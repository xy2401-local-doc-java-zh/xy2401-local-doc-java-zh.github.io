<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="This section describes how to adapt Garbage-First garbage collector (G1 GC) behavior in case it does not meet your requirements.">
      <meta name="description" content="This section describes how to adapt Garbage-First garbage collector (G1 GC) behavior in case it does not meet your requirements.">
      <title>Garbage-First Garbage Collector Tuning</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="HotSpot Virtual Machine Garbage Collection Tuning Guide">
      <meta property="og:description" content="This section describes how to adapt Garbage-First garbage collector (G1 GC) behavior in case it does not meet your requirements.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="HotSpot Virtual Machine Garbage Collection Tuning Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="hotspot-virtual-machine-garbage-collection-tuning-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2018-09-21T11:00:40-07:00">
      <meta name="dcterms.title" content="HotSpot Virtual Machine Garbage Collection Tuning Guide">
      <meta name="dcterms.dateCopyrighted" content="2015, 2018">
      <meta name="dcterms.category" content="java">
      <meta name="dcterms.identifier" content="E95201-01">
      
      <meta name="dcterms.product" content="en/java/javase/11">
      <meta name="dcterms.release" content="11">
      <link rel="prev" href="garbage-first-garbage-collector.html" title="Previous" type="text/html">
      <link rel="next" href="z-garbage-collector1.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"java","element_name":"Java","display_in_url":true},"suite":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product_group":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product":{"short_name":"javase","element_name":"Java SE","display_in_url":true},"release":{"short_name":"11","element_name":"11","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="GCTUNING">
  <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="garbage-first-garbage-collector.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="z-garbage-collector1.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">HotSpot Virtual Machine Garbage Collection Tuning Guide</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Garbage-First Garbage Collector Tuning</li>
            </ol>
            <a id="GUID-90E30ACA-8040-432E-B3A0-1E0440AB556A" name="GUID-90E30ACA-8040-432E-B3A0-1E0440AB556A"></a>
            
            <h2 id="JSGCT-GUID-90E30ACA-8040-432E-B3A0-1E0440AB556A" class="sect2"><span class="enumeration_chapter">10 </span>Garbage-First Garbage Collector Tuning
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This section describes how to adapt Garbage-First garbage collector (G1 GC) behavior in case it does not meet your requirements.</p>
               <div class="section">
                  <p class="subhead1" id="GUID-90E30ACA-8040-432E-B3A0-1E0440AB556A__GUID-85B75A91-240B-4DDC-BB87-BEA49959B39F">Topics</p>
                  <ul style="list-style-type: disc;">
                     <li><a href="garbage-first-garbage-collector-tuning.html#GUID-0BB3B742-A985-4D5E-A9C5-433A127FE0F6">General Recommendations for G1</a></li>
                     <li><a href="garbage-first-garbage-collector-tuning.html#GUID-E26056D1-02A5-4367-94EF-72C66D314AF7">Moving to G1 from Other Collectors</a></li>
                     <li><a href="garbage-first-garbage-collector-tuning.html#GUID-43ADE54E-2054-465C-8376-81CE92B6C1A4" title="This section describes the default values and some additional information about command-line options that are introduced in this topic.">Improving G1 Performance</a><ul style="list-style-type: disc;">
                           <li><a href="garbage-first-garbage-collector-tuning.html#GUID-0DD93225-0BCF-4605-B365-E9833F5BD2FC">Observing Full Garbage Collections</a></li>
                           <li><a href="garbage-first-garbage-collector-tuning.html#GUID-2428DA90-B93D-48E6-B336-A849ADF1C552">Humongous Object Fragmentation</a></li>
                           <li><a href="garbage-first-garbage-collector-tuning.html#GUID-4914A8D4-DE41-4250-B68E-816B58D4E278">Tuning for Latency</a><ul style="list-style-type: disc;">
                                 <li><a href="garbage-first-garbage-collector-tuning.html#GUID-8D9B2530-E370-4B8B-8ADD-A43674FC6658">Unusual System or Real-Time Usage</a></li>
                                 <li><a href="garbage-first-garbage-collector-tuning.html#GUID-40B64CD4-9844-4E3E-A0BB-81556AC04C74">Reference Object Processing Takes Too Long</a></li>
                                 <li><a href="garbage-first-garbage-collector-tuning.html#GUID-5FD5BDB1-DB7D-4E31-9296-19C0A28F810C">Young-Only Collections Within the Young-Only Phase Take Too Long</a></li>
                                 <li><a href="garbage-first-garbage-collector-tuning.html#GUID-D2B6ADCE-6766-4FF8-AA9D-B7F4F3D0F469">Mixed Collections Take Too Long</a></li>
                                 <li><a href="garbage-first-garbage-collector-tuning.html#GUID-A0343B53-A690-4DDE-98F9-9877096DBF0F">High Update RS and Scan RS Times</a></li>
                              </ul>
                           </li>
                           <li><a href="garbage-first-garbage-collector-tuning.html#GUID-70E3F150-B68E-4787-BBF1-F91315AC9AB9">Tuning for Throughput</a></li>
                           <li><a href="garbage-first-garbage-collector-tuning.html#GUID-0770AB01-E334-4E23-B307-FD2114B16E0E">Tuning for Heap Size</a></li>
                           <li><a href="garbage-first-garbage-collector-tuning.html#GUID-379B3888-FE24-4C3F-9E38-26434EB04F89" title="This section describes the default values and some additional information about command-line options that are introduced in this topic.">Tunable Defaults</a></li>
                        </ul>
                     </li>
                  </ul>
               </div>
               <!-- class="section" -->
            </div>
            <div class="sect2"><a id="GUID-0BB3B742-A985-4D5E-A9C5-433A127FE0F6" name="GUID-0BB3B742-A985-4D5E-A9C5-433A127FE0F6"></a><h3 id="JSGCT-GUID-0BB3B742-A985-4D5E-A9C5-433A127FE0F6" class="sect3">General Recommendations for G1</h3>
               <div>
                  <p>The general recommendation is to use G1 with its default settings, eventually giving it a different pause-time goal and setting a maximum Java heap size by using<code class="codeph"> -Xmx</code> if desired.
                  </p>
                  <p>G1 defaults have been balanced differently than either of the other collectors. G1's goals in the default configuration are neither maximum throughput nor lowest latency, but to provide relatively small, uniform pauses at high throughput. However, G1's mechanisms to incrementally reclaim space in the heap and the pause-time control incur some overhead in both the application threads and in the space-reclamation efficiency. </p>
                  <p>If you prefer high throughput, then relax the pause-time goal by using <code class="codeph">-XX:MaxGCPauseMillis </code>or provide a larger heap. If latency is the main requirement, then modify the pause-time target. Avoid limiting the young generation size to particular values by using options like <code class="codeph">-Xmn</code>,<code class="codeph"> -XX:NewRatio</code> and others because the young generation size is the main means for G1 to allow it to meet the pause-time. Setting the young generation size to a single value overrides and practically disables pause-time control.
                  </p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-E26056D1-02A5-4367-94EF-72C66D314AF7" name="GUID-E26056D1-02A5-4367-94EF-72C66D314AF7"></a><h3 id="JSGCT-GUID-E26056D1-02A5-4367-94EF-72C66D314AF7" class="sect3">Moving to G1 from Other Collectors</h3>
               <div>
                  <p>Generally, when moving to G1 from other collectors, particularly the Concurrent Mark Sweep collector, start by removing all options that affect garbage collection, and only set the pause-time goal and overall heap size by using <code class="codeph">-Xmx</code> and optionally <code class="codeph">-Xms</code>.
                  </p>
                  <p>Many options that are useful for other collectors to respond in some particular way, have either no effect at all, or even decrease throughput and the likelihood to meet the pause-time target. An example could be setting young generation sizes that completely prevent G1 from adjusting the young generation size to meet pause-time goals.</p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-43ADE54E-2054-465C-8376-81CE92B6C1A4" name="GUID-43ADE54E-2054-465C-8376-81CE92B6C1A4"></a><h3 id="JSGCT-GUID-43ADE54E-2054-465C-8376-81CE92B6C1A4" class="sect3">Improving G1 Performance</h3>
               <div>
                  <p>G1 is designed to provide good overall performance without the need to specify additional options. However, there are cases when the default heuristics or default configurations for them provide suboptimal results. This section gives some guidelines about diagnosing and improving in these cases. This guide describes only the possibilities that G1 provides to improve garbage collector performance in a selected metric, when given a set application. On a case-by-case basis, application-level optimizations could be more effective than trying to tune the VM to perform better, for example, by avoiding some problematic situations by less long-lived objects altogether.</p>
                  <p>For diagnosis purposes, G1 provides comprehensive logging. A good start is to use the <code class="codeph">-Xlog:gc*=debug</code> option and then refine the output from that if necessary. The log provides a detailed overview during and outside the pauses about garbage collection activity. This includes the type of collection and a breakdown of time spent in particular phases of the pause.
                  </p>
                  <p>The following subsections explore some common performance issues.</p>
               </div>
               <div class="sect3"><a id="GUID-0DD93225-0BCF-4605-B365-E9833F5BD2FC" name="GUID-0DD93225-0BCF-4605-B365-E9833F5BD2FC"></a><h4 id="JSGCT-GUID-0DD93225-0BCF-4605-B365-E9833F5BD2FC" class="sect4">Observing Full Garbage Collections</h4>
                  <div>
                     <p>A full heap garbage collection (Full GC) is often very time consuming. Full GCs caused by too high heap occupancy in the old generation can be detected by finding the words<span class="italic"> Pause Full (Allocation Failure) </span> in the log. Full GCs are typically preceded by garbage collections that encounter an evacuation failure indicated by <code class="codeph">to-space exhausted</code> tags.
                     </p>
                     <p>The reason that a Full GC occurs is because the application allocates too many objects that can't be reclaimed quickly enough. Often concurrent marking has not been able to complete in time to start a space-reclamation phase. The probability to run into a Full GC can be compounded by the allocation of many humongous objects. Due to the way these objects are allocated in G1, they may take up much more memory than expected.</p>
                     <p>The goal should be to ensure that concurrent marking completes on time. This can be achieved either by decreasing the allocation rate in the old generation, or giving the concurrent marking more time to complete.</p>
                     <p>G1 gives you several options to handle this situation better:</p>
                     <ul style="list-style-type: disc;">
                        <li>You can determine the number of regions occupied by humongous objects on the Java heap using the&nbsp;<code class="codeph">gc+heap=info</code> logging. <code class="codeph">Y</code> in the lines "<code class="codeph">Humongous regions:&nbsp;X-&gt;Y</code>” give you the amount of regions occupied by humongous objects. If this number is high compared to the number of old regions, the best option is to try to decrease this number of objects. You can achieve this by increasing the region size using the&nbsp;<code class="codeph"> -XX:G1HeapRegionSize</code> option. The currently selected heap region size is printed at the beginning of the log.
                        </li>
                        <li>Increase the size of the Java heap. This typically increases the amount of time marking has to complete.</li>
                        <li>Increase the number of concurrent marking threads by setting <code class="codeph">-XX:ConcGCThreads</code> explicitly.
                        </li>
                        <li>Force G1 to start marking earlier. G1 automatically determines the Initiating Heap Occupancy Percent (IHOP) threshold based on earlier application behavior. If the application behavior changes, these predictions might be wrong. There are two options: Lower the target occupancy for when to start space-reclamation by increasing the buffer used in an adaptive IHOP calculation by modifying <code class="codeph">-XX:G1ReservePercent</code>; or, disable the adaptive calculation of the IHOP by setting it manually using <code class="codeph">-XX:-G1UseAdaptiveIHOP</code> and<code class="codeph"> -XX:InitiatingHeapOccupancyPercent</code>.
                        </li>
                     </ul>
                     <p>Other causes than Allocation Failure for a Full GC typically indicate that either the application or some external tool causes a full heap collection. If the cause is<code class="codeph"> System.gc()</code>, and there is no way to modify the application sources, the effect of Full GCs can be mitigated by using<code class="codeph"> -XX:+ExplicitGCInvokesConcurrent</code> or let the VM completely ignore them by setting <code class="codeph">-XX:+DisableExplicitGC</code>. External tools may still force Full GCs; they can be removed only by not requesting them.
                     </p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-2428DA90-B93D-48E6-B336-A849ADF1C552" name="GUID-2428DA90-B93D-48E6-B336-A849ADF1C552"></a><h4 id="JSGCT-GUID-2428DA90-B93D-48E6-B336-A849ADF1C552" class="sect4">Humongous Object Fragmentation</h4>
                  <div>
                     <p>A Full GC could occur before all Java heap memory has been exhausted due to the necessity of finding a contiguous set of regions for them. Potential options in this case are increasing the heap region size by using the option <code class="codeph"> -XX:G1HeapRegionSize </code>to decrease the number of humongous objects, or increasing size of the heap. In extreme cases, there might not be enough contiguous space available for G1 to allocate the object even if available memory indicates otherwise. This would lead to a VM exit if that Full GC can not reclaim enough contiguous space. As a result, there are no other options than either decreasing the amount of humongous object allocations as mentioned previously, or increasing the heap.
                     </p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-4914A8D4-DE41-4250-B68E-816B58D4E278" name="GUID-4914A8D4-DE41-4250-B68E-816B58D4E278"></a><h4 id="JSGCT-GUID-4914A8D4-DE41-4250-B68E-816B58D4E278" class="sect4">Tuning for Latency</h4>
                  <div>
                     <p>This section discusses hints to improve G1 behavior in case of common latency problems that is, if the pause-time is too high.</p>
                  </div>
                  <div class="sect4"><a id="GUID-8D9B2530-E370-4B8B-8ADD-A43674FC6658" name="GUID-8D9B2530-E370-4B8B-8ADD-A43674FC6658"></a><h5 id="JSGCT-GUID-8D9B2530-E370-4B8B-8ADD-A43674FC6658" class="sect5">Unusual System or Real-Time Usage</h5>
                     <div>
                        <p>For every garbage collection pause, the <code class="codeph">gc+cpu=info</code> log output contains a line including information from the operating system with a breakdown about where during the pause-time has been spent. An example for such output is <code class="codeph">User=0.19s Sys=0.00s Real=0.01s</code>.
                        </p>
                        <p>User time is time spent in VM code,<span class="variable" translate="no"> system time </span>is the time spent in the operating system, and <span class="variable" translate="no">real time</span> is the amount of absolute time passed during the pause. If the system time is relatively high, then most often the environment is the cause.
                        </p>
                        <p>Common known issues for high system time are:</p>
                        <ul style="list-style-type: disc;">
                           <li>The VM allocating or giving back memory from the operating system memory may cause unnecessary delays. Avoid the delays by setting minimum and maximum heap sizes to the same value using the options <code class="codeph">-Xms</code> and<code class="codeph"> -Xmx</code>, and pre-touching all memory using <code class="codeph">-XX:+AlwaysPreTouch</code> to move this work to the VM startup phase.
                           </li>
                           <li>Particularly in Linux, coalescing of small pages into huge pages by the <span class="italic">Transparent Huge Pages (THP)</span> feature tends to stall random processes, not just during a pause. Because the VM allocates and maintains a lot of memory, there is a higher than usual risk that the VM will be the process that stalls for a long time. Refer to the documentation of your operating system on how to disable the Transparent Huge Pages feature.
                           </li>
                           <li>Writing the log output may stall for some time because of some background task intermittently taking up all I/O bandwidth for the hard disk the log is written to. Consider using a separate disk for your logs or some other storage, for example memory-backed file system to avoid this.</li>
                        </ul>
                        <p> Another situation to look out for is real time being a lot larger than the sum of the others this may indicate that the VM did not get enough CPU time on a possibly overloaded machine.</p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-40B64CD4-9844-4E3E-A0BB-81556AC04C74" name="GUID-40B64CD4-9844-4E3E-A0BB-81556AC04C74"></a><h5 id="JSGCT-GUID-40B64CD4-9844-4E3E-A0BB-81556AC04C74" class="sect5">Reference Object Processing Takes Too Long</h5>
                     <div>
                        <p>Information about the time taken for processing of Reference Objects is shown in the <code class="codeph">Reference Processing</code> phase. During the <code class="codeph">Reference Processing</code> phase, G1 updates the referents of Reference Objects according to the requirements of the particular type of Reference Object. By default, G1 tries to parallelize the sub-phases of <code class="codeph">Reference Processing</code> using the following heuristic: for every <code class="codeph">-XX:ReferencesPerThread</code> reference Objects start a single thread, bounded by the value in <code class="codeph">-XX:ParallelGCThreads</code>. This heuristic can be disabled by setting <code class="codeph">-XX:ReferencesPerThread</code> to 0 to use all available threads by default, or parallelization disabled completely by <code class="codeph">-XX:-ParallelRefProcEnabled</code>.
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-5FD5BDB1-DB7D-4E31-9296-19C0A28F810C" name="GUID-5FD5BDB1-DB7D-4E31-9296-19C0A28F810C"></a><h5 id="JSGCT-GUID-5FD5BDB1-DB7D-4E31-9296-19C0A28F810C" class="sect5">Young-Only Collections Within the Young-Only Phase Take Too Long</h5>
                     <div>
                        <p>Normal young and, in general any young collection roughly takes time proportional to the size of the young generation, or more specifically, the number of live objects within the collection set that needs to be copied. If the <span class="italic">Evacuate Collection Set </span> phase takes too long, in particular, the <span class="italic">Object Copy</span> sub-phase, decrease <code class="codeph">-XX:G1NewSizePercent</code>. This decreases the minimum size of the young generation, allowing for potentially shorter pauses.
                        </p>
                        <p>Another problem with sizing of the young generation may occur if application performance, and in particular the amount of objects surviving a collection, suddenly changes. This may cause spikes in garbage collection pause time. It might be useful to decrease the maximum young generation size by using <code class="codeph">-XX:G1MaxNewSizePercent</code>. This limits the maximum size of the young generation and so the number of objects that need to be processed during the pause.
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-D2B6ADCE-6766-4FF8-AA9D-B7F4F3D0F469" name="GUID-D2B6ADCE-6766-4FF8-AA9D-B7F4F3D0F469"></a><h5 id="JSGCT-GUID-D2B6ADCE-6766-4FF8-AA9D-B7F4F3D0F469" class="sect5">Mixed Collections Take Too Long</h5>
                     <div>
                        <p>Mixed collections are used to reclaim space in the old generation. The collection set of mixed collections contains young and old generation regions. You can obtain information about how much time evacuation of either young or old generation regions contribute to the pause-time by enabling the <code class="codeph">gc+ergo+cset=trace</code> log output. Look at the <span class="italic">predicted young region</span> time and <span class="italic">predicted old region</span> time for young and old generation regions respectively.
                        </p>
                        <p>If the predicted young region time is too long, then see <a href="garbage-first-garbage-collector-tuning.html#GUID-5FD5BDB1-DB7D-4E31-9296-19C0A28F810C">Young-Only Collections Within the Young-Only Phase Take Too Long</a> for options. Otherwise, to reduce the contribution of the old generation regions to the pause-time, G1 provides three options:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Spread the old generation region reclamation across more garbage collections by increasing <code class="codeph">-XX:G1MixedGCCountTarget</code>.
                              </p>
                           </li>
                           <li>
                              <p>Avoid collecting regions that take a proportionally large amount of time to collect by not putting them into the candidate collection set by using -<code class="codeph">XX:G1MixedGCLiveThresholdPercent</code>. In many cases, highly occupied regions take a lot of time to collect.
                              </p>
                           </li>
                           <li>
                              <p>Stop old generation space reclamation earlier so that G1 won't collect as many highly occupied regions. In this case, increase<code class="codeph"> -XX:G1HeapWastePercent</code>.
                              </p>
                           </li>
                        </ul>
                        <p>Note that the last two options decrease the amount of collection set candidate regions where space can be reclaimed for the current space-reclamation phase. This may mean that G1 may not be able to reclaim enough space in the old generation for sustained operation. However, later space-reclamation phases may be able to garbage collect them.</p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-A0343B53-A690-4DDE-98F9-9877096DBF0F" name="GUID-A0343B53-A690-4DDE-98F9-9877096DBF0F"></a><h5 id="JSGCT-GUID-A0343B53-A690-4DDE-98F9-9877096DBF0F" class="sect5">High Update RS and Scan RS Times</h5>
                     <div>
                        <p>To enable G1 to evacuate single old generation regions, G1 tracks locations of <span class="italic">cross-region references</span>, that is references that point from one region to another. The set of cross-region references pointing into a given region is called that region's <span class="italic">remembered set</span>. The remembered sets must be updated when moving the contents of a region. Maintenance of the regions' remembered sets is mostly concurrent. For performance purposes, G1 doesn't immediately update the remembered set of a region when the application installs a new cross-region reference between two objects. Remembered set update requests are delayed and batched for efficiency.
                        </p>
                        <p>G1 requires complete remembered sets for garbage collection, so the <span class="italic">Update RS </span> phase of the garbage collection processes any outstanding remembered set update requests. The<span class="italic"> Scan RS </span> phase searches for object references in remembered sets, moves region contents, and then updates these object references to the new locations. Depending on the application, these two phases may take a significant amount of time.
                        </p>
                        <p>Adjusting the size of the heap regions by using the option <code class="codeph"> -XX:G1HeapRegionSize</code> affects the number of cross-region references and as well as the size of the remembered set. Handling the remembered sets for regions may be a significant part of garbage collection work, so this has a direct effect on the achievable maximum pause time. Larger regions tend to have fewer cross-region references, so the relative amount of work spent in processing them decreases, although at the same time, larger regions may mean more live objects to evacuate per region, increasing the time for other phases.
                        </p>
                        <p>G1 tries to schedule concurrent processing of the remembered set updates so that the Update RS phase takes approximately <code class="codeph">-XX:G1RSetUpdatingPauseTimePercent</code> percent of the allowed maximum pause time. By decreasing this value, G1 usually performs more remembered set update work concurrently.
                        </p>
                        <p>Spurious high Update RS times in combination with the application allocating large objects may be caused by an optimization that tries to reduce concurrent remembered set update work by batching it. If the application that created such a batch happens just before a garbage collection, then the garbage collection must process all this work in the Update RS times part of the pause. Use<code class="codeph"> -XX:-ReduceInitialCardMarks </code> to disable this behavior and potentially avoid these situations.
                        </p>
                        <p>Scan RS Time is also determined by the amount of compression that G1 performs to keep remembered set storage size low. The more compact the remembered set is stored in memory, the more time it takes to retrieve the stored values during garbage collection. G1 automatically performs this compression, called remembered set coarsening, while updating the remembered sets depending on the current size of that region's remembered set. Particularly at the highest compression level, retrieving the actual data can be very slow. The option <code class="codeph">-XX:G1SummarizeRSetStatsPeriod</code> in combination with<code class="codeph"> gc+remset=trace</code> level logging shows if this coarsening occurs. If so, then the <code class="codeph">X </code> in the line <code class="codeph">Did &lt;X&gt; coarsenings</code> in the<span class="italic"> Before GC Summary</span> section shows a high value. The <code class="codeph">-XX:G1RSetRegionEntries</code> option could be increased significantly to decrease the amount of these coarsenings. Avoid using this detailed remembered set logging in production environments as collecting this data can take a significant amount of time.
                        </p>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-70E3F150-B68E-4787-BBF1-F91315AC9AB9" name="GUID-70E3F150-B68E-4787-BBF1-F91315AC9AB9"></a><h4 id="JSGCT-GUID-70E3F150-B68E-4787-BBF1-F91315AC9AB9" class="sect4">Tuning for Throughput</h4>
                  <div>
                     <p>G1's default policy tries to maintain a balance between throughput and latency; however, there are situations where higher throughput is desirable. Apart from decreasing the overall pause-times as described in the previous sections, the frequency of the pauses could be decreased. The main idea is to increase the maximum pause time by using <code class="codeph">-XX:MaxGCPauseMillis</code>. The generation sizing heuristics will automatically adapt the size of the young generation, which directly determines the frequency of pauses. If that does not result in expected behavior, particularly during the space-reclamation phase, increasing the minimum young generation size using<code class="codeph"> -XX:G1NewSizePercent</code> will force G1 to do that.
                     </p>
                     <p>In some cases, <code class="codeph">-XX:G1MaxNewSizePercent</code>, the maximum allowed young generation size, may limit throughput by limiting young generation size. This can be diagnosed by looking at region summary output of <code class="codeph">gc+heap=info</code> logging. In this case the combined percentage of Eden regions and Survivor regions is close to <code class="codeph">-XX:G1MaxNewSizePercent</code> percent of the total number of regions. Consider increasing<code class="codeph">-XX:G1MaxNewSizePercent</code> in this case.
                     </p>
                     <p>Another option to increase throughput is to try to decrease the amount of concurrent work in particular, concurrent remembered set updates often require a lot of CPU resources. Increasing<code class="codeph"> -XX:G1RSetUpdatingPauseTimePercent</code> moves work from concurrent operation into the garbage collection pause. In the worst case, concurrent remembered set updates can be disabled by setting <code class="codeph">-XX:-G1UseAdaptiveConcRefinement</code> <code class="codeph">-XX:G1ConcRefinementGreenZone=</code><code class="codeph">2G</code> <code class="codeph">-XX:G1ConcRefinementThreads=</code><code class="codeph">0</code>. This mostly disables this mechanism and moves all remembered set update work into the next garbage collection pause.
                     </p>
                     <p>Enabling the use of large pages by using <code class="codeph">-XX:+UseLargePages</code> may also improve throughput. Refer to your operating system documentation on how to set up large pages.
                     </p>
                     <p>You can minimize heap resizing work by disabling it; set the options <code class="codeph">-Xms </code> and <code class="codeph">-Xmx </code> to the same value. In addition, you can use <code class="codeph">-XX:+AlwaysPreTouch</code> to move the operating system work to back virtual memory with physical memory to VM startup time.  Both of these measures can be particularly desirable in order to make pause-times more consistent.
                     </p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-0770AB01-E334-4E23-B307-FD2114B16E0E" name="GUID-0770AB01-E334-4E23-B307-FD2114B16E0E"></a><h4 id="JSGCT-GUID-0770AB01-E334-4E23-B307-FD2114B16E0E" class="sect4">Tuning for Heap Size</h4>
                  <div>
                     <p>Like other collectors, G1 aims to size the heap so that the time spent in garbage collection is below the ratio determined by the <code class="codeph">-XX:GCTimeRatio</code> option. Adjust this option to make G1 meet your requirements.
                     </p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-379B3888-FE24-4C3F-9E38-26434EB04F89" name="GUID-379B3888-FE24-4C3F-9E38-26434EB04F89"></a><h4 id="JSGCT-GUID-379B3888-FE24-4C3F-9E38-26434EB04F89" class="sect4">Tunable Defaults</h4>
                  <div>
                     <p>This section describes the default values and some additional information about command-line options that are introduced in this topic.</p>
                     <div class="section">
                        <div class="tblformal" id="GUID-379B3888-FE24-4C3F-9E38-26434EB04F89__ERGONOMICDEFAULTSFORDETERMINISTICG1-9C74ED9D">
                           <p class="titleintable">Table 10-1 Tunable Defaults  G1 GC</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="Tunable Defaults  G1 GC" summary="Tunable defaults for G1 GC" width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="46%" id="d5396e627">Option and Default Value </th>
                                    <th align="left" valign="bottom" width="54%" id="d5396e630">Description</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="46%" id="d5396e635" headers="d5396e627 ">
                                       <p><code class="codeph">-XX:+G1UseAdaptiveConcRefinement</code></p>
                                       <p><code class="codeph"> -XX:G1ConcRefinementGreenZone=</code><span class="italic">&lt;ergo&gt;</span> 
                                       </p>
                                       <p><code class="codeph">-XX:G1ConcRefinementYellowZone=</code><span class="italic">&lt;ergo&gt;</span></p>
                                       <p> <code class="codeph">-XX:G1ConcRefinementRedZone=</code><span class="italic">&lt;ergo&gt;</span></p>
                                       <p> <code class="codeph">-XX:G1ConcRefinementThreads=</code><span class="italic">&lt;ergo&gt;</span></p>
                                    </td>
                                    <td align="left" valign="top" width="54%" headers="d5396e635 d5396e630 ">
                                       <p>The concurrent remembered set update (refinement) uses these options to control the work distribution of concurrent refinement threads. G1 chooses the ergonomic values for these options so that <code class="codeph">-XX:G1RSetUpdatingPauseTimePercent</code> time is spent in the garbage collection pause for processing any remaining work, adaptively adjusting them as needed. Change with caution because this may cause extremely long pauses.
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="46%" id="d5396e669" headers="d5396e627 ">
                                       <p><code class="codeph">-XX:+ReduceInitialCardMarks</code></p>
                                    </td>
                                    <td align="left" valign="top" width="54%" headers="d5396e669 d5396e630 ">
                                       <p>This batches together concurrent remembered set update (refinement) work for initial object allocations.</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="46%" id="d5396e677" headers="d5396e627 ">
                                       <p><code class="codeph">-XX:+ParallelRefProcEnabled</code></p>
                                       <p><code class="codeph">-XX:ReferencesPerThread=1000</code></p>
                                    </td>
                                    <td align="left" valign="top" width="54%" headers="d5396e677 d5396e630 ">
                                       <p><code class="codeph">-XX:ReferencesPerThread</code> determines the degree of parallelization: for every <span class="italic">N</span> Reference Objects one thread will participate in the sub-phases of Reference Processing, limited by <code class="codeph">-XX:ParallelGCThreads</code>. A value of 0 indicates that the maximum number of threads as indicated by the value of <code class="codeph">-XX:ParallelGCThreads</code> will always be used.&nbsp;
                                       </p>
                                       <p>This determines whether processing of<span class="apiname"> java.lang.Ref.*</span> instances should be done in parallel by multiple threads.
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="46%" id="d5396e704" headers="d5396e627 ">
                                       <p><code class="codeph">-XX:G1RSetUpdatingPauseTimePercent=</code><code class="codeph">10</code>&nbsp;
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="54%" headers="d5396e704 d5396e630 ">
                                       <p>This determines the percentage of total garbage collection time G1 should spend in the Update RS phase updating any remaining remembered sets. G1 controls the amount of concurrent remembered set updates using this setting.</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="46%" id="d5396e715" headers="d5396e627 ">
                                       <p><code class="codeph">-XX:G1SummarizeRSetStatsPeriod=</code><code class="codeph">0</code>&nbsp;
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="54%" headers="d5396e715 d5396e630 ">
                                       <p>This is the period in a number of GCs that G1 generates remembered set summary reports. Set this to zero to disable. Generating remembered set summary reports is a costly operation, so it should be used only if necessary, and with a reasonably high value. Use<code class="codeph"> gc+remset=trace</code> to print anything.
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="46%" id="d5396e729" headers="d5396e627 ">
                                       <p><code class="codeph">-XX:GCTimeRatio=</code><code class="codeph">12</code>&nbsp;
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="54%" headers="d5396e729 d5396e630 ">
                                       <p>This is the divisor for the target ratio of time that should be spent in garbage collection as opposed to the application. The actual formula for determining the target fraction of time that can be spent in garbage collection before increasing the heap is<code class="codeph"> 1 / (1 + GCTimeRatio)</code>. This default value results in a target with about 8% of the time to be spent in garbage collection.
                                       </p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <div class="infoboxnote" id="GUID-379B3888-FE24-4C3F-9E38-26434EB04F89__GUID-158B2AD4-B43D-4956-A474-67EAD0594471">
                           <p class="notep1">Note:</p><code class="codeph">&lt;ergo&gt;</code> means that the actual value is determined ergonomically depending on the environment.
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>
