<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="The Java Secure Socket Extension (JSSE) enables secure Internet communications. It provides a framework and an implementation for a Java version of the TLS and DTLS protocols and includes functionality for data encryption, server authentication, message integrity, and optional client authentication.">
      <meta name="description" content="The Java Secure Socket Extension (JSSE) enables secure Internet communications. It provides a framework and an implementation for a Java version of the TLS and DTLS protocols and includes functionality for data encryption, server authentication, message integrity, and optional client authentication.">
      <title>Java Secure Socket Extension (JSSE) Reference Guide</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Security Developer’s Guide">
      <meta property="og:description" content="The Java Secure Socket Extension (JSSE) enables secure Internet communications. It provides a framework and an implementation for a Java version of the TLS and DTLS protocols and includes functionality for data encryption, server authentication, message integrity, and optional client authentication.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Security Developer’s Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="security-developer-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2018-09-21T08:42:26-07:00">
      
      <meta name="dcterms.dateCopyrighted" content="1993, 2018">
      <meta name="dcterms.category" content="java">
      <meta name="dcterms.identifier" content="E94828-01">
      
      <meta name="dcterms.product" content="en/java/javase/11">
      <meta name="dcterms.release" content="11">
      <link rel="prev" href="kerberos-5-gss-api-mechanism.html" title="Previous" type="text/html">
      <link rel="next" href="running-jsse-sample-code1.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"java","element_name":"Java","display_in_url":true},"suite":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product_group":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product":{"short_name":"javase","element_name":"Java SE","display_in_url":true},"release":{"short_name":"11","element_name":"11","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Security Developer Guide">
    <meta name="dcterms.isVersionOf" content="SECURITY">
  <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="kerberos-5-gss-api-mechanism.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="running-jsse-sample-code1.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Security Developer’s Guide</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Java Secure Socket Extension (JSSE) Reference Guide</li>
            </ol>
            <a id="GUID-93DEEE16-0B70-40E5-BBE7-55C3FD432345" name="GUID-93DEEE16-0B70-40E5-BBE7-55C3FD432345"></a>
            
            <h2 id="JSSEC-GUID-93DEEE16-0B70-40E5-BBE7-55C3FD432345" class="sect2"><span class="enumeration_chapter">8 </span>Java Secure Socket Extension (JSSE) Reference Guide
            </h2>
         </header>
         <div class="ind"><script type="text/javascript">window.name='java-secure-socket-extension-jsse-reference-guide'</script><script type="text/javascript">
    function footdisplay(footnum,footnote) {
    var msg = window.open('about:blank', 'NewWindow' + footnum,
        'directories=no,height=100,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');
    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'); 
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us" dir="ltr"><head><title>');
   
    msg.document.write('Footnote&nbsp; ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('<meta http-equiv="Content-Script-Type" ');
    msg.document.write('content="text/javascript" />');
    msg.document.write('<style type="text/css"> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]\u003e <\/style>');
    msg.document.write('<\/head><body><div id="footnote"><h1>Footnote&nbsp; ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/div><\/body><\/html>');
    msg.document.close();
    setTimeout(function() {
        var height = msg.document.getElementById('footnote').offsetHeight;
        msg.resizeTo(598, height + 100);
    }
    , 100);
    msg.focus();
}
            </script><noscript>
               <p>The script content on this page is for navigation purposes only and does not alter the content in any way.</p>
            </noscript>
            <div>
               <p>The Java Secure Socket Extension (JSSE) enables secure Internet communications. It provides a framework and an implementation for a Java version of the TLS and DTLS protocols and includes functionality for data encryption, server authentication, message integrity, and optional client authentication.</p>
            </div>
            <div class="sect2"><a id="GUID-0EF5DA4E-856C-4AD2-A9FD-0837C5881DDA" name="GUID-0EF5DA4E-856C-4AD2-A9FD-0837C5881DDA"></a><h3 id="JSSEC-GUID-0EF5DA4E-856C-4AD2-A9FD-0837C5881DDA" class="sect3">Introduction to JSSE</h3>
               <div>
                  <p>Data that travels across a network can easily be accessed by someone who is not the intended recipient. When the data includes private information, such as passwords and credit card numbers, steps must be taken to make the data unintelligible to unauthorized parties. It is also important to ensure that the data has not been modified, either intentionally or unintentionally, during transport. The Transport Layer Security (TLS) protocol was designed to help protect the privacy and integrity of data while it is being transferred across a network.</p>
                  <div class="section">
                     <p>The Java Secure Socket Extension (JSSE) enables secure Internet communications. It provides a framework and an implementation for a Java version of the TLS protocol and includes functionality for data encryption, server authentication, message integrity, and optional client authentication. Using JSSE, developers can provide for the secure passage of data between a client and a server running any application protocol (such as HTTP, Telnet, or FTP) over TCP/IP.</p>
                     <p>By abstracting the complex underlying security algorithms and handshaking mechanisms, JSSE minimizes the risk of creating subtle but dangerous security vulnerabilities. Furthermore, it simplifies application development by serving as a building block that developers can integrate directly into their applications.</p>
                     <p>JSSE provides both an application programming interface (API) framework and an implementation of that API. The JSSE API supplements the core network and cryptographic services defined by the <code class="codeph">java.security</code> and <code class="codeph">java.net</code> packages by providing extended networking socket classes, trust managers, key managers, SSL contexts, and a socket factory framework for encapsulating socket creation behavior. Because the <code class="codeph">SSLSocket</code> class is based on a blocking I/O model, the Java Development Kit (JDK) includes a nonblocking <code class="codeph">SSLEngine</code> class to enable implementations to choose their own I/O methods.
                     </p>
                     <p>The JSSE API supports the following security protocols:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>DTLS: versions 1.0 and 1.2</p>
                        </li>
                        <li>
                           <p>TLS: version 1.0, 1.1, 1.2, and 1.3</p>
                        </li>
                        <li>
                           <p>SSL (Secure Socket Layer): version 3.0</p>
                        </li>
                     </ul>
                     <p>These security protocols encapsulate a normal bidirectional stream socket, and the JSSE API adds transparent support for authentication, encryption, and integrity protection.</p>
                     <p>JSSE is a security component of the Java SE platform, and is based on the same design principles found elsewhere in the <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-2BCFDD85-D533-4E6C-8CE9-29990DEB0190" title='The Java Cryptography Architecture (JCA) is a major piece of the platform, and contains a "provider" architecture and a set of APIs for digital signatures, message digests (hashes), certificates and certificate validation, encryption (symmetric/asymmetric block/stream ciphers), key generation and management, and secure random number generation, to name a few.'>Java Cryptography Architecture (JCA) Reference Guide</a> framework. This framework for cryptography-related security components allows them to have implementation independence and, whenever possible, algorithm independence. JSSE uses the <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-3E0744CE-6AC7-4A6D-A1F6-6C01199E6920">Cryptographic Service Providers</a> defined by the JCA framework.
                     </p>
                     <p>Other security components in the Java SE platform include the <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jaas/JAASRefGuide.html" target="_blank">Java Authentication and Authorization Service (JAAS) Reference Guide</a> and the <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/java/javase/11/security&amp;id=JSWOR691" target="_blank">Java Security Tools</a>. JSSE encompasses many of the same concepts and algorithms as those in JCA but automatically applies them underneath a simple stream socket API.
                     </p>
                     <p>The JSSE API was designed to allow other SSL/TLS/DTLS protocols and Public Key Infrastructure (PKI) implementations to be plugged in seamlessly. Developers can also provide alternative logic to determine if remote hosts should be trusted or what authentication key material should be sent to a remote host.</p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div class="sect3"><a id="GUID-F069F4ED-DF2C-4B3B-90FB-F89E700CF21A" name="GUID-F069F4ED-DF2C-4B3B-90FB-F89E700CF21A"></a><h4 id="JSSEC-GUID-F069F4ED-DF2C-4B3B-90FB-F89E700CF21A" class="sect4">JSSE Features and Benefits</h4>
                  <div>
                     <p>JSSE includes the following important benefits and features:</p>
                     <ul style="list-style-type: disc;">
                        <li>Included as a standard component of the JDK</li>
                        <li>Extensible, provider-based architecture</li>
                        <li>Implemented in 100% pure Java</li>
                        <li>Provides API support for TLS/DTLS</li>
                        <li>Provides implementations of SSL 3.0, TLS (versions 1.0, 1.1, 1.2, and 1.3), and DTLS (versions 1.0 and 1.2)</li>
                        <li>Includes classes that can be instantiated to create secure channels (<code class="codeph">SSLSocket</code>, <code class="codeph">SSLServerSocket</code>, and <code class="codeph">SSLEngine</code>)
                        </li>
                        <li>Provides support for cipher suite negotiation, which is part of the TLS/DTLS handshaking used to initiate or verify secure communications</li>
                        <li>Provides support for client and server authentication, which is part of the normal TLS/DTLS handshaking</li>
                        <li>Provides support for HTTP encapsulated in the TLS protocol, which allows access to data such as web pages using HTTPS</li>
                        <li>Provides server session management APIs to manage memory-resident SSL sessions</li>
                        <li>Provides support for the certificate status request extension (OCSP stapling), which saves client certificate validation round-trips and resources</li>
                        <li>Provides support for the Server Name Indication (SNI) rxtension, which extends the TLS/DTLS protocols to indicate what server name the client is attempting to connect to during handshaking</li>
                        <li>Provides support for endpoint identification during handshaking, which prevents man-in-the-middle attacks</li>
                        <li>Provides support for cryptographic algorithm constraints, which provides fine-grained control over algorithms negotiated by JSSE</li>
                     </ul>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-2DF22C2B-C32E-4665-BB4B-E9510865FDC0" name="GUID-2DF22C2B-C32E-4665-BB4B-E9510865FDC0"></a><h4 id="JSSEC-GUID-2DF22C2B-C32E-4665-BB4B-E9510865FDC0" class="sect4">JSSE Standard API</h4>
                  <div>
                     <p>The JSSE standard API, available in the <code class="codeph">javax.net</code> and <code class="codeph">javax.net.ssl</code> packages, provides:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>Secure sockets tailored to client and server-side applications.</li>
                        <li>A non-blocking engine for producing and consuming streams of TLS/DTLS data (<code class="codeph">SSLEngine</code>).
                        </li>
                        <li>Factories for creating sockets, server sockets, SSL sockets, and SSL server sockets. By using socket factories, you can encapsulate socket creation and configuration behavior.</li>
                        <li>A class representing a secure socket context that acts as a factory for secure socket factories and engines.</li>
                        <li>Key and trust manager interfaces (including X.509-specific key and trust managers), and factories that can be used for creating them.</li>
                        <li>A class for secure HTTP URL connections (HTTPS).</li>
                     </ul>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-59EC25A8-4CE4-4D94-896B-8E6FB23C2838" name="GUID-59EC25A8-4CE4-4D94-896B-8E6FB23C2838"></a><h4 id="JSSEC-GUID-59EC25A8-4CE4-4D94-896B-8E6FB23C2838" class="sect4">SunJSSE Provider</h4>
                  <div>
                     <p>Oracle's implementation of Java SE includes a JSSE provider named <span class="variable" translate="no">SunJSSE</span>, which comes preinstalled and preregistered with the JCA. This provider supplies the following cryptographic services:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>An implementation of the SSL 3.0, TLS (versions 1.0, 1.1, 1.2, and 1.3), and DTLS (versions 1.0 and 1.2) security protocols.</li>
                        <li>An implementation of the most common TLS and DTLS cipher suites. This implementation encompasses a combination of authentication, key agreement, encryption, and integrity protection.</li>
                        <li>An implementation of an X.509-based key manager that chooses appropriate authentication keys from a standard JCA keystore.</li>
                        <li>An implementation of an X.509-based trust manager that implements rules for certificate chain validation.</li>
                     </ul>
                     <p>See <a href="oracle-providers.html#GUID-7093246A-31A3-4304-AC5F-5FB6400405E2">The SunJSSE Provider</a>.
                     </p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-DF5DA7C2-7B13-4341-B8F2-E4A64F8C0FFA" name="GUID-DF5DA7C2-7B13-4341-B8F2-E4A64F8C0FFA"></a><h4 id="JSSEC-GUID-DF5DA7C2-7B13-4341-B8F2-E4A64F8C0FFA" class="sect4">JSSE Related Documentation</h4>
                  <div>
                     <p>The following list contains links to online documentation and names of books about related subjects:</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-DF5DA7C2-7B13-4341-B8F2-E4A64F8C0FFA__GUID-F6CBD4B8-8264-4D13-BA0B-BC3D04F23303">JSSE API Documentation</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="https://docs.oracle.com/javase/10/docs/api/javax/net/package-summary.html" target="_blank"><span class="apiname">javax.net</span></a> package
                              </p>
                           </li>
                           <li>
                              <p><a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/package-summary.html" target="_blank"><span class="apiname">javax.net.ssl</span></a> package
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-DF5DA7C2-7B13-4341-B8F2-E4A64F8C0FFA__GUID-107C6EEB-EE4B-47D2-8F8D-9A6414BE4E36">Java SE Security</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The <a href="http://www.oracle.com/technetwork/java/javase/tech/index-jsp-136007.html" target="_blank">Java SE Security</a> home page
                              </p>
                           </li>
                           <li>
                              <p>The <a href="https://docs.oracle.com/javase/tutorial/security/" target="_blank">Security Features in Java SE</a> trail of the Java Tutorial
                              </p>
                           </li>
                           <li>
                              <p><a href="java-pki-programmers-guide.html#GUID-650D0D53-B617-4055-AFD3-AF5C2629CBBF" title="The Java Certification Path API consists of classes and interfaces for handling certification paths, which are also called certification chains. If a certification path meets certain validation rules, it may be used to securely establish the mapping of a public key to a subject.">Java PKI Programmers Guide</a></p>
                           </li>
                           <li>
                              <p><a href="http://www.oracle.com/technetwork/java/javaee/gong-135902.html" target="_blank">Inside Java 2 Platform Security, Second Edition: Architecture, API Design and Implementation</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-DF5DA7C2-7B13-4341-B8F2-E4A64F8C0FFA__GUID-B86C493A-4053-4532-945F-EE2D62C7929F">Transport Layer Security (TLS)</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="http://www.ietf.org/rfc/rfc2246.txt" target="_blank">The TLS Protocol Version 1.0</a></p>
                           </li>
                           <li>
                              <p><a href="https://www.ietf.org/rfc/rfc4346.txt" target="_blank">The TLS Protocol Version 1.1</a></p>
                           </li>
                           <li>
                              <p><a href="https://www.ietf.org/rfc/rfc5246.txt" target="_blank">The TLS Protocol Version 1.2</a></p>
                           </li>
                           <li>
                              <p><a href="https://tools.ietf.org/html/rfc8446" target="_blank">The (TLS) Protocol Version 1.3</a></p>
                           </li>
                           <li>
                              <p><a href="https://tools.ietf.org/html/rfc6066" target="_blank">Transport Layer Security (TLS) Extensions</a></p>
                           </li>
                           <li>
                              <p><a href="http://www.ietf.org/rfc/rfc2818.txt" target="_blank">HTTP Over TLS</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-DF5DA7C2-7B13-4341-B8F2-E4A64F8C0FFA__GUID-A4325643-AE73-4989-90F4-CB43BE53F298">Datagram Transport Layer Security (DTLS)</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="https://tools.ietf.org/html/rfc4347.txt" target="_blank">The DTLS Protocol Version 1.0</a></p>
                           </li>
                           <li>
                              <p><a href="https://tools.ietf.org/html/rfc6347.txt" target="_blank">The DTLS Protocol Version 1.2</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-DF5DA7C2-7B13-4341-B8F2-E4A64F8C0FFA__GUID-9FD2E015-BE86-4ADC-9554-DCCC17A7A5B1">U.S. Encryption Policies</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="http://www.commerce.gov/" target="_blank">U.S. Department of Commerce</a></p>
                           </li>
                           <li>
                              <p><a href="http://www.techceocouncil.org" target="_blank">Technology CEO Council</a></p>
                           </li>
                           <li>
                              <p>Current export policies: <a href="https://www.bis.doc.gov/index.php/policy-guidance/encryption" target="_blank">Encryption and Export Administration Regulations (EAR)</a></p>
                           </li>
                           <li>
                              <p><a href="http://csrc.nist.gov/publications/index.html" target="_blank">NIST Computer Security Publications</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-B7AB25FA-7F0C-4EFA-A827-813B2CE7FBDC" name="GUID-B7AB25FA-7F0C-4EFA-A827-813B2CE7FBDC"></a><h3 id="JSSEC-GUID-B7AB25FA-7F0C-4EFA-A827-813B2CE7FBDC" class="sect3">JSSE Classes and Interfaces</h3>
               <div>
                  <p></p>
                  <div class="section">
                     <p>To communicate securely, both sides of the connection must be SSL-enabled. In the JSSE API, the endpoint classes of the connection are <code class="codeph">SSLSocket</code> and <code class="codeph">SSLEngine</code>. In <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-B7AB25FA-7F0C-4EFA-A827-813B2CE7FBDC__GUID-A0AB7CF4-2CB8-4F12-8EF8-68EA03C6217D">Figure 8-1</a>, the major classes used to create <code class="codeph">SSLSocket</code> and <code class="codeph">SSLEngine</code> are laid out in a logical ordering.
                     </p>
                     <div class="figure" id="GUID-B7AB25FA-7F0C-4EFA-A827-813B2CE7FBDC__GUID-A0AB7CF4-2CB8-4F12-8EF8-68EA03C6217D">
                        <p class="titleinfigure">Figure 8-1 JSSE Classes Used to Create SSLSocket and SSLEngine</p><img src="img/jsse-classes-and-interfaces.png" alt="Description of Figure 8-1 follows" title="Description of Figure 8-1 follows" longdesc="img_text/jsse-classes-and-interfaces.html"><br><a href="img_text/jsse-classes-and-interfaces.html">Description of "Figure 8-1 JSSE Classes Used to Create SSLSocket and SSLEngine"</a></div>
                     <!-- class="figure" -->
                     <p>An <code class="codeph">SSLSocket</code> is created either by an <code class="codeph">SSLSocketFactory</code> or by an <code class="codeph">SSLServerSocket</code> accepting an inbound connection. In turn, an <code class="codeph">SSLServerSocket</code> is created by an <code class="codeph">SSLServerSocketFactory</code>. Both <code class="codeph">SSLSocketFactory</code> and <code class="codeph">SSLServerSocketFactory</code> objects are created by an <code class="codeph">SSLContext</code>. An <code class="codeph">SSLEngine</code> is created directly by an <code class="codeph">SSLContext</code>, and relies on the application to handle all I/O. 
                     </p>
                     <div class="infoboxnote" id="GUID-B7AB25FA-7F0C-4EFA-A827-813B2CE7FBDC__GUID-1C41051F-5CE0-44B3-A0E9-D7FC41D3C6EE">
                        <p class="notep1">Note:</p>When using raw <code class="codeph">SSLSocket</code> or <code class="codeph">SSLEngine</code> classes, you should always check the peer's credentials before sending any data. Since JDK 7, endpoint identification/verification procedures can be handled during SSL/TLS handshaking. See the method <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLParameters.html#getEndpointIdentificationAlgorithm--" target="_blank"><span class="apiname">SSLParameters.setEndpointIdentificationAlgorithm</span></a>. 
                        <p>For example, the host name in a URL should match the host name in the peer's credentials. An application could be exploited with URL spoofing if the host name is not verified.</p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
               <div class="sect3"><a id="GUID-4A6ABFE4-6B0E-4DF2-A9E8-EEEB71935293" name="GUID-4A6ABFE4-6B0E-4DF2-A9E8-EEEB71935293"></a><h4 id="JSSEC-GUID-4A6ABFE4-6B0E-4DF2-A9E8-EEEB71935293" class="sect4">JSSE Core Classes and Interfaces</h4>
                  <div>
                     <p></p>
                     <p>The core JSSE classes are part of the <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/package-summary.html" target="_blank"><span class="apiname">javax.net</span></a> and <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/package-summary.html" target="_blank"><span class="apiname">javax.net.ssl</span></a> packages.
                     </p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-6AF71CD9-4E87-49E1-B175-89810D54139E" name="GUID-6AF71CD9-4E87-49E1-B175-89810D54139E"></a><h4 id="JSSEC-GUID-6AF71CD9-4E87-49E1-B175-89810D54139E" class="sect4">SocketFactory and ServerSocketFactory Classes</h4>
                  <div>
                     <p></p>
                     <p>The abstract <code class="codeph">javax.net.SocketFactory</code> class is used to create sockets. Subclasses of this class are factories that create particular subclasses of sockets and thus provide a general framework for the addition of public socket-level functionality. For example, see <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-F0917FCC-FBB0-4E36-8D79-37F14F8A274B">SSLSocketFactory and SSLServerSocketFactory Classes</a>.
                     </p>
                     <p>The abstract <code class="codeph">javax.net.ServerSocketFactory</code> class is analogous to the <code class="codeph">SocketFactory</code> class, but is used specifically for creating server sockets.
                     </p>
                     <p>Socket factories are a simple way to capture a variety of policies related to the sockets being constructed, producing such sockets in a way that does not require special configuration of the code that asks for the sockets:</p>
                     <ul style="list-style-type: disc;">
                        <li>Due to polymorphism of both factories and sockets, different kinds of sockets can be used by the same application code just by passing different kinds of factories.</li>
                        <li>Factories can themselves be customized with parameters used in socket construction. For example, factories could be customized to return sockets with different networking timeouts or security parameters already configured.</li>
                        <li>The sockets returned to the application can be subclasses of <code class="codeph">java.net.Socket</code> (or <code class="codeph">javax.net.ssl.SSLSocket</code>), so that they can directly expose new APIs for features such as compression, security, record marking, statistics collection, or firewall tunneling.
                        </li>
                     </ul>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-F0917FCC-FBB0-4E36-8D79-37F14F8A274B" name="GUID-F0917FCC-FBB0-4E36-8D79-37F14F8A274B"></a><h4 id="JSSEC-GUID-F0917FCC-FBB0-4E36-8D79-37F14F8A274B" class="sect4">SSLSocketFactory and SSLServerSocketFactory Classes</h4>
                  <div>
                     <p></p>
                     <p>The <code class="codeph">javax.net.ssl.SSLSocketFactory</code> class acts as a factory for creating secure sockets. This class is an abstract subclass of <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/SocketFactory.html" target="_blank"><code class="codeph">javax.net.SocketFactory</code></a>.
                     </p>
                     <p>Secure socket factories encapsulate the details of creating and initially configuring secure sockets. This includes authentication keys, peer certificate validation, enabled cipher suites, and the like.</p>
                     <p>The <code class="codeph">javax.net.ssl.SSLServerSocketFactory</code> class is analogous to the <code class="codeph">SSLSocketFactory</code> class, but is used specifically for creating server sockets.
                     </p>
                  </div>
                  <div class="sect4"><a id="GUID-86684173-0E06-4EA9-AF89-B80E0D7B602E" name="GUID-86684173-0E06-4EA9-AF89-B80E0D7B602E"></a><h5 id="JSSEC-GUID-86684173-0E06-4EA9-AF89-B80E0D7B602E" class="sect5">Obtaining an SSLSocketFactory</h5>
                     <div>
                        <p>The following ways can be used to obtain an <code class="codeph">SSLSocketFactory</code>:
                        </p>
                        <div class="section">
                           <ul style="list-style-type: disc;">
                              <li>Get the default factory by calling the <code class="codeph">SSLSocketFactory.getDefault()</code> static method.
                              </li>
                              <li>Receive a factory as an API parameter. That is, code that must create sockets but does not care about the details of how the sockets are configured can include a method with an <code class="codeph">SSLSocketFactory</code> parameter that can be called by clients to specify which <code class="codeph">SSLSocketFactory</code> to use when creating sockets (for example, <code class="codeph">javax.net.ssl.HttpsURLConnection</code>).
                              </li>
                              <li>Construct a new factory with specifically configured behavior.</li>
                           </ul>
                           <p>The default factory is typically configured to support server authentication only so that sockets created by the default factory do not leak any more information about the client than a normal TCP socket would.</p>
                           <p>Many classes that create and use sockets do not need to know the details of socket creation behavior. Creating sockets through a socket factory passed in as a parameter is a good way of isolating the details of socket configuration, and increases the reusability of classes that create and use sockets.</p>
                           <p>You can create new socket factory instances either by implementing your own socket factory subclass or by using another class which acts as a factory for socket factories. One example of such a class is <code class="codeph">SSLContext</code>, which is provided with the JSSE implementation as a provider-based configuration class.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-8EF3AA86-6559-482D-82C7-4F6F6951A1AB" name="GUID-8EF3AA86-6559-482D-82C7-4F6F6951A1AB"></a><h4 id="JSSEC-GUID-8EF3AA86-6559-482D-82C7-4F6F6951A1AB" class="sect4">SSLSocket and SSLServerSocket Classes</h4>
                  <div>
                     <p></p>
                     <p>The <code class="codeph">javax.net.ssl.SSLSocket</code> class is a subclass of the standard Java <code class="codeph">java.net.Socket</code> class. It supports all of the standard socket methods and adds methods specific to secure sockets. Instances of this class encapsulate the <span class="apiname">SSLContext</span> under which they were created. See <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-C281CAF3-275F-4DE4-8B47-4A84363CF39F" title="The javax.net.ssl.SSLContext class is an engine class for an implementation of a secure socket protocol. An instance of this class acts as a factory for SSLSocket, SSLServerSocket, and SSLEngine. An SSLContext object holds all of the state information shared across all objects created under that context. For example, session state is associated with the SSLContext when it is negotiated through the handshake protocol by sockets created by socket factories provided by the context. These cached sessions can be reused and shared by other sockets created under the same context.">SSLContext Class</a>. There are APIs to control the creation of secure socket sessions for a socket instance, but trust and key management are not directly exposed.
                     </p>
                     <p>The <code class="codeph">javax.net.ssl.SSLServerSocket</code> class is analogous to the <code class="codeph">SSLSocket</code> class, but is used specifically for creating server sockets.
                     </p>
                     <p>To prevent peer spoofing, you should always verify the credentials presented to an <code class="codeph">SSLSocket</code>. See <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-D6A538A2-8CEF-4C6D-9C44-295758E64E38">Cipher Suite Choice and Remote Entity Verification</a>.
                     </p>
                     <div class="p">
                        <div class="infoboxnote" id="GUID-8EF3AA86-6559-482D-82C7-4F6F6951A1AB__GUID-1242F7C2-58EE-4389-BD47-8316EBD20B28">
                           <p class="notep1">Note:</p>Due to the complexity of the SSL and TLS protocols, it is difficult to predict whether incoming bytes on a connection are handshake or application data, and how that data might affect the current connection state (even causing the process to block). In the Oracle JSSE implementation, the <code class="codeph">available()</code> method on the object obtained by <code class="codeph">SSLSocket.getInputStream()</code> returns a count of the number of application data bytes successfully decrypted from the SSL connection but not yet read by the application.
                        </div> 
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-BA88D2CC-EC63-4A74-A696-E1A56BD68BF0" name="GUID-BA88D2CC-EC63-4A74-A696-E1A56BD68BF0"></a><h5 id="JSSEC-GUID-BA88D2CC-EC63-4A74-A696-E1A56BD68BF0" class="sect5">Obtaining an SSLSocket</h5>
                     <div>
                        <p>Instances of <span class="apiname">SSLSocket</span> can be obtained in one of the following ways:
                        </p>
                        <ul>
                           <li><span>An <span class="apiname">SSLSocket</span> can be created by an instance of <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLSocketFactory.html" target="_blank"><span class="apiname">SSLSocketFactory</span></a> via one of the several <span class="apiname">createSocket</span> methods of that class.</span></li>
                           <li><span>An <span class="apiname">SSLSocket</span> can be created through the <span class="apiname">accept</span> method of the <span class="apiname">SSLServerSocket</span> class.</span></li>
                        </ul>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-D6A538A2-8CEF-4C6D-9C44-295758E64E38" name="GUID-D6A538A2-8CEF-4C6D-9C44-295758E64E38"></a><h5 id="JSSEC-GUID-D6A538A2-8CEF-4C6D-9C44-295758E64E38" class="sect5">Cipher Suite Choice and Remote Entity Verification</h5>
                     <div>
                        <p></p>
                        <p>The SSL/TLS protocols define a specific series of steps to ensure a <span class="italic">protected</span> connection. However, the choice of cipher suite directly affects the type of security that the connection enjoys. For example, if an anonymous cipher suite is selected, then the application has no way to verify the remote peer's identity. If a suite with no encryption is selected, then the privacy of the data cannot be protected. Additionally, the SSL/TLS protocols do not specify that the credentials received must match those that peer might be expected to send. If the connection were somehow redirected to a rogue peer, but the rogue's credentials were acceptable based on the current trust material, then the connection would be considered valid.
                        </p>
                        <p>When using raw <code class="codeph">SSLSocket</code> and <code class="codeph">SSLEngine</code> classes, you should always check the peer's credentials before sending any data. The <code class="codeph">SSLSocket</code> and <code class="codeph">SSLEngine</code> classes do not automatically verify that the host name in a URL matches the host name in the peer's credentials. An application could be exploited with URL spoofing if the host name is not verified. Since JDK 7, endpoint identification/verification procedures can be handled during SSL/TLS handshaking. See the <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLParameters.html#getEndpointIdentificationAlgorithm--" target="_blank"><span class="apiname">SSLParameters.getEndpointIdentificationAlgorithm</span></a> method.
                        </p>
                        <p>Protocols such as HTTPS (<a href="http://www.ietf.org/rfc/rfc2818.txt" target="_blank">HTTP Over TLS</a>) do require host name verification. Since JDK 7, the HTTPS endpoint identification is enforced during handshaking for <span class="apiname">HttpsURLConnection</span> by default. See the <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLParameters.html#getEndpointIdentificationAlgorithm--" target="_blank"><span class="apiname">SSLParameters.getEndpointIdentificationAlgorithm</span></a> method. Alternatively, applications can use the <span class="apiname">HostnameVerifier</span> interface to override the default HTTPS host name rules. See <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-9E46E5AA-FE3E-48D7-B616-98A143F74587">HostnameVerifier Interface</a> and <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-A14E129D-4D9D-4F38-A9F0-ED6F97B18863" title="The javax.net.ssl.HttpsURLConnection class extends the java.net.HttpURLConnection class and adds support for HTTPS-specific features.">HttpsURLConnection Class</a>.
                        </p>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-8796681D-06C8-4884-ADE4-782394F6F6FB" name="GUID-8796681D-06C8-4884-ADE4-782394F6F6FB"></a><h4 id="JSSEC-GUID-8796681D-06C8-4884-ADE4-782394F6F6FB" class="sect4">SSLEngine Class</h4>
                  <div>
                     <p></p>
                     <p>TLS/DTLS is becoming increasingly popular. It is being used in a wide variety of applications across a wide range of computing platforms and devices. Along with this popularity come demands to use TLS/DTLS with different I/O and threading models to satisfy the applications' performance, scalability, footprint, and other requirements. There are demands to use TLS/DTLS with blocking and nonblocking I/O channels, asynchronous I/O, arbitrary input and output streams, and byte buffers. There are demands to use it in highly scalable, performance-critical environments, requiring management of thousands of network connections.</p>
                     <p>Abstraction of the I/O transport mechanism using the <code class="codeph">SSLEngine</code> class in Java SE allows applications to use the TLS/DTLS protocols in a transport-independent way, and thus frees application developers to choose transport and computing models that best meet their needs. Not only does this abstraction allow applications to use nonblocking I/O channels and other I/O models, it also accommodates different threading models. This effectively leaves the I/O and threading decisions up to the application developer. Because of this flexibility, the application developer must manage I/O and threading (complex topics in and of themselves), as well as have some understanding of the TLS/DTLS protocols. The abstraction is therefore an advanced API: beginners should use <code class="codeph">SSLSocket</code>.
                     </p>
                     <p>Users of other Java programming language APIs such as the Java Generic Security Services (Java GSS-API) and the Java Simple Authentication Security Layer (Java SASL) will notice similarities in that the application is also responsible for transporting data.</p>
                     <p>The core class is <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLEngine.html" target="_blank"><span class="apiname">javax.net.ssl.SSLEngine</span></a>. It encapsulates a TLS/DTLS state machine and operates on inbound and outbound byte buffers supplied by the user of the <code class="codeph">SSLEngine</code> class. <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-8796681D-06C8-4884-ADE4-782394F6F6FB__GUID-A02F05DD-41AA-47E3-A1BE-9AB4AC6E4BC2">Figure 8-2</a> illustrates the flow of data from the application, through <code class="codeph">SSLEngine</code>, to the transport mechanism, and back.
                     </p>
                     <div class="figure" id="GUID-8796681D-06C8-4884-ADE4-782394F6F6FB__GUID-A02F05DD-41AA-47E3-A1BE-9AB4AC6E4BC2">
                        <p class="titleinfigure">Figure 8-2 Flow of Data Through SSLEngine</p><img src="img/sslengine_jsse.png" alt="The following text describes this figure." title="The following text describes this figure."></div>
                     <!-- class="figure" -->
                     <p>The application, shown on the left, supplies application (plaintext) data in an application buffer and passes it to <span class="apiname">SSLEngine</span>. The <span class="apiname">SSLEngine</span> object processes the data contained in the buffer, or any handshaking data, to produce TLS/DTLS encoded data and places it to the network buffer supplied by the application. The application is then responsible for using an appropriate transport (shown on the right) to send the contents of the network buffer to its peer. Upon receiving TLS/DTLS encoded data from its peer (via the transport), the application places the data into a network buffer and passes it to <span class="apiname">SSLEngine</span>. The <span class="apiname">SSLEngine</span> object processes the network buffer's contents to produce handshaking data or application data.
                     </p>
                     <p>An instance of the <code class="codeph">SSLEngine</code> class can be in one of the following states:
                     </p>
                     <dl>
                        <dt class="dlterm"><a name="GUID-8796681D-06C8-4884-ADE4-782394F6F6FB__GUID-B02D18CC-ADD5-44A5-805E-25CD2998855B">
                              <!-- --></a>Creation
                        </dt>
                        <dd>The <code class="codeph">SSLEngine</code> has been created and initialized, but has not yet been used. During this phase, an application may set any <code class="codeph">SSLEngine</code>-specific settings (enabled cipher suites, whether the <code class="codeph">SSLEngine</code> should handshake in client or server mode, and so on). Once handshaking has begun, though, any new settings (except client/server mode) will be used for the next handshake.
                        </dd>
                        <dt class="dlterm"><a name="GUID-8796681D-06C8-4884-ADE4-782394F6F6FB__GUID-0F78430D-0144-4BFE-8E16-6DE2FAD40A64">
                              <!-- --></a>Initial handshaking
                        </dt>
                        <dd>The initial handshake is a procedure by which the two peers exchange communication parameters until an <code class="codeph">SSLSession</code> is established. Application data can’t be sent during this phase.
                        </dd>
                        <dt class="dlterm"><a name="GUID-8796681D-06C8-4884-ADE4-782394F6F6FB__GUID-4FFB7915-D7CE-49E5-9E71-0C542A09854A">
                              <!-- --></a>Application data
                        </dt>
                        <dd>After the communication parameters have been established and the handshake is complete, application data can flow through the <code class="codeph">SSLEngine</code>. Outbound application messages are encrypted and integrity protected, and inbound messages reverse the process.
                        </dd>
                        <dt class="dlterm"><a name="GUID-8796681D-06C8-4884-ADE4-782394F6F6FB__GUID-21E779D2-2FBB-46D2-9275-E742012D20DB">
                              <!-- --></a>Rehandshaking
                        </dt>
                        <dd>Either side can request a renegotiation of the session at any time during the Application Data phase. New handshaking data can be intermixed among the application data. Before starting the rehandshake phase, the application may reset the TLS/DTLS communication parameters such as the list of enabled cipher suites and whether to use client authentication, but can not change between client/server modes. As before, after handshaking has begun, any new <code class="codeph">SSLEngine</code> configuration settings won’t be used until the next handshake.
                        </dd>
                        <dt class="dlterm"><a name="GUID-8796681D-06C8-4884-ADE4-782394F6F6FB__GUID-5FBA1A16-3A76-416F-A4F9-3271D9F2E45D">
                              <!-- --></a>Closure
                        </dt>
                        <dd>When the connection is no longer needed, the application should close the <code class="codeph">SSLEngine</code> and should send/receive any remaining messages to the peer before closing the underlying transport mechanism. Once an engine is closed, it is not reusable: a new <code class="codeph">SSLEngine</code> must be created.
                        </dd>
                     </dl>
                  </div>
                  <div class="sect4"><a id="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744" name="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744"></a><h5 id="JSSEC-GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744" class="sect5">Understanding SSLEngine Operation Statuses</h5>
                     <div>
                        <p>The status of the SSLEngine is represented by <code class="codeph">SSLEngineResult.Status</code>.
                        </p>
                        <div class="section">
                           <p>To indicate the status of the engine and what actions the application should take, the <code class="codeph">SSLEngine.wrap()</code> and <code class="codeph">SSLEngine.unwrap()</code> methods return an <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLEngineResult.html" target="_blank"><code class="codeph">SSLEngineResult</code></a> instance, as shown in <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-6DB10B60-4FE0-4C29-8E6D-DC661522A2B4__GUID-223D79BF-70AD-4F6C-B472-81C28C010BD9">Example 8-5</a>. This <code class="codeph">SSLEngineResult</code> object contains two pieces of status information: the overall status of the engine and the handshaking status.
                           </p>
                           <p>The possible overall statuses are represented by the <code class="codeph">SSLEngineResult.Status</code> enum. The following statuses are available:
                           </p>
                           <dl>
                              <dt class="dlterm"><a name="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__GUID-F79D56D5-8F54-4E4E-ACFB-4BEF8B9B9E7D">
                                    <!-- --></a><code class="codeph">OK</code></dt>
                              <dd>There was no error.</dd>
                              <dt class="dlterm"><a name="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__GUID-55BEDBCE-8E29-45B8-98D1-9E6929540C3D">
                                    <!-- --></a><code class="codeph">CLOSED</code></dt>
                              <dd>The operation closed the <code class="codeph">SSLEngine</code> or the operation could not be completed because it was already closed.
                              </dd>
                              <dt class="dlterm"><a name="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__GUID-C5AE7AA6-7EA1-447A-B443-6895062E1F87">
                                    <!-- --></a><code class="codeph">BUFFER_UNDERFLOW</code></dt>
                              <dd>The input buffer had insufficient data, indicating that the application must obtain more data from the peer (for example, by reading more data from the network).</dd>
                              <dt class="dlterm"><a name="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__GUID-B67FEDA3-B9B6-4730-9C49-9D3D60E3255C">
                                    <!-- --></a><code class="codeph">BUFFER_OVERFLOW</code></dt>
                              <dd>The output buffer had insufficient space to hold the result, indicating that the application must clear or enlarge the destination buffer.</dd>
                           </dl>
                           <p><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__EXAMPLE4HANDLINGBUFFER_UNDERFLOWAND-78F60126">Example 8-1</a> illustrates how to handle the <code class="codeph">BUFFER_UNDERFLOW</code> and <code class="codeph">BUFFER_OVERFLOW</code> statuses of the <code class="codeph">SSLEngine.unwrap()</code> method. It uses <code class="codeph">SSLSession.getApplicationBufferSize()</code> and <code class="codeph">SSLSession.getPacketBufferSize()</code> to determine how large to make the byte buffers.
                           </p>
                           <p>The possible handshaking statuses are represented by the <code class="codeph">SSLEngineResult.HandshakeStatus</code> enum. They represent whether handshaking has completed, whether the caller must obtain more handshaking data from the peer or send more handshaking data to the peer, and so on. The following handshake statuses are available:
                           </p>
                           <dl>
                              <dt class="dlterm"><a name="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__GUID-6738EEFA-1FE5-48B8-9E03-B99B688FD77F">
                                    <!-- --></a><code class="codeph">FINISHED</code></dt>
                              <dd>The <code class="codeph">SSLEngine</code> has just finished handshaking.
                              </dd>
                              <dt class="dlterm"><a name="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__GUID-29199762-DA07-4595-B35D-A0271A229020">
                                    <!-- --></a><code class="codeph">NEED_TASK</code></dt>
                              <dd>The <code class="codeph">SSLEngine</code> needs the results of one (or more) delegated tasks before handshaking can continue.
                              </dd>
                              <dt class="dlterm"><a name="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__GUID-DEFA0BD8-5FC5-41E8-AEB4-82542DDDF7CA">
                                    <!-- --></a><code class="codeph">NEED_UNWRAP</code></dt>
                              <dd>The <code class="codeph">SSLEngine</code> needs to receive data from the remote side before handshaking can continue.
                              </dd>
                              <dt class="dlterm"><a name="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__GUID-C4CCD4B8-357E-4F8B-95E2-89B2A255D9E3">
                                    <!-- --></a><code class="codeph">NEED_UNWRAP_AGAIN</code></dt>
                              <dd>The <code class="codeph">SSLEngine</code> needs to unwrap before handshaking can continue. This value indicates that not-yet-interpreted data has been previously received from the remote side and does not need to be received again; the data has been brought into the JSSE framework but has not been processed yet.
                              </dd>
                              <dt class="dlterm"><a name="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__GUID-2FCB0DC1-F723-4036-B8DA-0A885ECA17E7">
                                    <!-- --></a><code class="codeph">NEED_WRAP</code></dt>
                              <dd>The <code class="codeph">SSLEngine</code> must send data to the remote side before handshaking can continue, so <span class="apiname">SSLEngine.wrap()</span> should be called.
                              </dd>
                              <dt class="dlterm"><a name="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__GUID-215B8B63-813A-4B80-98DE-3C16A0F2926A">
                                    <!-- --></a><code class="codeph">NOT_HANDSHAKING</code></dt>
                              <dd>The <code class="codeph">SSLEngine</code> is not currently handshaking.
                              </dd>
                           </dl>
                           <p>Having two statuses per result allows the <span class="apiname">SSLEngine</span> to indicate that the application must take two actions: one in response to the handshaking and one representing the overall status of the <code class="codeph">wrap()</code> and <code class="codeph">unwrap()</code> methods. For example, the engine might, as the result of a single <code class="codeph">SSLEngine.unwrap()</code> call, return <code class="codeph">SSLEngineResult.Status.OK</code> to indicate that the input data was processed successfully and <code class="codeph">SSLEngineResult.HandshakeStatus.NEED_UNWRAP</code> to indicate that the application should obtain more TLS/DTLS encoded data from the peer and supply it to <code class="codeph">SSLEngine.unwrap()</code> again so that handshaking can continue. As you can see, the previous examples were greatly simplified; they would need to be expanded significantly to properly handle all of these statuses.
                           </p>
                           <p><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__GUID-CEB4C19E-7DB9-4CD8-8315-8FEDD212BAD3">Example 8-3</a> and <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__EXAMPLE5CHECKINGANDPROCESSINGHANDSH-78F5FE16">Example 8-2</a> illustrate how to process handshaking data by checking handshaking status and the overall status of the <code class="codeph">wrap()</code> and <code class="codeph">unwrap()</code> methods.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__EXAMPLE4HANDLINGBUFFER_UNDERFLOWAND-78F60126">
                           <p class="titleinexample">Example 8-1 Sample Code for Handling BUFFER_UNDERFLOW and BUFFER_OVERFLOW</p>
                           <p>The following code sample illustrates how to handle BUFFER_UNDERFLOW and BUFFER_OVERFLOW status:</p><pre class="codeblock"><code>    SSLEngineResult res = engine.unwrap(peerNetData, peerAppData);
    switch (res.getStatus()) {

    case BUFFER_OVERFLOW:
            // Maybe need to enlarge the peer application data buffer.
        if (engine.getSession().getApplicationBufferSize() &gt; peerAppData.capacity()) {
            // enlarge the peer application data buffer
        } else {
            // compact or clear the buffer
        }
        // retry the operation
    break;

    case BUFFER_UNDERFLOW:
        // Maybe need to enlarge the peer network packet buffer
        if (engine.getSession().getPacketBufferSize() &gt; peerNetData.capacity()) {
        // enlarge the peer network packet buffer
        } else {
        // compact or clear the buffer
        }
        // obtain more inbound network data and then retry the operation
       break;

       // Handle other status: CLOSED, OK
       // ...
    }
</code></pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__EXAMPLE5CHECKINGANDPROCESSINGHANDSH-78F5FE16">
                           <p class="titleinexample">Example 8-2 Sample Code for Checking and Processing Handshaking Statuses and Overall Statuses</p>
                           <p>The following code sample illustrates how to process handshaking data by checking handshaking status and the overall status of the <span class="apiname">wrap()</span> and <span class="apiname">unwrap()</span> methods:
                           </p><pre class="codeblock"><code>void doHandshake(SocketChannel socketChannel, SSLEngine engine,
    ByteBuffer myNetData, ByteBuffer peerNetData) throws Exception {

    // Create byte buffers to use for holding application data
    int appBufferSize = engine.getSession().getApplicationBufferSize();
    ByteBuffer myAppData = ByteBuffer.allocate(appBufferSize);
    ByteBuffer peerAppData = ByteBuffer.allocate(appBufferSize);

    // Begin handshake
    engine.beginHandshake();
    SSLEngineResult.HandshakeStatus hs = engine.getHandshakeStatus();

    // Process handshaking message
    while (hs != SSLEngineResult.HandshakeStatus.FINISHED &amp;&amp;
        hs != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {

        switch (hs) {

        case NEED_UNWRAP:
            // Receive handshaking data from peer
            if (socketChannel.read(peerNetData) &lt; 0) {
                // The channel has reached end-of-stream
            }

            // Process incoming handshaking data
            peerNetData.flip();
            SSLEngineResult res = engine.unwrap(peerNetData, peerAppData);
            peerNetData.compact();
            hs = res.getHandshakeStatus();

            // Check status
            switch (res.getStatus()) {
            case OK :
                // Handle OK status
                break;

            // Handle other status: BUFFER_UNDERFLOW, BUFFER_OVERFLOW, CLOSED
            // ...
            }
            break;

        case NEED_WRAP :
            // Empty the local network packet buffer.
            myNetData.clear();

            // Generate handshaking data
            res = engine.wrap(myAppData, myNetData);
            hs = res.getHandshakeStatus();

            // Check status
            switch (res.getStatus()) {
            case OK :
                myNetData.flip();

                // Send the handshaking data to peer
                while (myNetData.hasRemaining()) {
                    socketChannel.write(myNetData);
                }
                break;

            // Handle other status:  BUFFER_OVERFLOW, BUFFER_UNDERFLOW, CLOSED
            // ...
            }
            break;

        case NEED_TASK :
            // Handle blocking tasks
            break;

            // Handle other status:  // FINISHED or NOT_HANDSHAKING
            // ...
        }
    }

    // Processes after handshaking
    // ...
}
</code></pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__GUID-CEB4C19E-7DB9-4CD8-8315-8FEDD212BAD3">
                           <p class="titleinexample">Example 8-3 Sample Code for Handling DTLS handshake Status and Overall Status</p>
                           <p>The following code sample illustrates how to handle DTLS handshake status:</p><pre class="pre codeblock"><code>void handshake(SSLEngine engine, DatagramSocket socket,
               SocketAddress peerAddr) throws Exception {
    boolean endLoops = false;
    // private static int MAX_HANDSHAKE_LOOPS = 60;
    int loops = MAX_HANDSHAKE_LOOPS;
    engine.beginHandshake();
    while (!endLoops &amp;&amp; (serverException == null) &amp;&amp; (clientException == null)) {
        if (--loops &lt; 0) {
            throw new RuntimeException("Too many loops to produce handshake packets");
        }
        SSLEngineResult.HandshakeStatus hs = engine.getHandshakeStatus();
        if (hs == SSLEngineResult.HandshakeStatus.NEED_UNWRAP ||
                hs == SSLEngineResult.HandshakeStatus.NEED_UNWRAP_AGAIN) {
            ByteBuffer iNet;
            ByteBuffer iApp;
            if (hs == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {
                // receive ClientHello request and other SSL/TLS/DTLS records
                byte[] buf = new byte[1024];
                DatagramPacket packet = new DatagramPacket(buf, buf.length);
                try {
                    socket.receive(packet);
                } catch (SocketTimeoutException ste) {
                    // retransmit the packet if timeout
                    List &lt;Datagrampacket&gt; packets =
                        onReceiveTimeout(engine, peerAddr);
                    for (DatagramPacket p : packets) {
                        socket.send(p);
                    }
                    continue;
                }
                iNet = ByteBuffer.wrap(buf, 0, packet.getLength());
                iApp = ByteBuffer.allocate(1024);
            } else {
                iNet = ByteBuffer.allocate(0);
                iApp = ByteBuffer.allocate(1024);
            }
            SSLEngineResult r = engine.unwrap(iNet, iApp);
            SSLEngineResult.Status rs = r.getStatus();
            hs = r.getHandshakeStatus();
            if (rs == SSLEngineResult.Status.BUFFER_OVERFLOW) {
                // the client maximum fragment size config does not work?
                throw new Exception("Buffer overflow: " +
                                    "incorrect client maximum fragment size");
            } else if (rs == SSLEngineResult.Status.BUFFER_UNDERFLOW) {
                // bad packet, or the client maximum fragment size
                // config does not work?
                if (hs != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {
                    throw new Exception("Buffer underflow: " +
                                        "incorrect client maximum fragment size");
                } // otherwise, ignore this packet
            } else if (rs == SSLEngineResult.Status.CLOSED) {
                endLoops = true;
            }   // otherwise, SSLEngineResult.Status.OK:
            if (rs != SSLEngineResult.Status.OK) {
                continue;
            }
        } else if (hs == SSLEngineResult.HandshakeStatus.NEED_WRAP) {
            List &lt;DatagramPacket&gt; packets =
                // Call a function to produce handshake packets
                produceHandshakePackets(engine, peerAddr);
            for (DatagramPacket p : packets) {
                socket.send(p);
            }
        } else if (hs == SSLEngineResult.HandshakeStatus.NEED_TASK) {
            runDelegatedTasks(engine);
        } else if (hs == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {
            // OK, time to do application data exchange.
            endLoops = true;
        } else if (hs == SSLEngineResult.HandshakeStatus.FINISHED) {
            endLoops = true;
        }
    }
    SSLEngineResult.HandshakeStatus hs = engine.getHandshakeStatus();
    if (hs != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {
        throw new Exception("Not ready for application data yet");
    }
}</code></pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-58F4882A-4BBD-4291-8322-2DC7E300974D" name="GUID-58F4882A-4BBD-4291-8322-2DC7E300974D"></a><h5 id="JSSEC-GUID-58F4882A-4BBD-4291-8322-2DC7E300974D" class="sect5">SSLEngine for TLS Protocols</h5>
                     <p>This section shows you how to create an <span class="apiname">SSLEngine</span> object and use it to generate and process TLS data.
                     </p>
                     <div class="sect5"><a id="GUID-16B697CD-77EB-468F-94A1-04254BA75FD7" name="GUID-16B697CD-77EB-468F-94A1-04254BA75FD7"></a><h6 id="JSSEC-GUID-16B697CD-77EB-468F-94A1-04254BA75FD7" class="sect6">Creating an SSLEngine Object</h6>
                        <div>
                           <p>Use the <code class="codeph">SSLContext.createSSLEngine()</code> method to create an <code class="codeph">SSLEngine</code> object.
                           </p>
                           <div class="section">
                              <p>Before you create an <code class="codeph">SSLEngine</code> object, you must configure the engine to act as a client or a server, and set other configuration parameters, such as which cipher suites to use and whether client authentication is required. The <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLContext.html#createSSLEngine--" target="_blank"><code class="codeph">SSLContext.createSSLEngine</code></a> method creates an <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLEngine.html" target="_blank"><code class="codeph">javax.net.ssl.SSLEngine</code></a> object.
                              </p>
                           </div>
                           <!-- class="section" -->
                           <div class="example" id="GUID-16B697CD-77EB-468F-94A1-04254BA75FD7__THEFOLLOWINGSAMPLECODECREATESASSLEN-225FBEA9">
                              <p class="titleinexample">Example 8-4 Sample Code for Creating an SSLEngine Client for TLS with JKS as Keystore</p>
                              <p>The following sample code creates an <span class="apiname">SSLEngine</span> client for TLS that uses JKS as keystore.
                              </p>
                              <div class="infoboxnote" id="GUID-16B697CD-77EB-468F-94A1-04254BA75FD7__GUID-E7142213-957C-4DEB-8C5D-CD8BE3E5A286">
                                 <p class="notep1">Note:</p>In this sample, the server name and port number are not used for communicating with the server (all transport is the responsibility of the application). They are hints to the JSSE provider to use for TLS session caching.
                              </div><pre class="codeblock"><code>    import javax.net.ssl.*;
    import java.security.*;

    // Create and initialize the SSLContext with key material
    char[] passphrase = "passphrase".toCharArray();

    // First initialize the key and trust material
    KeyStore ksKeys = KeyStore.getInstance("JKS");
    ksKeys.load(new FileInputStream("testKeys"), passphrase);
    KeyStore ksTrust = KeyStore.getInstance("JKS");
    ksTrust.load(new FileInputStream("testTrust"), passphrase);

    // KeyManagers decide which key material to use
    KeyManagerFactory kmf = KeyManagerFactory.getInstance("PKIX");
    kmf.init(ksKeys, passphrase);

    // TrustManagers decide whether to allow connections
    TrustManagerFactory tmf = TrustManagerFactory.getInstance("PKIX");
    tmf.init(ksTrust);

    // Get an instance of SSLContext for TLS protocols
    sslContext = SSLContext.getInstance("TLS");
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);

    // Create the engine
    SSLEngine engine = sslContext.createSSLengine(hostname, port);

    // Use as client
    engine.setUseClientMode(true);
</code></pre></div>
                           <!-- class="example" -->
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-6DB10B60-4FE0-4C29-8E6D-DC661522A2B4" name="GUID-6DB10B60-4FE0-4C29-8E6D-DC661522A2B4"></a><h6 id="JSSEC-GUID-6DB10B60-4FE0-4C29-8E6D-DC661522A2B4" class="sect6">Generating and Processing TLS Data</h6>
                        <div>
                           <p>The two main <code class="codeph">SSLEngine</code> methods are <code class="codeph">wrap()</code> and <code class="codeph">unwrap()</code>. They are responsible for generating and consuming network data respectively. Depending on the state of the <code class="codeph">SSLEngine</code> object, this data might be handshake or application data.
                           </p>
                           <div class="section">
                              <p>Each <code class="codeph">SSLEngine</code> object has several phases during its lifetime. Before application data can be sent or received, the TLS protocol requires a handshake to establish cryptographic parameters. This handshake requires a series of back-and-forth steps by the <code class="codeph">SSLEngine</code> object.
                              </p>
                              <p>During the initial handshaking, the <code class="codeph">wrap()</code> and <code class="codeph">unwrap()</code> methods generate and consume handshake data, and the application is responsible for transporting the data. The <code class="codeph">wrap()</code> and <code class="codeph">unwrap()</code> method sequence is repeated until the handshake is finished. Each <code class="codeph">SSLEngine</code> operation generates an instance of the <code class="codeph">SSLEngineResult</code> class, in which the <code class="codeph">SSLEngineResult.HandshakeStatus</code> field is used to determine what operation must occur next to move the handshake along.
                              </p>
                              <p><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-6DB10B60-4FE0-4C29-8E6D-DC661522A2B4__STATEMACHINEDURINGDTLSHANDSHAKE-D6B2B3FD">Figure 8-3</a> shows the state machine during a typical TLS handshake, with corresponding messages and statuses:
                              </p>
                              <div class="figure" id="GUID-6DB10B60-4FE0-4C29-8E6D-DC661522A2B4__STATEMACHINEDURINGDTLSHANDSHAKE-D6B2B3FD">
                                 <p class="titleinfigure">Figure 8-3 State Machine during TLS Handshake</p><img src="img/ssl-tls-handshake.png" alt="Description of Figure 8-3 follows" title="Description of Figure 8-3 follows" longdesc="img_text/ssl-tls-handshake.html"><br><a href="img_text/ssl-tls-handshake.html">Description of "Figure 8-3 State Machine during TLS Handshake"</a></div>
                              <!-- class="figure" -->
                              <p>When handshaking is complete, further calls to <code class="codeph">wrap()</code> will attempt to consume application data and package it for transport. The <code class="codeph">unwrap()</code> method will attempt the opposite.
                              </p>
                              <p>To send data to the peer, the application first supplies the data that it wants to send via <code class="codeph">SSLEngine.wrap()</code> to obtain the corresponding TLS encoded data. The application then sends the encoded data to the peer using its chosen transport mechanism. When the application receives the TLS encoded data from the peer via the transport mechanism, it supplies this data to the <code class="codeph">SSLEngine</code> via <code class="codeph">SSLEngine.unwrap()</code> to obtain the plaintext data sent by the peer.
                              </p>
                           </div>
                           <!-- class="section" -->
                           <div class="example" id="GUID-6DB10B60-4FE0-4C29-8E6D-DC661522A2B4__GUID-223D79BF-70AD-4F6C-B472-81C28C010BD9">
                              <p class="titleinexample">Example 8-5 Sample Code for Creating a Nonblocking SocketChannel</p>
                              <p>The following example is an SSL application that uses a non-blocking <code class="codeph">SocketChannel</code> to communicate with its peer. It sends the string "hello" to the peer by encoding it using the <code class="codeph">SSLEngine</code> created in <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-16B697CD-77EB-468F-94A1-04254BA75FD7__THEFOLLOWINGSAMPLECODECREATESASSLEN-225FBEA9">Example 8-4</a> . It uses information from the <code class="codeph">SSLSession</code> to determine how large to make the byte buffers.
                              </p>
                              <div class="infoboxnote" id="GUID-6DB10B60-4FE0-4C29-8E6D-DC661522A2B4__GUID-6DE5C28C-B4CD-438F-9A68-33BB5C3E2E94">
                                 <p class="notep1">Note:</p>The example can be made more robust and scalable by using a <code class="codeph">Selector</code> with the nonblocking <code class="codeph">SocketChannel</code>.
                              </div><pre class="codeblock"><code>
    // Create a nonblocking socket channel
    SocketChannel socketChannel = SocketChannel.open();
    socketChannel.configureBlocking(false);
    socketChannel.connect(new InetSocketAddress(hostname, port));

    // Complete connection
    while (!socketChannel.finishedConnect()) {
    // do something until connect completed
    }

    //Create byte buffers for holding application and encoded data

    SSLSession session = engine.getSession();
    ByteBuffer myAppData = ByteBuffer.allocate(session.getApplicationBufferSize());
    ByteBuffer myNetData = ByteBuffer.allocate(session.getPacketBufferSize());
    ByteBuffer peerAppData = ByteBuffer.allocate(session.getApplicationBufferSize());
    ByteBuffer peerNetData = ByteBuffer.allocate(session.getPacketBufferSize());

    // Do initial handshake
    doHandshake(socketChannel, engine, myNetData, peerNetData);

    myAppData.put("hello".getBytes());
    myAppData.flip();

    while (myAppData.hasRemaining()) {
    // Generate TLS/DTLS encoded data (handshake or application data)
    SSLEngineResult res = engine.wrap(myAppData, myNetData);

    // Process status of call
    if (res.getStatus() == SSLEngineResult.Status.OK) {
        myAppData.compact();

        // Send TLS/DTLS encoded data to peer
        while(myNetData.hasRemaining()) {
            int num = socketChannel.write(myNetData);
            if (num == 0) {
                // no bytes written; try again later
            }
        }
    }

    // Handle other status:  BUFFER_OVERFLOW, CLOSED
    ...
    }</code></pre></div>
                           <!-- class="example" -->
                           <div class="example" id="GUID-6DB10B60-4FE0-4C29-8E6D-DC661522A2B4__GUID-FDF2BEE0-D9F4-4653-BD90-4167FEB96C45">
                              <p class="titleinexample">Example 8-6 Sample Code for Reading Data From Nonblocking SocketChannel</p>The following sample code illustrates how to read data from the same nonblocking <code class="codeph">SocketChannel</code> and extract the plaintext data from it by using <code class="codeph">SSLEngine</code> created in <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-16B697CD-77EB-468F-94A1-04254BA75FD7__THEFOLLOWINGSAMPLECODECREATESASSLEN-225FBEA9">Example 8-4</a>. Each iteration of this code may or may not produce plaintext data, depending on whether handshaking is in progress.<pre class="codeblock"><code>
    // Read TLS/DTLS encoded data from peer
    int num = socketChannel.read(peerNetData);
    if (num == -1) {
        // The channel has reached end-of-stream
    } else if (num == 0) {
        // No bytes read; try again ...
    } else {
        // Process incoming data
        peerNetData.flip();
        res = engine.unwrap(peerNetData, peerAppData);

        if (res.getStatus() == SSLEngineResult.Status.OK) {
            peerNetData.compact();

        if (peerAppData.hasRemaining()) {
            // Use peerAppData
        }
    }
    // Handle other status:  BUFFER_OVERFLOW, BUFFER_UNDERFLOW, CLOSED
    ...
    }
</code></pre></div>
                           <!-- class="example" -->
                        </div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-9C55936B-376F-4B49-8018-216856F2C695" name="GUID-9C55936B-376F-4B49-8018-216856F2C695"></a><h5 id="JSSEC-GUID-9C55936B-376F-4B49-8018-216856F2C695" class="sect5">SSLEngine for DTLS Protocols</h5>
                     <p>This section shows you how to create an <span class="apiname">SSLEngine</span> object and use it to handle a DTLS handshake, generate and process DTLS data, and handle retransmissions in DTLS connections.
                     </p>
                     <div class="sect5"><a id="GUID-4D854666-433A-4672-B902-565CC7AEE0BF" name="GUID-4D854666-433A-4672-B902-565CC7AEE0BF"></a><h6 id="JSSEC-GUID-4D854666-433A-4672-B902-565CC7AEE0BF" class="sect6">Creating an SSLEngine Object for DTLS</h6>
                        <div>
                           <p>The following examples illustrate how to create an <code class="codeph">SSLEngine</code> object for DTLS.
                           </p>
                           <div class="p">
                              <div class="infoboxnote" id="GUID-4D854666-433A-4672-B902-565CC7AEE0BF__GUID-4E9C2C41-E06E-4412-A9C8-20DBFA93CC0B">
                                 <p class="notep1">Note:</p>The server name and port number are not used for communicating with the server (all transport is the responsibility of the application). They are hints to the JSSE provider to use for DTLS session caching, and for Kerberos-based cipher suite implementations to determine which server credentials should be obtained.
                              </div> 
                           </div>
                           <div class="example" id="GUID-4D854666-433A-4672-B902-565CC7AEE0BF__THEFOLLOWINGSAMPLECODECREATESASSLEN-225FCB3A">
                              <p class="titleinexample">Example 8-7 Sample Code for Creating an SSLEngine Client for DTLS with PKCS12 as Keystore</p>
                              <p>The following sample code creates an <span class="apiname">SSLEngine</span> client for DTLS that uses PKCS12 as keystore:
                              </p><pre class="codeblock"><code>    import javax.net.ssl.*;
    import java.security.*;

    // Create and initialize the SSLContext with key material
    char[] passphrase = "passphrase".toCharArray();

    // First initialize the key and trust material
    KeyStore ksKeys = KeyStore.getInstance("PKCS12");
    ksKeys.load(new FileInputStream("testKeys"), passphrase);
    KeyStore ksTrust = KeyStore.getInstance("PKCS12");
    ksTrust.load(new FileInputStream("testTrust"), passphrase);

    // KeyManagers decide which key material to use
    KeyManagerFactory kmf = KeyManagerFactory.getInstance("PKIX");
    kmf.init(ksKeys, passphrase);

    // TrustManagers decide whether to allow connections
    TrustManagerFactory tmf = TrustManagerFactory.getInstance("PKIX");
    tmf.init(ksTrust);

    // Get an instance of SSLContext for DTLS protocols
    sslContext = SSLContext.getInstance("DTLS");
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);

    // Create the engine
    SSLEngine engine = sslContext.createSSLengine(hostname, port);

    // Use engine as client
    engine.setUseClientMode(true);
</code></pre></div>
                           <!-- class="example" -->
                           <div class="example" id="GUID-4D854666-433A-4672-B902-565CC7AEE0BF__THEFOLLOWINGSAMPLECODECREATESASSLEN-225FC3CE">
                              <p class="titleinexample">Example 8-8 Sample Code for Creating an SSLEngine Server for DTLS with PKCS12 as Keystore</p>The following sample code creates an <span class="apiname">SSLEngine</span> server for DTLS that uses PKCS12 as keystore:<pre class="codeblock"><code>    import javax.net.ssl.*;
    import java.security.*;

    // Create and initialize the SSLContext with key material
    char[] passphrase = "passphrase".toCharArray();

    // First initialize the key and trust material
    KeyStore ksKeys = KeyStore.getInstance("PKCS12");
    ksKeys.load(new FileInputStream("testKeys"), passphrase);
    KeyStore ksTrust = KeyStore.getInstance("PKCS12");
    ksTrust.load(new FileInputStream("testTrust"), passphrase);

    // KeyManagers decide which key material to use
    KeyManagerFactory kmf = KeyManagerFactory.getInstance("PKIX");
    kmf.init(ksKeys, passphrase);

    // TrustManagers decide whether to allow connections
    TrustManagerFactory tmf = TrustManagerFactory.getInstance("PKIX");
    tmf.init(ksTrust);

    // Get an SSLContext for DTLS Protocol without authentication
    sslContext = SSLContext.getInstance("DTLS");
    sslContext.init(null, null, null);

    // Create the engine
    SSLEngine engine = sslContext.createSSLeEngine(hostname, port);

    // Use the engine as server
    engine.setUseClientMode(false);

    // Require client authentication
    engine.setNeedClientAuth(true);</code></pre></div>
                           <!-- class="example" -->
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-80EBB1BB-8A36-4B6F-BC35-AF235F30EF45" name="GUID-80EBB1BB-8A36-4B6F-BC35-AF235F30EF45"></a><h6 id="JSSEC-GUID-80EBB1BB-8A36-4B6F-BC35-AF235F30EF45" class="sect6">Generating and Processing DTLS Data</h6>
                        <div>
                           <p></p>
                           <p>A DTLS handshake and a TLS handshake generate and process data similarly. (See <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-6DB10B60-4FE0-4C29-8E6D-DC661522A2B4" title="The two main SSLEngine methods are wrap() and unwrap(). They are responsible for generating and consuming network data respectively. Depending on the state of the SSLEngine object, this data might be handshake or application data.">Generating and Processing TLS Data</a>.) They both use the <span class="apiname">SSLEngine.wrap()</span> and <span class="apiname">SSLEngine.wrap()</span> methods to generate and consume network data, respectively.
                           </p>
                           <p>The following diagram shows the state machine during a typical DTLS handshake, with corresponding messages and statuses:</p>
                           <div class="figure" id="GUID-80EBB1BB-8A36-4B6F-BC35-AF235F30EF45__GUID-85F0E791-66C0-479B-855B-86509CE249FE">
                              <p class="titleinfigure">Figure 8-4 State Machine during DTLS Handshake</p><img src="img/jsse-handshake-state-machine-new.png" alt="Description of Figure 8-4 follows" title="Description of Figure 8-4 follows" longdesc="img_text/jsse-handshake-state-machine-new.html"><br><a href="img_text/jsse-handshake-state-machine-new.html">Description of "Figure 8-4 State Machine during DTLS Handshake"</a></div>
                           <!-- class="figure" -->
                           <div class="example" id="GUID-80EBB1BB-8A36-4B6F-BC35-AF235F30EF45__GUID-E31F4DB7-7133-414A-A7A8-4AECA3A8A5CA">
                              <p class="titleinexample">Example 8-9 Sample Code for Handling DTLS Handshake Status and Overall Status</p>
                              <p>This sample demonstrates how to handle DTLS handshake status (from the <span class="apiname">SSLEngine.getHandshakeStatus</span> method) and overall status (from the <span class="apiname">SSLEngineResult.getStatus</span> method).
                              </p><pre class="pre codeblock"><code>void handshake(SSLEngine engine, DatagramSocket socket, SocketAddress peerAddr) throws Exception {
    boolean endLoops = false;
    // private static int MAX_HANDSHAKE_LOOPS = 60;
    int loops = MAX_HANDSHAKE_LOOPS;
    engine.beginHandshake();
    while (!endLoops &amp;&amp; (serverException == null) &amp;&amp; (clientException == null)) {
        if (--loops &lt; 0) {
            throw new RuntimeException("Too many loops to produce handshake packets");
        }
        SSLEngineResult.HandshakeStatus hs = engine.getHandshakeStatus();
        if (hs == SSLEngineResult.HandshakeStatus.NEED_UNWRAP ||
                hs == SSLEngineResult.HandshakeStatus.NEED_UNWRAP_AGAIN) {
            ByteBuffer iNet;
            ByteBuffer iApp;
            if (hs == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {
                // Receive ClientHello request and other SSL/TLS/DTLS records
                byte[] buf = new byte[1024];
                DatagramPacket packet = new DatagramPacket(buf, buf.length);
                try {
                    socket.receive(packet);
                } catch (SocketTimeoutException ste) {
                    // Retransmit the packet if timeout
                    List &lt;Datagrampacket&gt; packets = onReceiveTimeout(engine, peerAddr);
                    for (DatagramPacket p : packets) {
                        socket.send(p);
                    }
                    continue;
                }
                iNet = ByteBuffer.wrap(buf, 0, packet.getLength());
                iApp = ByteBuffer.allocate(1024);
            } else {
                iNet = ByteBuffer.allocate(0);
                iApp = ByteBuffer.allocate(1024);
            }
            SSLEngineResult r = engine.unwrap(iNet, iApp);
            SSLEngineResult.Status rs = r.getStatus();
            hs = r.getHandshakeStatus();
            if (rs == SSLEngineResult.Status.BUFFER_OVERFLOW) {
                // The client maximum fragment size config does not work?
                throw new Exception("Buffer overflow: " +
                                    "incorrect client maximum fragment size");
            } else if (rs == SSLEngineResult.Status.BUFFER_UNDERFLOW) {
                // Bad packet, or the client maximum fragment size
                // config does not work?
                if (hs != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {
                    throw new Exception("Buffer underflow: " +
                                        "incorrect client maximum fragment size");
                } // Otherwise, ignore this packet
            } else if (rs == SSLEngineResult.Status.CLOSED) {
                endLoops = true;
            } // Otherwise, SSLEngineResult.Status.OK
            if (rs != SSLEngineResult.Status.OK) {
                continue;
            }
        } else if (hs == SSLEngineResult.HandshakeStatus.NEED_WRAP) {
            // Call a function to produce handshake packets
            List &lt;DatagramPacket&gt; packets = produceHandshakePackets(engine, peerAddr);
            for (DatagramPacket p : packets) {
                socket.send(p);
            }
        } else if (hs == SSLEngineResult.HandshakeStatus.NEED_TASK) {
            runDelegatedTasks(engine);
        } else if (hs == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {
            // OK, time to do application data exchange
            endLoops = true;
        } else if (hs == SSLEngineResult.HandshakeStatus.FINISHED) {
            endLoops = true;
        }
    }
    SSLEngineResult.HandshakeStatus hs = engine.getHandshakeStatus();
    if (hs != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {
        throw new Exception("Not ready for application data yet");
    }
}</code></pre></div>
                           <!-- class="example" -->
                           <div class="section">
                              <p class="subhead3" id="GUID-80EBB1BB-8A36-4B6F-BC35-AF235F30EF45__GUID-67A89488-A98D-4B4D-AA48-340CECECC0F5">Difference Between the TLS and DTLS SSLEngine.wrap() Methods</p>
                              <div class="p">The <code class="codeph">SSLEngine.wrap()</code> method for DTLS is different from TLS as follows: 
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p>In the TLS implementation of <code class="codeph">SSLEngine</code>, the output buffer of <code class="codeph">SSLEngine.wrap()</code> contains one or more TLS records (due to the TLSv1 BEAST Cipher Block Chaining vulnerability). 
                                       </p>
                                    </li>
                                    <li>
                                       <p>In the DTLS implementation of <code class="codeph">SSLEngine</code>, the output buffer of <code class="codeph">SSLEngine.wrap()</code> contains at most one record, so that every DTLS record can be marshaled and delivered to the datagram layer individually.
                                       </p>
                                    </li>
                                 </ul>
                                 <div class="infoboxnote" id="GUID-80EBB1BB-8A36-4B6F-BC35-AF235F30EF45__GUID-52C4A89B-A524-44E5-9626-136B0C65EB0C">
                                    <p class="notep1">Note:</p>Each record produced by <code class="codeph">SSLEngine.wrap()</code> should comply to the maximum packet size limitation as specified by <code class="codeph">SSLParameters.getMaximumPacketSize()</code>.
                                 </div>&nbsp; 
                              </div>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-6C8AA45B-EB45-4767-BBB4-B7C5A64A60B7" name="GUID-6C8AA45B-EB45-4767-BBB4-B7C5A64A60B7"></a><h6 id="JSSEC-GUID-6C8AA45B-EB45-4767-BBB4-B7C5A64A60B7" class="sect6">Handling Retransmissions in DTLS Connections</h6>
                        <div>
                           <p>In SSL/TLS over a reliable connection, data is guaranteed to arrive in the proper order, and retransmission is unnecessary. However, for DTLS, which often works over unreliable media, missing or delayed handshake messages must be retransmitted.</p>
                           <div class="section">
                              <p>The <code class="codeph">SSLEngine</code> class operates in a completely transport-neutral manner, and the application layer performs all I/O. Because the <code class="codeph">SSLEngine</code> class isn’t responsible for I/O, the application instead is responsible for providing timers and signalling the <code class="codeph">SSLEngine</code> class when a retransmission is needed. The application layer must determine the right timeout value and when to trigger the timeout event. During handshaking, if an <code class="codeph">SSLEngine</code> object is in <code class="codeph">HandshakeStatus.NEED_UNWRAP</code> state, a call to <span class="apiname">SSLEngine.wrap()</span> means that the previous packets were lost, and must be retransmitted. For such cases, the DTLS implementation of the <code class="codeph">SSLEngine</code> class takes the responsibility to wrap the previous necessary handshaking messages again if necessary.
                              </p>
                              <div class="infoboxnote" id="GUID-6C8AA45B-EB45-4767-BBB4-B7C5A64A60B7__GUID-3AC8121B-28CE-4611-8E66-06E9CEC39B5E">
                                 <p class="notep1">Note:</p>In a DTLS engine, only handshake messages must be properly exchanged. Application data can handle packet loss without the need for timers.
                              </div>
                           </div>
                           <!-- class="section" -->
                        </div>
                        <div class="sect6"><a id="GUID-32494D9D-B0FC-4DFC-B747-F4115B6112E3" name="GUID-32494D9D-B0FC-4DFC-B747-F4115B6112E3"></a><h6 id="JSSEC-GUID-32494D9D-B0FC-4DFC-B747-F4115B6112E3" class="sect6">Handling Retransmission in an Application</h6>
                           <div>
                              <p><code class="codeph">SSLEngine.unwrap()</code> and <code class="codeph">SSLEngine.wrap()</code> can be used together to handle retransmission in an application.
                              </p>
                              <div class="section">
                                 <p><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-32494D9D-B0FC-4DFC-B747-F4115B6112E3__GUID-62CAEA17-2745-42AE-94C6-2E35852FC63A">Figure 8-5</a> shows a typical scenario for handling DTLS handshaking retransmission:
                                 </p>
                                 <div class="figure" id="GUID-32494D9D-B0FC-4DFC-B747-F4115B6112E3__GUID-62CAEA17-2745-42AE-94C6-2E35852FC63A">
                                    <p class="titleinfigure">Figure 8-5 DTLS Handshake Retransmission State Flow</p><img src="img/state-flow-need_unwrap_again_new.png" alt="This image illustrates the DTLS handshake retransmission state flow. The flow is described in the numbered steps that follow the image." title="This image illustrates the DTLS handshake retransmission state flow. The flow is described in the numbered steps that follow the image."></div>
                                 <!-- class="figure" -->
                              </div>
                              <!-- class="section" -->
                              <ol>
                                 <li class="stepexpand"><span>Create and initialize an instance of DTLS <code class="codeph">SSLEngine</code>. </span><div>See <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-16B697CD-77EB-468F-94A1-04254BA75FD7" title="Use the SSLContext.createSSLEngine() method to create an SSLEngine object.">Creating an SSLEngine Object</a>. The DTLS handshake process begins.
                                    </div>
                                 </li>
                                 <li class="stepexpand"><span>If the handshake status is <code class="codeph">HandshakeStatus.NEED_UNWRAP</code>, wait for data from network.</span></li>
                                 <li class="stepexpand"><span>If the timer times out, it indicates that the previous delivered handshake messages may have been lost.</span><div>
                                       <div class="infoboxnote" id="GUID-32494D9D-B0FC-4DFC-B747-F4115B6112E3__GUID-39A9DD22-1E2F-4924-8960-9DCAF232DE86">
                                          <p class="notep1">Note:</p>In DTLS handshaking retransmission, the determined handshake status isn’t necessarily <code class="codeph">HandshakeStatus.NEED_WRAP</code> for the call to <code class="codeph">SSLEngine.wrap()</code>.
                                       </div>
                                    </div>
                                 </li>
                                 <li class="stepexpand"><span>Call <code class="codeph">SSLEngine.wrap()</code>.</span></li>
                                 <li class="stepexpand"><span>The wrapped packets are delivered.</span></li>
                              </ol>
                           </div>
                        </div>
                        <div class="sect6"><a id="GUID-F8FB4BE7-3A43-41FB-8642-07848FCA9381" name="GUID-F8FB4BE7-3A43-41FB-8642-07848FCA9381"></a><h6 id="JSSEC-GUID-F8FB4BE7-3A43-41FB-8642-07848FCA9381" class="sect6">Handling a Buffered Handshake Message in an Application</h6>
                           <div>
                              <p>Datagram transport doesn’t require or provide reliable or in-order delivery of data.&nbsp;Handshake messages may be lost or need to be reordered.  In the DTLS implementation, a handshake message may need to be buffered for future handling before all previous messages have been received.</p>
                              <div class="section">
                                 <p>The DTLS implementation of <code class="codeph">SSLEngine</code> takes the responsibility to reorder handshake messages. Handshake message buffering and reordering are transparent to applications.
                                 </p>
                                 <p>However, applications must manage <code class="codeph">HandshakeStatus.NEED_UNWRAP_AGAIN</code> status. This status indicates that for the next <span class="apiname">SSLEngine.unwrap()</span> operation no additional data from the remote side is required.
                                 </p>
                                 <p><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-F8FB4BE7-3A43-41FB-8642-07848FCA9381__GUID-693172EF-782D-4676-BA14-27B0794F8B72">Figure 8-6</a> shows a typical scenario for using the <code class="codeph">HandshakeStatus.NEED_UNWRAP_AGAIN</code>.
                                 </p>
                                 <div class="figure" id="GUID-F8FB4BE7-3A43-41FB-8642-07848FCA9381__GUID-693172EF-782D-4676-BA14-27B0794F8B72">
                                    <p class="titleinfigure">Figure 8-6 State Machine of DTLS Buffered Handshake with NEED_UNWRAP_AGAIN</p><img src="img/dtls-buffered-handshake-message-new.png" alt="This flowchart illustrates the sequence of messages that are exchanged in the DTLS buffered handshake. Messages that are sent only in certain situations are noted as optional. The sequence is described in the numbered list that follows the image." title="This flowchart illustrates the sequence of messages that are exchanged in the DTLS buffered handshake. Messages that are sent only in certain situations are noted as optional. The sequence is described in the numbered list that follows the image."></div>
                                 <!-- class="figure" -->
                              </div>
                              <!-- class="section" -->
                              <ol>
                                 <li class="stepexpand"><span>Create and initialize an instance of DTLS <code class="codeph">SSLEngine</code>.</span><div>See <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-16B697CD-77EB-468F-94A1-04254BA75FD7" title="Use the SSLContext.createSSLEngine() method to create an SSLEngine object.">Creating an SSLEngine Object</a>.
                                    </div>
                                 </li>
                                 <li class="stepexpand"><strong>Optional: </strong><span>If the handshake status is <code class="codeph">HandshakeStatus.NEED_UNWRAP</code>, wait for data from network.</span></li>
                                 <li class="stepexpand"><strong>Optional: </strong><span>If you received the network data, call <span class="apiname">SSLEngine.unwrap()</span>.</span></li>
                                 <li class="stepexpand"><span>Determine the handshake status for next processing. The handshake status can be <code class="codeph">HandshakeStatus.NEED_UNWRAP_AGAIN</code>, <code class="codeph">HandshakeStatus.NEED_UNWRAP</code>, or <code class="codeph">HandshakeStatus.NEED_WRAP</code>.</span><ul>
                                       <li>If the handshake status is <code class="codeph">HandshakeStatus.NEED_UNWRAP_AGAIN</code>, call <span class="apiname">SSLEngine.unwrap()</span>.
                                       </li>
                                    </ul>
                                    <div>
                                       <div class="infoboxnote" id="GUID-F8FB4BE7-3A43-41FB-8642-07848FCA9381__GUID-4201EFCD-11F7-4175-A530-80F779E79E05">
                                          <p class="notep1">Note:</p>For <code class="codeph">HandshakeStatus.NEED_UNWRAP_AGAIN</code> status, no additional data from the network is required for an <span class="apiname">SSLEngine.unwrap()</span> operation.
                                       </div>
                                    </div>
                                 </li>
                                 <li class="stepexpand"><span>Determine the handshake status for further processing. The handshake status can be <code class="codeph">HandshakeStatus.NEED_UNWRAP_AGAIN</code>, <code class="codeph">HandshakeStatus.NEED_UNWRAP</code>, or <code class="codeph">HandshakeStatus.NEED_WRAP</code>.</span></li>
                              </ol>
                           </div>
                        </div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-7ED13982-53B2-455B-9198-3289F19905B6" name="GUID-7ED13982-53B2-455B-9198-3289F19905B6"></a><h5 id="JSSEC-GUID-7ED13982-53B2-455B-9198-3289F19905B6" class="sect5">Dealing With Blocking Tasks</h5>
                     <div>
                        <p></p>
                        <div class="section">
                           <p>During handshaking, an <code class="codeph">SSLEngine</code> might encounter tasks that can block or take a long time. For example, a <code class="codeph">TrustManager</code> may need to connect to a remote certificate validation service, or a <code class="codeph">KeyManager</code> might need to prompt a user to determine which certificate to use as part of client authentication. To preserve the nonblocking nature of <code class="codeph">SSLEngine</code>, when the engine encounters such a task, it will return <code class="codeph">SSLEngineResult.HandshakeStatus.NEED_TASK</code>. Upon receiving this status, the application should invoke <code class="codeph">SSLEngine.getDelegatedTask()</code> to get the task, and then, using the threading model appropriate for its requirements, process the task. The application might, for example, obtain threads from a thread pool to process the tasks, while the main thread handles other I/O.
                           </p>
                           <p>The following code executes each task in a newly created thread:</p><pre class="codeblock"><code>if (res.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_TASK) {
    Runnable task;
    while ((task = engine.getDelegatedTask()) != null) {
        new Thread(task).start();
    }
}
</code></pre><p>The <code class="codeph">SSLEngine</code> will block future <code class="codeph">wrap()</code> and <code class="codeph">unwrap()</code> calls until all of the outstanding tasks are completed.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-2B54A68F-75AF-4FEA-9339-F7082FE5DA33" name="GUID-2B54A68F-75AF-4FEA-9339-F7082FE5DA33"></a><h5 id="JSSEC-GUID-2B54A68F-75AF-4FEA-9339-F7082FE5DA33" class="sect5">Shutting Down a TLS/DTLS Connection</h5>
                     <div>
                        <div class="section">
                           <p>For an orderly shutdown of a TLS/DTLS connection, the TLS/DTLS protocols require transmission of close messages. Therefore, when an application is done with the TLS/DTLS connection, it should first obtain the close messages from the <code class="codeph">SSLEngine</code>, then transmit them to the peer using its transport mechanism, and finally shut down the transport mechanism. <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-2B54A68F-75AF-4FEA-9339-F7082FE5DA33__SHUTTINGDOWNANSSLTLSCONNECTION-B4C0BC69">Example 8-10</a> illustrates this.
                           </p>
                           <p>In addition to an application explicitly closing the <code class="codeph">SSLEngine</code>, the <code class="codeph">SSLEngine</code> might be closed by the peer (via receipt of a close message while it is processing handshake data), or by the <code class="codeph">SSLEngine</code> encountering an error while processing application or handshake data, indicated by throwing an <code class="codeph">SSLException</code>. In such cases, the application should invoke <code class="codeph">SSLEngine.wrap()</code> to get the close message and send it to the peer until <code class="codeph">SSLEngine.isOutboundDone()</code> returns <code class="codeph">true</code> (as shown in <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-2B54A68F-75AF-4FEA-9339-F7082FE5DA33__SHUTTINGDOWNANSSLTLSCONNECTION-B4C0BC69">Example 8-10</a>), or until the <code class="codeph">SSLEngineResult.getStatus()</code> returns <code class="codeph">CLOSED</code>.
                           </p>
                           <p>In addition to orderly shutdowns, there can also be unexpected shutdowns when the transport link is severed before close messages are exchanged. In the previous examples, the application might get <code class="codeph">-1</code> or <code class="codeph">IOException</code> when trying to read from the nonblocking <code class="codeph">SocketChannel</code>, or get <code class="codeph">IOException</code> when trying to write to the non-blocking <code class="codeph">SocketChannel</code>. When you get to the end of your input data, you should call <code class="codeph">engine.closeInbound()</code>, which will verify with the <code class="codeph">SSLEngine</code> that the remote peer has closed cleanly from the TLS/DTLS perspective. Then the application should still try to shut down cleanly by using the procedure in <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-2B54A68F-75AF-4FEA-9339-F7082FE5DA33__SHUTTINGDOWNANSSLTLSCONNECTION-B4C0BC69">Example 8-10</a>. Obviously, unlike <code class="codeph">SSLSocket</code>, the application using <code class="codeph">SSLEngine</code> must deal with more state transitions, statuses, and programming. See <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__SAMPLECODEILLUSTRATINGTHEUSEOFANSSL-7D23A601">Sample Code Illustrating the Use of an SSLEngine</a>.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-2B54A68F-75AF-4FEA-9339-F7082FE5DA33__SHUTTINGDOWNANSSLTLSCONNECTION-B4C0BC69">
                           <p class="titleinexample">Example 8-10 Sample Code for Shutting Down a SSL/TLS/DTLS Connection</p>
                           <p>The following code sample illustrates how to shut down a TLS/DTLS connection:</p><pre class="codeblock"><code>// Indicate that application is done with engine
engine.closeOutbound();

while (!engine.isOutboundDone()) {
    // Get close message
    SSLEngineResult res = engine.wrap(empty, myNetData);

    // Check res statuses

    // Send close message to peer
    while(myNetData.hasRemaining()) {
        int num = socketChannel.write(myNetData);
        if (num == 0) {
            // no bytes written; try again later
        }
        myNetData().compact();
    }
}

// Close transport
socketChannel.close();
</code></pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-AB362290-033A-4D3B-AAF3-1BFEB1CD472B" name="GUID-AB362290-033A-4D3B-AAF3-1BFEB1CD472B"></a><h4 id="JSSEC-GUID-AB362290-033A-4D3B-AAF3-1BFEB1CD472B" class="sect4">SSLSession and ExtendedSSLSession</h4>
                  <div>
                     <p>The <code class="codeph">javax.net.ssl.SSLSession</code> interface represents a security context negotiated between the two peers of an <code class="codeph">SSLSocket</code> or <code class="codeph">SSLEngine</code> connection. After a session has been arranged, it can be shared by future <code class="codeph">SSLSocket</code> or <code class="codeph">SSLEngine</code> objects connected between the same two peers.
                     </p>
                     <div class="section">
                        <p>In some cases, parameters negotiated during the handshake are needed later in the handshake to make decisions about trust. For example, the list of valid signature algorithms might restrict the certificate types that can be used for authentication. The <code class="codeph">SSLSession</code> can be retrieved <span class="italic">during</span> the handshake by calling <code class="codeph">getHandshakeSession()</code> on an <code class="codeph">SSLSocket</code> or <code class="codeph">SSLEngine</code>. Implementations of <code class="codeph">TrustManager</code> or <code class="codeph">KeyManager</code> can use the <code class="codeph">getHandshakeSession()</code> method to get information about session parameters to help them make decisions.
                        </p>
                        <p>A fully initialized <code class="codeph">SSLSession</code> contains the cipher suite that will be used for communications over a secure socket as well as a nonauthoritative hint as to the network address of the remote peer, and management information such as the time of creation and last use. A session also contains a shared master secret negotiated between the peers that is used to create cryptographic keys for encrypting and guaranteeing the integrity of the communications over an <code class="codeph">SSLSocket</code> or <code class="codeph">SSLEngine</code> connection. The value of this master secret is known only to the underlying secure socket implementation and is not exposed through the <code class="codeph">SSLSession</code> API.
                        </p>
                        <p><code class="codeph">ExtendedSSLSession</code> extends the <code class="codeph">SSLSession</code> interface to support additional session attributes. The <code class="codeph">ExtendedSSLSession</code> class adds methods that describe the signature algorithms that are supported by the local implementation and the peer. The <code class="codeph">getRequestedServerNames()</code> method called on an <code class="codeph">ExtendedSSLSession</code> instance is used to obtain a list of <code class="codeph">SNIServerName</code> objects in the requested <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F">Server Name Indication (SNI) Extension</a>. The server should use the requested server names to guide its selection of an appropriate authentication certificate, and/or other aspects of the security policy. The client should use the requested server names to guide its endpoint identification of the peer's identity, and/or other aspects of the security policy.
                        </p>
                        <p>Calls to the <code class="codeph">getPacketBufferSize()</code> and <code class="codeph">getApplicationBufferSize()</code> methods on <code class="codeph">SSLSession</code> are used to determine the appropriate buffer sizes used by <code class="codeph">SSLEngine</code>.
                        </p>
                        <div class="p">
                           <div class="infoboxnote" id="GUID-AB362290-033A-4D3B-AAF3-1BFEB1CD472B__GUID-17258111-C234-4640-B886-D85221CCE842">
                              <p class="notep1">Note:</p>The TLS protocols specify that implementations are to produce packets containing at most 16 kilobytes (KB) of plain text. However, some implementations violate the specification and generate large records up to 32 KB. If the <code class="codeph">SSLEngine.unwrap()</code> code detects large inbound packets, then the buffer sizes returned by <code class="codeph">SSLSession</code> will be updated dynamically. Applications should always check the BUFFER_OVERFLOW and BUFFER_UNDERFLOW statuses and enlarge the corresponding buffers if necessary. See <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744" title="The status of the SSLEngine is represented by SSLEngineResult.Status.">Understanding SSLEngine Operation Statuses</a>. SunJSSE will always send standard compliant 16 KB records and allow incoming 32 KB records. For a workaround, see the System property <code class="codeph">jsse.SSLEngine.acceptLargeFragments</code> in <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9" title="JSSE includes a standard implementation that can be customized by plugging in different implementations or specifying the default keystore, and so on.">Customizing JSSE</a>.
                           </div> 
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-A14E129D-4D9D-4F38-A9F0-ED6F97B18863" name="GUID-A14E129D-4D9D-4F38-A9F0-ED6F97B18863"></a><h4 id="JSSEC-GUID-A14E129D-4D9D-4F38-A9F0-ED6F97B18863" class="sect4">HttpsURLConnection Class</h4>
                  <div>
                     <p>The <code class="codeph">javax.net.ssl.HttpsURLConnection</code> class extends the <code class="codeph">java.net.HttpURLConnection</code> class and adds support for HTTPS-specific features.
                     </p>
                     <div class="section">
                        <p>The HTTPS protocol is similar to HTTP, but HTTPS first establishes a secure channel through TLS sockets and then verifies the identity of the peer (see <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-D6A538A2-8CEF-4C6D-9C44-295758E64E38">Cipher Suite Choice and Remote Entity Verification</a>) before requesting or receiving data. The <code class="codeph">javax.net.ssl.HttpsURLConnection</code> class extends the <code class="codeph">java.net.HttpURLConnection</code> class and adds support for HTTPS-specific features. To know more about how HTTPS URLs are constructed and used, see the<a href="https://docs.oracle.com/javase/10/docs/api/java/net/URL.html" target="_blank"><span class="apiname">java.net.URL</span></a>, <a href="https://docs.oracle.com/javase/10/docs/api/java/net/URLConnection.html" target="_blank"><span class="apiname">java.net.URLConnection</span></a>, <a href="https://docs.oracle.com/javase/10/docs/api/java/net/HttpURLConnection.html" target="_blank"><span class="apiname">java.net.HttpURLConnection</span></a>, and <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/HttpsURLConnection.html" target="_blank"><span class="apiname">javax.net.ssl.HttpsURLConnection</span></a> classes.
                        </p>
                        <p>Upon obtaining an <code class="codeph">HttpsURLConnection</code> instance, you can configure a number of HTTP and HTTPS parameters before actually initiating the network connection via the <code class="codeph">URLConnection.connect()</code> method. Of particular interest are:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-8BE4AE6F-21EF-4DF0-91D4-B2D36EF625CA">Setting the Assigned SSLSocketFactory</a></li>
                           <li><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-ABE2057C-0F36-48E1-8E76-4FC8D72A6573">Setting the Assigned HostnameVerifier</a></li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div class="sect4"><a id="GUID-8BE4AE6F-21EF-4DF0-91D4-B2D36EF625CA" name="GUID-8BE4AE6F-21EF-4DF0-91D4-B2D36EF625CA"></a><h5 id="JSSEC-GUID-8BE4AE6F-21EF-4DF0-91D4-B2D36EF625CA" class="sect5">Setting the Assigned SSLSocketFactory</h5>
                     <div>
                        <p></p>
                        <div class="section">
                           <p>In some situations, it is desirable to specify the <code class="codeph">SSLSocketFactory</code> that an <code class="codeph">HttpsURLConnection</code> instance uses. For example, you might want to tunnel through a proxy type that is not supported by the default implementation. The new <code class="codeph">SSLSocketFactory</code> could return sockets that have already performed all necessary tunneling, thus allowing <code class="codeph">HttpsURLConnection</code> to use additional proxies.
                           </p>
                           <p>The <code class="codeph">HttpsURLConnection</code> class has a default <code class="codeph">SSLSocketFactory</code> that is assigned when the class is loaded (this is the factory returned by the <code class="codeph">SSLSocketFactory.getDefault()</code> method). Future instances of <code class="codeph">HttpsURLConnection</code> will inherit the current default <code class="codeph">SSLSocketFactory</code> until a new default <code class="codeph">SSLSocketFactory</code> is assigned to the class via the static <code class="codeph">HttpsURLConnection.setDefaultSSLSocketFactory()</code> method. Once an instance of <code class="codeph">HttpsURLConnection</code> has been created, the inherited <code class="codeph">SSLSocketFactory</code> on this instance can be overridden with a call to the <code class="codeph">setSSLSocketFactory()</code> method.
                           </p>
                           <div class="p">
                              <div class="infoboxnote" id="GUID-8BE4AE6F-21EF-4DF0-91D4-B2D36EF625CA__GUID-2DF8B087-98E2-490B-89EC-BA0A4E86DC57">
                                 <p class="notep1">Note:</p>Changing the default static <code class="codeph">SSLSocketFactory</code> has no effect on existing instances of <code class="codeph">HttpsURLConnection</code>. A call to the <code class="codeph">setSSLSocketFactory()</code> method is necessary to change the existing instances.
                              </div> 
                           </div>
                           <p>You can obtain the per-instance or per-class <code class="codeph">SSLSocketFactory</code> by making a call to the <code class="codeph">getSSLSocketFactory()</code> or <code class="codeph">getDefaultSSLSocketFactory()</code> method, respectively.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-ABE2057C-0F36-48E1-8E76-4FC8D72A6573" name="GUID-ABE2057C-0F36-48E1-8E76-4FC8D72A6573"></a><h5 id="JSSEC-GUID-ABE2057C-0F36-48E1-8E76-4FC8D72A6573" class="sect5">Setting the Assigned HostnameVerifier</h5>
                     <div>
                        <p></p>
                        <p>If the host name of the URL does not match the host name in the credentials received as part of the TLS handshake, then it is possible that URL spoofing has occurred. If the implementation cannot determine a host name match with reasonable certainty, then the TLS implementation performs a callback to the instance's assigned <span class="apiname">HostnameVerifier</span> for further checking. The host name verifier can take whatever steps are necessary to make the determination, such as performing host name pattern matching or perhaps opening an interactive dialog box. An unsuccessful verification by the host name verifier closes the connection. For more information regarding host name verification, see <a href="http://www.ietf.org/rfc/rfc2818.txt?number=2818" target="_blank">RFC 2818: HTTP over TLS</a>.
                        </p>
                        <p>The <span class="apiname">setHostnameVerifier()</span> and <span class="apiname">setDefaultHostnameVerifier()</span> methods operate in a similar manner to the <span class="apiname">setSSLSocketFactory()</span> and <span class="apiname">setDefaultSSLSocketFactory()</span> methods, in that <span class="apiname">HostnameVerifier</span> objects are assigned on a per-instance and per-class basis, and the current values can be obtained by a call to the <span class="apiname">getHostnameVerifier()</span> or <span class="apiname">getDefaultHostnameVerifier()</span> method.
                        </p>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-AD2529FD-8778-4A02-B544-5F58E083774B" name="GUID-AD2529FD-8778-4A02-B544-5F58E083774B"></a><h4 id="JSSEC-GUID-AD2529FD-8778-4A02-B544-5F58E083774B" class="sect4">Support Classes and Interfaces</h4>
                  <div>
                     <p></p>
                     <p>The classes and interfaces in this section are provided to support the creation and initialization of <code class="codeph">SSLContext</code> objects, which are used to create <code class="codeph">SSLSocketFactory</code>, <code class="codeph">SSLServerSocketFactory</code>, and <code class="codeph">SSLEngine</code> objects. The support classes and interfaces are part of the <code class="codeph">javax.net.ssl</code> package.
                     </p>
                     <p>Three of the classes described in this section (<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-C281CAF3-275F-4DE4-8B47-4A84363CF39F" title="The javax.net.ssl.SSLContext class is an engine class for an implementation of a secure socket protocol. An instance of this class acts as a factory for SSLSocket, SSLServerSocket, and SSLEngine. An SSLContext object holds all of the state information shared across all objects created under that context. For example, session state is associated with the SSLContext when it is negotiated through the handshake protocol by sockets created by socket factories provided by the context. These cached sessions can be reused and shared by other sockets created under the same context.">SSLContext Class</a>, <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-616A7E77-587C-44E0-9F69-92BEDF631D5F" title="The javax.net.ssl.KeyManagerFactory class is an engine class for a provider-based service that acts as a factory for one or more types of KeyManager objects. The SunJSSE provider implements a factory that can return a basic X.509 key manager. Because it is provider-based, additional factories can be implemented and configured to provide additional or alternative key managers.">KeyManagerFactory Class</a>, and <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-AB5DA59B-B070-4AC5-A9C1-C3C30BF9209F" title="The javax.net.ssl.TrustManagerFactory is an engine class for a provider-based service that acts as a factory for one or more types of TrustManager objects. Because it is provider-based, additional factories can be implemented and configured to provide additional or alternative trust managers that provide more sophisticated services or that implement installation-specific authentication policies.">TrustManagerFactory Class</a>) are <span class="italic"><span>engine classes</span></span>. An engine class is an API class for specific algorithms (or protocols, in the case of <code class="codeph">SSLContext</code>), for which implementations may be provided in one or more Cryptographic Service Provider (provider) packages. See <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-71693272-7F57-4155-99F9-A2139271FD6D">JCA Design Principles</a> and <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-A7EEDE25-C4C0-4C28-94EA-262858AE9212" title="An engine class provides the interface to a specific type of cryptographic service, independent of a particular cryptographic algorithm or provider.">Engine Classes and Algorithms</a>.
                     </p>
                     <p>The SunJSSE provider that comes standard with JSSE provides <code class="codeph">SSLContext</code>, <code class="codeph">KeyManagerFactory</code>, and <code class="codeph">TrustManagerFactory</code> implementations, as well as implementations for engine classes in the standard <code class="codeph">java.security</code> API. <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-AD2529FD-8778-4A02-B544-5F58E083774B__GUID-8487642F-B1E3-4DB7-BA5E-ABF8971F8A58" title="The following table lists implementations supplied by SunJSSE.">Table 8-1</a> lists implementations supplied by SunJSSE.
                     </p>
                     <div class="tblformal" id="GUID-AD2529FD-8778-4A02-B544-5F58E083774B__GUID-8487642F-B1E3-4DB7-BA5E-ABF8971F8A58">
                        <p class="titleintable">Table 8-1 Implementations Supplied by SunJSSE</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="Implementations Supplied by SunJSSE" summary="The following table lists implementations supplied by SunJSSE." width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th rowspan="1" colspan="1" align="left" valign="bottom" id="d112429e2123">Engine Class Implemented</th>
                                 <th rowspan="1" colspan="1" align="left" valign="bottom" id="d112429e2125">Algorithm or Protocol</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td rowspan="1" colspan="1" align="left" valign="top" id="d112429e2129" headers="d112429e2123 "><code class="codeph">KeyStore</code></td>
                                 <td rowspan="1" colspan="1" align="left" valign="top" headers="d112429e2129 d112429e2125 ">PKCS12</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td rowspan="1" colspan="1" align="left" valign="top" id="d112429e2135" headers="d112429e2123 "><code class="codeph">KeyManagerFactory</code></td>
                                 <td rowspan="1" colspan="1" align="left" valign="top" headers="d112429e2135 d112429e2125 ">PKIX, SunX509</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td rowspan="1" colspan="1" align="left" valign="top" id="d112429e2141" headers="d112429e2123 "><code class="codeph">TrustManagerFactory</code></td>
                                 <td rowspan="1" colspan="1" align="left" valign="top" headers="d112429e2141 d112429e2125 ">PKIX (X509 or SunPKIX), SunX509</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td rowspan="1" colspan="1" align="left" valign="top" id="d112429e2147" headers="d112429e2123 "><code class="codeph">SSLContext</code></td>
                                 <td rowspan="1" colspan="1" align="left" valign="top" headers="d112429e2147 d112429e2125 ">SSLv3<a id="fn_1" name="fn_1" href="#fn_1" onclick='footdisplay(1, "Starting with JDK 8u31, the SSLv3 protocol (Secure Socket Layer) has been deactivated and is not available by default. See the java.security.Security property jdk.tls.disabledAlgorithms in the <java_home&gt;/conf/security/java.security file. If SSLv3 is absolutely required, the protocol can be reactivated by removing SSLv3 from the jdk.tls.disabledAlgorithms property in the java.security file or by dynamically setting this Security Property before JSSE is initialized.")'><sup>Foot&nbsp;1</sup></a>, TLSv1, TLSv1.1, TLSv1.2, TLSv1.3, DTLSv1.0, DTLSv1.2
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p class="tablefootnote"><sup class="tablefootnote">Footnote&nbsp;1 </sup>Starting with JDK 8u31, the SSLv3 protocol (Secure Socket Layer) has been deactivated and is not available by default. See the <code class="codeph">java.security.Security</code> property <code class="codeph">jdk.tls.disabledAlgorithms</code> in the <code class="codeph"><span class="variable" translate="no">&lt;java_home&gt;</span>/conf/security/java.security</code> file. If SSLv3 is absolutely required, the protocol can be reactivated by removing <code class="codeph">SSLv3</code> from the <code class="codeph">jdk.tls.disabledAlgorithms</code> property in the <code>java.security</code> file or by dynamically setting this Security Property before JSSE is initialized.
                     </p>
                  </div>
                  <div class="sect4"><a id="GUID-C281CAF3-275F-4DE4-8B47-4A84363CF39F" name="GUID-C281CAF3-275F-4DE4-8B47-4A84363CF39F"></a><h5 id="JSSEC-GUID-C281CAF3-275F-4DE4-8B47-4A84363CF39F" class="sect5">SSLContext Class</h5>
                     <div>
                        <p>The <code class="codeph">javax.net.ssl.SSLContext</code> class is an engine class for an implementation of a secure socket protocol. An instance of this class acts as a factory for <code class="codeph">SSLSocket</code>, <code class="codeph">SSLServerSocket</code>, and <code class="codeph">SSLEngine</code>. An <code class="codeph">SSLContext</code> object holds all of the state information shared across all objects created under that context. For example, session state is associated with the <code class="codeph">SSLContext</code> when it is negotiated through the handshake protocol by sockets created by socket factories provided by the context. These cached sessions can be reused and shared by other sockets created under the same context.
                        </p>
                        <p>Each instance is configured through its <code class="codeph">init</code> method with the keys, certificate chains, and trusted root CA certificates that it needs to perform authentication. This configuration is provided in the form of key and trust managers. These managers provide support for the authentication and key agreement aspects of the cipher suites supported by the context.
                        </p>
                        <p>Currently, only X.509-based managers are supported.</p>
                     </div>
                     <div class="sect5"><a id="GUID-1F3F9B1E-143A-4C05-922E-152EA1DFAE90" name="GUID-1F3F9B1E-143A-4C05-922E-152EA1DFAE90"></a><h6 id="JSSEC-GUID-1F3F9B1E-143A-4C05-922E-152EA1DFAE90" class="sect6">Obtaining and Initializing the SSLContext Class</h6>
                        <div>
                           <p>The <code class="codeph">SSLContext</code> class is used to create the <code class="codeph">SSLSocketFactory</code> or <code class="codeph">SSLServerSocketFactory</code> class.
                           </p>
                           <p>There are two ways to obtain and initialize an <code class="codeph">SSLContext</code>:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>The simplest way is to call the static <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLContext.html#getDefault" target="_blank"><code class="codeph">SSLContext.getDefault</code></a> method on either the <code class="codeph">SSLSocketFactory</code> or <code class="codeph">SSLServerSocketFactory</code> class. This method creates a default <code class="codeph">SSLContext</code> with a default <code class="codeph">KeyManager</code>, <code class="codeph">TrustManager</code>, and <code class="codeph">SecureRandom</code> (a secure random number generator). A default <code class="codeph">KeyManagerFactory</code> and <code class="codeph">TrustManagerFactory</code> are used to create the <code class="codeph">KeyManager</code> and <code class="codeph">TrustManager</code>, respectively. The key material used is found in the default keystore and truststore, as determined by system properties described in <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150">Customizing the Default Keystores and Truststores, Store Types, and Store Passwords</a>.
                              </li>
                              <li>The approach that gives the caller the most control over the behavior of the created context is to call the static method <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLContext.html#getDefault" target="_blank"><code class="codeph">SSLContext.getDefault</code></a> on the <code class="codeph">SSLContext</code> class, and then initialize the context by calling the instance's proper <code class="codeph">init()</code> method. One variant of the <code class="codeph">init()</code> method takes three arguments: an array of <code class="codeph">KeyManager</code> objects, an array of <code class="codeph">TrustManager</code> objects, and a <code class="codeph">SecureRandom</code> object. The <code class="codeph">KeyManager</code> and <code class="codeph">TrustManager</code> objects are created by either implementing the appropriate interfaces or using the <code class="codeph">KeyManagerFactory</code> and <code class="codeph">TrustManagerFactory</code> classes to generate implementations. The <code class="codeph">KeyManagerFactory</code> and <code class="codeph">TrustManagerFactory</code> can then each be initialized with key material contained in the <code class="codeph">KeyStore</code> passed as an argument to the <code class="codeph">init()</code> method of the <code class="codeph">TrustManagerFactory</code> or <code class="codeph">KeyManagerFactory</code> classes. Finally, the <code class="codeph">getTrustManagers()</code> method (in <code class="codeph">TrustManagerFactory</code>) and <code class="codeph">getKeyManagers()</code> method (in <code class="codeph">KeyManagerFactory</code>) can be called to obtain the array of trust managers or key managers, one for each type of trust or key material.
                              </li>
                           </ul>
                           <p>Once a TLS connection is established, an <code class="codeph">SSLSession</code> is created which contains various information, such as identities established and cipher suite used. The <code class="codeph">SSLSession</code> is then used to describe an ongoing relationship and state information between two entities. Each TLS connection involves one session at a time, but that session may be used on many connections between those entities, simultaneously or sequentially.
                           </p>
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-9BAC1902-A203-4422-8163-61D64ADD2FF7" name="GUID-9BAC1902-A203-4422-8163-61D64ADD2FF7"></a><h6 id="JSSEC-GUID-9BAC1902-A203-4422-8163-61D64ADD2FF7" class="sect6">Creating an SSLContext Object</h6>
                        <div>
                           <p>Like other JCA provider-based engine classes, <code class="codeph">SSLContext</code> objects are created using the <code class="codeph">getInstance()</code> factory methods of the <code class="codeph">SSLContext</code> class. These static methods each return an instance that implements <span class="italic">at least</span> the requested secure socket protocol. The returned instance may implement other protocols, too. For example, <code class="codeph">getInstance("TLSv1")</code> may return an instance that implements TLSv1, TLSv1.1, and TLSv1.2. The <code class="codeph">getSupportedProtocols()</code> method returns a list of supported protocols when an <code class="codeph">SSLSocket</code>, <code class="codeph">SSLServerSocket</code>, or <code class="codeph">SSLEngine</code> is created from this context. You can control which protocols are actually enabled for an SSL connection by using the <code class="codeph">setEnabledProtocols(String[] protocols)</code> method.
                           </p>
                           <div class="section">
                              <div class="infoboxnote" id="GUID-9BAC1902-A203-4422-8163-61D64ADD2FF7__GUID-AEF580E3-5151-4C8F-A5DE-A21E08BC18A2">
                                 <p class="notep1">Note:</p>An <code class="codeph">SSLContext</code> object is automatically created, initialized, and statically assigned to the <code class="codeph">SSLSocketFactory</code> class when you call the <code class="codeph">SSLSocketFactory.getDefault()</code> method. Therefore, you do not have to directly create and initialize an <span class="apiname">SSLContext</span> object (unless you want to override the default behavior).
                              </div>
                              <p>To create an <code class="codeph">SSLContext</code> object by calling the <code class="codeph">getInstance()</code> factory method, you must specify the protocol name. You may also specify which provider you want to supply the implementation of the requested protocol:
                              </p>
                              <ul style="list-style-type: disc;">
                                 <li><code class="codeph">public static SSLContext getInstance(String protocol);</code></li>
                                 <li><code class="codeph">public static SSLContext getInstance(String protocol, String provider);</code></li>
                                 <li><code class="codeph">public static SSLContext getInstance(String protocol, Provider provider);</code></li>
                              </ul>
                              <p>If just a protocol name is specified, then the system will determine whether an implementation of the requested protocol is available in the environment. If there is more than one implementation, then it will determine whether there is a preferred one.</p>
                              <p>If both a protocol name and a provider are specified, then the system will determine whether an implementation of the requested protocol is in the provider requested. If there is no implementation, an exception will be thrown.</p>
                              <p>A protocol is a string (such as <code class="codeph">"TLS"</code>) that describes the secure socket protocol desired. Common protocol names for <code class="codeph">SSLContext</code> objects are defined in <a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html" target="_blank">Java Security Standard Algorithm Names</a>.
                              </p>
                              <p>An <code class="codeph">SSLContext</code> can be obtained as follows:
                              </p><pre class="codeblock"><code>SSLContext sc = SSLContext.getInstance("TLS");
</code></pre><p>A newly created <code class="codeph">SSLContext</code> should be initialized by calling the <code class="codeph">init</code> method:
                              </p><pre class="codeblock"><code>public void init(KeyManager[] km, TrustManager[] tm, SecureRandom random);
</code></pre><p>If the <code class="codeph">KeyManager[]</code> parameter is null, then an empty <code class="codeph">KeyManager</code> will be defined for this context. If the <code class="codeph">TrustManager[]</code> parameter is null, then the installed security providers will be searched for the highest-priority implementation of the <span class="apiname">TrustManagerFactory</span> class (see <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-AB5DA59B-B070-4AC5-A9C1-C3C30BF9209F" title="The javax.net.ssl.TrustManagerFactory is an engine class for a provider-based service that acts as a factory for one or more types of TrustManager objects. Because it is provider-based, additional factories can be implemented and configured to provide additional or alternative trust managers that provide more sophisticated services or that implement installation-specific authentication policies.">TrustManagerFactory Class</a>), from which an appropriate <code class="codeph">TrustManager</code> will be obtained. Likewise, the <code class="codeph">SecureRandom</code> parameter may be null, in which case a default implementation will be used.
                              </p>
                              <p>If the internal default context is used, (for example, an <code class="codeph">SSLContext</code> is created by <code class="codeph">SSLSocketFactory.getDefault()</code> or <code class="codeph">SSLServerSocketFactory.getDefault()</code>), then a <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-0ACD9274-607C-49BE-AED9-BEE2B4F2BEF2">default KeyManager and TrustManager</a> are created. The default <code class="codeph">SecureRandom</code> implementation is also chosen.
                              </p>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-42CA1099-42AD-4772-BC4A-29C2A78E3EC9" name="GUID-42CA1099-42AD-4772-BC4A-29C2A78E3EC9"></a><h5 id="JSSEC-GUID-42CA1099-42AD-4772-BC4A-29C2A78E3EC9" class="sect5">TrustManager Interface</h5>
                     <div>
                        <p>The primary responsibility of the <code class="codeph">TrustManager</code> is to determine whether the presented authentication credentials should be trusted. If the credentials are not trusted, then the connection will be terminated. To authenticate the remote identity of a secure socket peer, you must initialize an <code class="codeph">SSLContext</code> object with one or more <code class="codeph">TrustManager</code> objects. You must pass one <code class="codeph">TrustManager</code> for each authentication mechanism that is supported. If null is passed into the <code class="codeph">SSLContext</code> initialization, then a trust manager will be created for you. Typically, a single trust manager supports authentication based on X.509 public key certificates (for example, <code class="codeph">X509TrustManager</code>). Some secure socket implementations may also support authentication based on shared secret keys, Kerberos, or other mechanisms.
                        </p>
                        <p><code class="codeph">TrustManager</code> objects are created either by a <code class="codeph">TrustManagerFactory</code>, or by providing a concrete implementation of the interface.
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-AB5DA59B-B070-4AC5-A9C1-C3C30BF9209F" name="GUID-AB5DA59B-B070-4AC5-A9C1-C3C30BF9209F"></a><h5 id="JSSEC-GUID-AB5DA59B-B070-4AC5-A9C1-C3C30BF9209F" class="sect5">TrustManagerFactory Class</h5>
                     <div>
                        <p>The <code class="codeph">javax.net.ssl.TrustManagerFactory</code> is an engine class for a provider-based service that acts as a factory for one or more types of <code class="codeph">TrustManager</code> objects. Because it is provider-based, additional factories can be implemented and configured to provide additional or alternative trust managers that provide more sophisticated services or that implement installation-specific authentication policies.
                        </p>
                     </div>
                     <div class="sect5"><a id="GUID-CF1771C6-D881-48E3-BB0D-49DC3E7C893B" name="GUID-CF1771C6-D881-48E3-BB0D-49DC3E7C893B"></a><h6 id="JSSEC-GUID-CF1771C6-D881-48E3-BB0D-49DC3E7C893B" class="sect6">Creating a TrustManagerFactory</h6>
                        <div>
                           <p>You create an instance of this class in a similar manner to <code class="codeph">SSLContext</code>, except for passing an algorithm name string instead of a protocol name to the <code class="codeph">getInstance()</code> method:
                           </p>
                           <div class="section"><pre class="codeblock"><code>TrustManagerFactory tmf = TrustManagerFactory.getInstance(String algorithm);
TrustManagerFactory tmf = TrustManagerFactory.getInstance(String algorithm, String provider);
TrustManagerFactory tmf = TrustManagerFactory.getInstance(String algorithm, Provider provider);
</code></pre><p>A sample call is as follows:</p><pre class="codeblock"><code>TrustManagerFactory tmf = TrustManagerFactory.getInstance("PKIX", "SunJSSE");
</code></pre><p>The preceding call creates an instance of the SunJSSE provider's PKIX trust manager factory. This factory can be used to create trust managers that provide X.509 PKIX-based certification path validity checking.</p>
                              <p>When initializing an <code class="codeph">SSLContext</code>, you can use trust managers created from a trust manager factory, or you can write your own trust manager, for example, using the <a href="https://docs.oracle.com/javase/10/docs/api/java/security/cert/CertPath.html" target="_blank"><code class="codeph">CertPath</code> </a> API. See <a href="java-pki-programmers-guide.html#GUID-E47B8A0E-6B3A-4B49-994D-CF185BF441EC" title="The CertPath class is an abstract class for certification paths. It defines the functionality shared by all certification path objects. Various certification path types can be implemented by subclassing the CertPath class, even though they may have different contents and ordering schemes.">Java PKI Programmer’s Guide</a>. You do not need to use a trust manager factory if you implement a trust manager using the <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/X509TrustManager.html" target="_blank"><code class="codeph">X509TrustManager</code></a> interface.
                              </p>
                              <p>A newly created factory should be initialized by calling one of the <code class="codeph">init()</code> methods:
                              </p><pre class="codeblock"><code>public void init(KeyStore ks);
public void init(ManagerFactoryParameters spec);
</code></pre><p>Call whichever <code class="codeph">init()</code> method is appropriate for the <code class="codeph">TrustManagerFactory</code> you are using. If you are not sure, then ask the provider vendor.
                              </p>
                              <p>For many factories, such as the SunX509 <code class="codeph">TrustManagerFactory</code> from the SunJSSE provider, the <code class="codeph">KeyStore</code> is the only information required to initialize the <code class="codeph">TrustManagerFactory</code> and thus the first <code class="codeph">init</code> method is the appropriate one to call. The <code class="codeph">TrustManagerFactory</code> will query the <code class="codeph">KeyStore</code> for information about which remote certificates should be trusted during authorization checks.
                              </p>
                              <p>Sometimes, initialization parameters other than a <code class="codeph">KeyStore</code> are needed by a provider. Users of that provider are expected to pass an implementation of the appropriate <code class="codeph">ManagerFactoryParameters</code> as defined by the provider. The provider can then call the specified methods in the <code class="codeph">ManagerFactoryParameters</code> implementation to obtain the needed information.
                              </p>
                              <p>For example, suppose the <code class="codeph">TrustManagerFactory</code> provider requires initialization parameters B, R, and S from any application that wants to use that provider. Like all providers that require initialization parameters other than a <code class="codeph">KeyStore</code>, the provider requires the application to provide an instance of a class that implements a particular <code class="codeph">ManagerFactoryParameters</code> subinterface. In the example, suppose that the provider requires the calling application to implement and create an instance of <code class="codeph">MyTrustManagerFactoryParams</code> and pass it to the second <code class="codeph">init()</code> method. The following example illustrates what <code class="codeph">MyTrustManagerFactoryParams</code> can look like:
                              </p><pre class="codeblock"><code>public interface MyTrustManagerFactoryParams extends ManagerFactoryParameters {
  public boolean getBValue();
  public float getRValue();
  public String getSValue();
}
</code></pre><p>Some trust managers can make trust decisions without being explicitly initialized with a <code class="codeph">KeyStore</code> object or any other parameters. For example, they may access trust material from a local directory service via LDAP, use a remote online certificate status checking server, or access default trust material from a standard local location.
                              </p>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-ED23411A-B4AA-4E46-A5E9-619A0CF30151" name="GUID-ED23411A-B4AA-4E46-A5E9-619A0CF30151"></a><h6 id="JSSEC-GUID-ED23411A-B4AA-4E46-A5E9-619A0CF30151" class="sect6">PKIX TrustManager Support</h6>
                        <div>
                           <p>The default trust manager algorithm is PKIX. It can be changed by editing the <code class="codeph">ssl.TrustManagerFactory.algorithm</code> property in the <code class="codeph">java.security</code> file.
                           </p>
                           <p>The PKIX trust manager factory uses the CertPath PKIX implementation (see <a href="java-pki-programmers-guide.html#GUID-D6A18B1E-A2A8-4CA2-BD18-514CD807810E" title="The Java Certification Path API defines interfaces and abstract classes for creating, building, and validating certification paths.&nbsp; Implementations may be plugged in using a provider-based interface.">PKI Programmers Guide Overview</a>) from an installed security provider. The trust manager factory can be initialized using the normal <code class="codeph">init(KeyStores)</code> method, or by passing <span class="apiname">CertPath</span> parameters to the PKIX trust manager using the <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/CertPathTrustManagerParameters.html" target="_blank"><span class="apiname">CertPathTrustManagerParameters</span></a> class.
                           </p>
                           <p><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-ED23411A-B4AA-4E46-A5E9-619A0CF30151__EXAMPLE-1326-635DA89D">Example 8-11</a> illustrates how to get the trust manager to use a particular LDAP certificate store and enable revocation checking.
                           </p>
                           <p>If the <code class="codeph">TrustManagerFactory.init(KeyStore)</code> method is used, then default PKIX parameters are used with the exception that revocation checking is disabled. It can be enabled by setting the <code class="codeph">com.sun.net.ssl.checkRevocation</code> system property to <code class="codeph">true</code>. This setting requires that the CertPath implementation can locate revocation information by itself. The PKIX implementation in the provider can do this in many cases but requires that the system property <code class="codeph">com.sun.security.enableCRLDP</code> be set to <code class="codeph">true</code>. Note that the <span class="apiname">TrustManagerFactory.init(ManagerFactoryParameters)</span> method has revocation checking enabled by default.
                           </p>
                           <p>See <a href="java-pki-programmers-guide.html#GUID-5BBEF087-CA8A-4287-97FB-BD88DCD12FE5" title="The Java Certification Path API includes a set of algorithm-specific classes modeled for use with the PKIX certification path validation algorithm.">PKIX Classes</a> and <a href="java-pki-programmers-guide.html#GUID-E47B8A0E-6B3A-4B49-994D-CF185BF441EC" title="The CertPath class is an abstract class for certification paths. It defines the functionality shared by all certification path objects. Various certification path types can be implemented by subclassing the CertPath class, even though they may have different contents and ordering schemes.">The CertPath Class</a>.
                           </p>
                           <div class="example" id="GUID-ED23411A-B4AA-4E46-A5E9-619A0CF30151__EXAMPLE-1326-635DA89D">
                              <p class="titleinexample">Example 8-11 Sample Code for Using a LDAP Certificate to Enable Revocation Checking</p>
                              <p>The following example illustrates how to get the trust manager to use a particular LDAP certificate store and enable revocation checking:</p><pre class="codeblock"><code>
    import javax.net.ssl.*;
    import java.security.cert.*;
    import java.security.KeyStore;
    import java.io.FileInputStream;
    ...
    
    // Obtain Keystore password
    char[] pass = System.console().readPassword("Password: ");

    // Create PKIX parameters
    KeyStore anchors = KeyStore.getInstance("JKS");
    anchors.load(new FileInputStream(anchorsFile, pass));
    PKIXBuilderParameters pkixParams = new PKIXBuilderParameters(anchors, new X509CertSelector());
    
    // Specify LDAP certificate store to use
    LDAPCertStoreParameters lcsp = new LDAPCertStoreParameters("ldap.imc.org", 389);
    pkixParams.addCertStore(CertStore.getInstance("LDAP", lcsp));
    
    // Specify that revocation checking is to be enabled
    pkixParams.setRevocationEnabled(true);
    
    // Wrap PKIX parameters as trust manager parameters
    ManagerFactoryParameters trustParams = new CertPathTrustManagerParameters(pkixParams);
    
    // Create TrustManagerFactory for PKIX-compliant trust managers
    TrustManagerFactory factory = TrustManagerFactory.getInstance("PKIX");
    
    // Pass parameters to factory to be passed to CertPath implementation
    factory.init(trustParams);
    
    // Use factory
    SSLContext ctx = SSLContext.getInstance("TLS");
    ctx.init(null, factory.getTrustManagers(), null);
</code></pre></div>
                           <!-- class="example" -->
                        </div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-7932AB21-2FED-402E-A806-3088402BAEA6" name="GUID-7932AB21-2FED-402E-A806-3088402BAEA6"></a><h5 id="JSSEC-GUID-7932AB21-2FED-402E-A806-3088402BAEA6" class="sect5">X509TrustManager Interface</h5>
                     <div>
                        <p>The <code class="codeph">javax.net.ssl.X509TrustManager</code> interface extends the general <code class="codeph">TrustManager</code> interface. It must be implemented by a trust manager when using X.509-based authentication.
                        </p>
                        <p>To support X.509 authentication of remote socket peers through JSSE, an instance of this interface must be passed to the <code class="codeph">init</code> method of an <code class="codeph">SSLContext</code> object.
                        </p>
                     </div>
                     <div class="sect5"><a id="GUID-32CF3420-56E8-4BC5-8D3B-1F6B4692A290" name="GUID-32CF3420-56E8-4BC5-8D3B-1F6B4692A290"></a><h6 id="JSSEC-GUID-32CF3420-56E8-4BC5-8D3B-1F6B4692A290" class="sect6">Creating an X509TrustManager</h6>
                        <div>
                           <p>You can either implement this interface directly yourself or obtain one from a provider-based <code class="codeph">TrustManagerFactory</code> (such as that supplied by the SunJSSE provider). You could also implement your own interface that delegates to a factory-generated trust manager. For example, you might do this to filter the resulting trust decisions and query an end-user through a graphical user interface.
                           </p>
                           <div class="section">
                              <p>If a null KeyStore parameter is passed to the SunJSSE PKIX or SunX509 <code class="codeph">TrustManagerFactory</code>, then the factory uses the following process to try to find trust material:
                              </p>
                              <ol>
                                 <li> 
                                    <p>If the <code class="codeph">javax.net.ssl.trustStore</code> property is defined, then the <code class="codeph">TrustManagerFactory</code> attempts to find a file using the file name specified by that system property, and uses that file for the KeyStore parameter. If the <code class="codeph">javax.net.ssl.trustStorePassword</code> system property is also defined, then its value is used to check the integrity of the data in the truststore before opening it.
                                    </p> 
                                    <p>If the <code class="codeph">javax.net.ssl.trustStore</code> property is defined but the specified file does not exist, then a default <code class="codeph">TrustManager</code> using an empty keystore is created.
                                    </p> 
                                 </li>
                                 <li>If the <code class="codeph">javax.net.ssl.trustStore</code> system property was not specified, then: 
                                    <ul style="list-style-type: disc;">
                                       <li>if the file <span class="variable" translate="no">java-home</span><code class="codeph">/lib/security/jssecacerts</code> exists, that file is used;
                                       </li>
                                       <li>if the file <span class="variable" translate="no">java-home</span><code class="codeph">/lib/security/cacerts</code> exists, that file is used;
                                       </li>
                                       <li>if neither of these files exists, then the TLS cipher suite is anonymous, does not perform any authentication, and thus does not need a truststore.</li>
                                    </ul> 
                                 </li>
                              </ol>
                              <p>To know more about what <span class="variable" translate="no">java-home</span> refers to, see <a href="terms-and-definitions.html" title="The following are commonly used cryptography terms and their definitions.">Terms and Definitions</a>.
                              </p>
                              <p>The factory looks for a file specified via the <code class="codeph">javax.net.ssl.trustStore</code> Security Property or for the <code>jssecacerts</code> file before checking for a <code class="codeph">cacerts</code> file. Therefore, you can provide a JSSE-specific set of trusted root certificates separate from ones that might be present in <code>cacerts</code> for code-signing purposes.
                              </p>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-E1205974-3249-4E40-83C0-5F89C7375CF4" name="GUID-E1205974-3249-4E40-83C0-5F89C7375CF4"></a><h6 id="JSSEC-GUID-E1205974-3249-4E40-83C0-5F89C7375CF4" class="sect6">Creating Your Own X509TrustManager</h6>
                        <div>
                           <p>If the supplied <code class="codeph">X509TrustManager</code> behavior is not suitable for your situation, then you can create your own <code class="codeph">X509TrustManager</code> by either creating and registering your own <code class="codeph">TrustManagerFactory</code> or by implementing the <code class="codeph">X509TrustManager</code> interface directly.
                           </p>
                           <div class="section">
                              <p><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-E1205974-3249-4E40-83C0-5F89C7375CF4__EXAMPLE-1327-635DA68E">Example 8-12</a> illustrates a <code class="codeph">MyX509TrustManager</code> class that enhances the default SunJSSE <code class="codeph">X509TrustManager</code> behavior by providing alternative authentication logic when the default <code class="codeph">X509TrustManager</code> fails.
                              </p>
                              <p>Once you have created such a trust manager, assign it to an <code class="codeph">SSLContext</code> via the <code class="codeph">init()</code> method, as in the following example. Future <code class="codeph">SocketFactories</code> created from this <code class="codeph">SSLContext</code> will use your new <code class="codeph">TrustManager</code> when making trust decisions.
                              </p><pre class="codeblock"><code>TrustManager[] myTMs = new TrustManager[] { new MyX509TrustManager() };
SSLContext ctx = SSLContext.getInstance("TLS");
ctx.init(null, myTMs, null);
</code></pre></div>
                           <!-- class="section" -->
                           <div class="example" id="GUID-E1205974-3249-4E40-83C0-5F89C7375CF4__EXAMPLE-1327-635DA68E">
                              <p class="titleinexample">Example 8-12 Sample Code for Creating a X509TrustManager</p>
                              <p>The following code sample illustrates <code class="codeph">MyX509TrustManager</code> class that enhances the default SunJSSE <code class="codeph">X509TrustManager</code> behavior by providing alternative authentication logic when the default <code class="codeph">X509TrustManager</code> fails:
                              </p><pre class="codeblock"><code>
class MyX509TrustManager implements X509TrustManager {

     /*
      * The default PKIX X509TrustManager9.  Decisions are delegated
      * to it, and a fall back to the logic in this class is performed
      * if the default X509TrustManager does not trust it.
      */
     X509TrustManager pkixTrustManager;

     MyX509TrustManager() throws Exception {
         // create a "default" JSSE X509TrustManager.

         KeyStore ks = KeyStore.getInstance("JKS");
         ks.load(new FileInputStream("trustedCerts"), "passphrase".toCharArray());

         TrustManagerFactory tmf = TrustManagerFactory.getInstance("PKIX");
         tmf.init(ks);

         TrustManager tms [] = tmf.getTrustManagers();

         /*
          * Iterate over the returned trust managers, looking
          * for an instance of X509TrustManager.  If found,
          * use that as the default trust manager.
          */
         for (int i = 0; i &lt; tms.length; i++) {
             if (tms[i] instanceof X509TrustManager) {
                 pkixTrustManager = (X509TrustManager) tms[i];
                 return;
             }
         }

         /*
          * Find some other way to initialize, or else the
          * constructor fails.
          */
         throw new Exception("Couldn't initialize");
     }

     /*
      * Delegate to the default trust manager.
      */
     public void checkClientTrusted(X509Certificate[] chain, String authType)
                 throws CertificateException {
         try {
             pkixTrustManager.checkClientTrusted(chain, authType);
         } catch (CertificateException excep) {
             // do any special handling here, or rethrow exception.
         }
     }

     /*
      * Delegate to the default trust manager.
      */
     public void checkServerTrusted(X509Certificate[] chain, String authType)
                 throws CertificateException {
         try {
             pkixTrustManager.checkServerTrusted(chain, authType);
         } catch (CertificateException excep) {
             /*
              * Possibly pop up a dialog box asking whether to trust the
              * cert chain.
              */
         }
     }

     /*
      * Merely pass this through.
      */
     public X509Certificate[] getAcceptedIssuers() {
         return pkixTrustManager.getAcceptedIssuers();
     }
}
</code></pre></div>
                           <!-- class="example" -->
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-43F18232-8DDE-4F0C-B2AB-0EE4B472B15F" name="GUID-43F18232-8DDE-4F0C-B2AB-0EE4B472B15F"></a><h6 id="JSSEC-GUID-43F18232-8DDE-4F0C-B2AB-0EE4B472B15F" class="sect6">Updating the Keystore Dynamically</h6>
                        <div>
                           <p>You can enhance <code class="codeph">MyX509TrustManager</code> to handle dynamic keystore updates. When a <code class="codeph">checkClientTrusted</code> or <code class="codeph">checkServerTrusted</code> test fails and does not establish a trusted certificate chain, you can add the required trusted certificate to the keystore. You must create a new <code class="codeph">pkixTrustManager</code> from the <code class="codeph">TrustManagerFactory</code> initialized with the updated keystore. When you establish a new connection (using the previously initialized <code class="codeph">SSLContext</code>), the newly added certificate will be used when making trust decisions.
                           </p>
                        </div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-BAAC4A6F-2705-4A16-874A-1CDF0E48B8E3" name="GUID-BAAC4A6F-2705-4A16-874A-1CDF0E48B8E3"></a><h5 id="JSSEC-GUID-BAAC4A6F-2705-4A16-874A-1CDF0E48B8E3" class="sect5">X509ExtendedTrustManager Class</h5>
                     <div>
                        <p>The <code class="codeph">X509ExtendedTrustManager</code> class is an abstract implementation of the <code class="codeph">X509TrustManager</code> interface. It adds methods for connection-sensitive trust management. In addition, it enables endpoint verification at the TLS layer.
                        </p>
                        <p>In TLS 1.2 and later, both client and server can specify which hash and signature algorithms they will accept. To authenticate the remote side, authentication decisions must be based on both X509 certificates and the local accepted hash and signature algorithms. The local accepted hash and signature algorithms can be obtained using the <code class="codeph">ExtendedSSLSession.getLocalSupportedSignatureAlgorithms()</code> method.
                        </p>
                        <p>The <code class="codeph">ExtendedSSLSession</code> object can be retrieved by calling the <code class="codeph">SSLSocket.getHandshakeSession()</code> method or the <code class="codeph">SSLEngine.getHandshakeSession()</code> method.
                        </p>
                        <p>The <code class="codeph">X509TrustManager</code> interface is not connection-sensitive. It provides no way to access <code class="codeph">SSLSocket</code> or <code class="codeph">SSLEngine</code> session properties.
                        </p>
                        <p>Besides TLS 1.2 and later support, the <code class="codeph">X509ExtendedTrustManager</code> class also supports algorithm constraints and SSL layer host name verification. For JSSE providers and trust manager implementations, the <code class="codeph">X509ExtendedTrustManager</code> class is highly recommended over the legacy <code class="codeph">X509TrustManager</code> interface.
                        </p>
                     </div>
                     <div class="sect5"><a id="GUID-A6B7B05A-3696-4F86-A05C-9500EEC91C2D" name="GUID-A6B7B05A-3696-4F86-A05C-9500EEC91C2D"></a><h6 id="JSSEC-GUID-A6B7B05A-3696-4F86-A05C-9500EEC91C2D" class="sect6">Creating an X509ExtendedTrustManager</h6>
                        <div>
                           <p>You can either create an <code class="codeph">X509ExtendedTrustManager</code> subclass yourself (which is outlined in the following section) or obtain one from a provider-based <code class="codeph">TrustManagerFactory</code> (such as that supplied by the SunJSSE provider). In Java SE 7, the PKIX or SunX509 <code class="codeph">TrustManagerFactory</code> returns an <code class="codeph">X509ExtendedTrustManager</code> instance.
                           </p>
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-AC443CF8-4CBD-4B77-8733-46D8DA2E3248" name="GUID-AC443CF8-4CBD-4B77-8733-46D8DA2E3248"></a><h6 id="JSSEC-GUID-AC443CF8-4CBD-4B77-8733-46D8DA2E3248" class="sect6">Creating Your Own X509ExtendedTrustManager</h6>
                        <div>
                           <p>This section outlines how to create a subclass of <code class="codeph">X509ExtendedTrustManager</code> in nearly the same way as described for <code class="codeph">X509TrustManager</code>.
                           </p>
                           <div class="section">
                              <p><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-AC443CF8-4CBD-4B77-8733-46D8DA2E3248__IMPORTJAVA.IO.IMPORTJAVA.NET.IMPORT-635DA3F9">Example 8-13</a> illustrates how to create a class that uses the PKIX <code class="codeph">TrustManagerFactory</code> to locate a default <code class="codeph">X509ExtendedTrustManager</code> that will be used to make decisions about trust.
                              </p>
                           </div>
                           <!-- class="section" -->
                           <div class="example" id="GUID-AC443CF8-4CBD-4B77-8733-46D8DA2E3248__IMPORTJAVA.IO.IMPORTJAVA.NET.IMPORT-635DA3F9">
                              <p class="titleinexample">Example 8-13 Sample Code for Creating a PKIX TrustManagerFactory</p>
                              <p>The following code sample illustrates how to create a class that uses the PKIX <code class="codeph">TrustManagerFactory</code> to locate a default <code class="codeph">X509ExtendedTrustManager</code> that will be used to make decisions about trust. If the default trust manager fails for any reason, then the subclass can add other behavior. In the sample, these locations are indicated by comments in the <code class="codeph">catch</code> clauses.
                              </p><pre class="codeblock"><code>import java.io.*;
import java.net.*;
import java.security.*;
import java.security.cert.*;
import javax.net.ssl.*;
    
public class MyX509ExtendedTrustManager extends X509ExtendedTrustManager {

  /*
   * The default PKIX X509ExtendedTrustManager.  Decisions are
   * delegated to it, and a fall back to the logic in this class is
   * performed if the default X509ExtendedTrustManager does not
   * trust it.
   */
  
  X509ExtendedTrustManager pkixTrustManager;
    
  MyX509ExtendedTrustManager() throws Exception {
    // create a "default" JSSE X509ExtendedTrustManager.
    
    KeyStore ks = KeyStore.getInstance("JKS");
    ks.load(new FileInputStream("trustedCerts"), "passphrase".toCharArray());
    
    TrustManagerFactory tmf = TrustManagerFactory.getInstance("PKIX");
    tmf.init(ks);
    
    TrustManager tms [] = tmf.getTrustManagers();
    
    /*
     * Iterate over the returned trust managers, looking
     * for an instance of X509ExtendedTrustManager. If found,
     * use that as the default trust manager.
     */
    for (int i = 0; i &lt; tms.length; i++) {
      if (tms[i] instanceof X509ExtendedTrustManager) {
        pkixTrustManager = (X509ExtendedTrustManager) tms[i];
        return;
      }
    }
    
    /*
     * Find some other way to initialize, or else we have to fail the
     * constructor.
     */
    throw new Exception("Couldn't initialize");
  }
    
  /*
   * Delegate to the default trust manager.
   */
  public void checkClientTrusted(X509Certificate[] chain, String authType)
    throws CertificateException {
    try {
      pkixTrustManager.checkClientTrusted(chain, authType);
    } catch (CertificateException excep) {
      // do any special handling here, or rethrow exception.
    }
  }
    
  /*
   * Delegate to the default trust manager.
   */
  public void checkServerTrusted(X509Certificate[] chain, String authType)
    throws CertificateException {
    try {
      pkixTrustManager.checkServerTrusted(chain, authType);
    } catch (CertificateException excep) {
      /*
       * Possibly pop up a dialog box asking whether to trust the
       * cert chain.
       */
    }
  }
    
  /*
   * Connection-sensitive verification.
   */
  public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket)
    throws CertificateException {
    try {
      pkixTrustManager.checkClientTrusted(chain, authType, socket);
    } catch (CertificateException excep) {
      // do any special handling here, or rethrow exception.
    }
  }
    
  public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine)
    throws CertificateException {
    try {
      pkixTrustManager.checkClientTrusted(chain, authType, engine);
    } catch (CertificateException excep) {
      // do any special handling here, or rethrow exception.
    }
  }
    
  public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket)
    throws CertificateException {
    try {
      pkixTrustManager.checkServerTrusted(chain, authType, socket);
    } catch (CertificateException excep) {
      // do any special handling here, or rethrow exception.
    }
  }
    
  public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine)
    throws CertificateException {
    try {
      pkixTrustManager.checkServerTrusted(chain, authType, engine);
    } catch (CertificateException excep) {
      // do any special handling here, or rethrow exception.
    }
  }
         
  /*
   * Merely pass this through.
   */
  public X509Certificate[] getAcceptedIssuers() {
    return pkixTrustManager.getAcceptedIssuers();
  }
}
</code></pre></div>
                           <!-- class="example" -->
                        </div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-997AB098-DDD7-40E2-9FD0-5AA3C83E1702" name="GUID-997AB098-DDD7-40E2-9FD0-5AA3C83E1702"></a><h5 id="JSSEC-GUID-997AB098-DDD7-40E2-9FD0-5AA3C83E1702" class="sect5">KeyManager Interface</h5>
                     <div>
                        <p></p>
                        <p>The primary responsibility of the <code class="codeph">KeyManager</code> is to select the authentication credentials that will eventually be sent to the remote host. To authenticate yourself (a local secure socket peer) to a remote peer, you must initialize an <code class="codeph">SSLContext</code> object with one or more <code class="codeph">KeyManager</code> objects. You must pass one <code class="codeph">KeyManager</code> for each different authentication mechanism that will be supported. If null is passed into the <code class="codeph">SSLContext</code> initialization, then an empty <code class="codeph">KeyManager</code> will be created. If the internal default context is used (for example, an <code class="codeph">SSLContext</code> created by <code class="codeph">SSLSocketFactory.getDefault()</code> or <code class="codeph">SSLServerSocketFactory.getDefault()</code>), then a default <code class="codeph">KeyManager</code> is created. See <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150">Customizing the Default Keystores and Truststores, Store Types, and Store Passwords</a>. Typically, a single key manager supports authentication based on X.509 public key certificates. Some secure socket implementations may also support authentication based on shared secret keys, Kerberos, or other mechanisms.
                        </p>
                        <p><code class="codeph">KeyManager</code> objects are created either by a <code class="codeph">KeyManagerFactory</code>, or by providing a concrete implementation of the interface.
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-616A7E77-587C-44E0-9F69-92BEDF631D5F" name="GUID-616A7E77-587C-44E0-9F69-92BEDF631D5F"></a><h5 id="JSSEC-GUID-616A7E77-587C-44E0-9F69-92BEDF631D5F" class="sect5">KeyManagerFactory Class</h5>
                     <div>
                        <p>The <code class="codeph">javax.net.ssl.KeyManagerFactory</code> class is an engine class for a provider-based service that acts as a factory for one or more types of <code class="codeph">KeyManager</code> objects. The SunJSSE provider implements a factory that can return a basic X.509 key manager. Because it is provider-based, additional factories can be implemented and configured to provide additional or alternative key managers.
                        </p>
                     </div>
                     <div class="sect5"><a id="GUID-65A7A023-AE02-4A95-8210-386AE6F18EB5" name="GUID-65A7A023-AE02-4A95-8210-386AE6F18EB5"></a><h6 id="JSSEC-GUID-65A7A023-AE02-4A95-8210-386AE6F18EB5" class="sect6">Creating a KeyManagerFactory</h6>
                        <div>
                           <p>You create an instance of this class in a similar manner to <code class="codeph">SSLContext</code>, except for passing an algorithm name string instead of a protocol name to the <code class="codeph">getInstance()</code> method:
                           </p>
                           <div class="section"><pre class="codeblock"><code>KeyManagerFactory kmf = getInstance(String algorithm);
KeyManagerFactory kmf = getInstance(String algorithm, String provider);
KeyManagerFactory kmf = getInstance(String algorithm, Provider provider);
</code></pre><p>A sample call as follows:</p><pre class="codeblock"><code>KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509", "SunJSSE");
</code></pre><p>The preceding call creates an instance of the SunJSSE provider's default key manager factory, which provides basic X.509-based authentication keys.</p>
                              <p>A newly created factory should be initialized by calling one of the <code class="codeph">init</code> methods:
                              </p><pre class="codeblock"><code>public void init(KeyStore ks, char[] password);
public void init(ManagerFactoryParameters spec);
</code></pre><p>Call whichever <code class="codeph">init</code> method is appropriate for the <code class="codeph">KeyManagerFactory</code> you are using. If you are not sure, then ask the provider vendor.
                              </p>
                              <p>For many factories, such as the default SunX509 <code class="codeph">KeyManagerFactory</code> from the SunJSSE provider, the <code class="codeph">KeyStore</code> and password are the only information required to initialize the <code class="codeph">KeyManagerFactory</code> and thus the first <code class="codeph">init</code> method is the appropriate one to call. The <code class="codeph">KeyManagerFactory</code> will query the <code class="codeph">KeyStore</code> for information about which private key and matching public key certificates should be used for authenticating to a remote socket peer. The password parameter specifies the password that will be used with the methods for accessing keys from the <code class="codeph">KeyStore</code>. All keys in the <code class="codeph">KeyStore</code> must be protected by the same password.
                              </p>
                              <p>Sometimes initialization parameters other than a <code class="codeph">KeyStore</code> and password are needed by a provider. Users of that provider are expected to pass an implementation of the appropriate <code class="codeph">ManagerFactoryParameters</code> as defined by the provider. The provider can then call the specified methods in the <code class="codeph">ManagerFactoryParameters</code> implementation to obtain the needed information.
                              </p>
                              <p>Some factories can provide access to authentication material without being initialized with a <code class="codeph">KeyStore</code> object or any other parameters. For example, they may access key material as part of a login mechanism such as one based on JAAS, the Java Authentication and Authorization Service.
                              </p>
                              <p>As previously indicated, the SunJSSE provider supports a SunX509 factory that must be initialized with a <code class="codeph">KeyStore</code> parameter.
                              </p>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-9C8442E4-279D-4E60-B4D0-3B1558C99F4F" name="GUID-9C8442E4-279D-4E60-B4D0-3B1558C99F4F"></a><h5 id="JSSEC-GUID-9C8442E4-279D-4E60-B4D0-3B1558C99F4F" class="sect5">X509KeyManager Interface</h5>
                     <p>The <code class="codeph">javax.net.ssl.X509KeyManager</code> interface extends the general <code class="codeph">KeyManager</code> interface. It must be implemented by a key manager for X.509-based authentication. To support X.509 authentication to remote socket peers through JSSE, an instance of this interface must be passed to the <code class="codeph">init()</code> method of an <code class="codeph">SSLContext</code> object.
                     </p>
                     <div class="sect5"><a id="GUID-FEA439FF-8110-4F2D-82AF-54815002805E" name="GUID-FEA439FF-8110-4F2D-82AF-54815002805E"></a><h6 id="JSSEC-GUID-FEA439FF-8110-4F2D-82AF-54815002805E" class="sect6">Creating an X509KeyManager</h6>
                        <div>
                           <p>You can either implement this interface directly yourself or obtain one from a provider-based <code class="codeph">KeyManagerFactory</code> (such as that supplied by the SunJSSE provider). You could also implement your own interface that delegates to a factory-generated key manager. For example, you might do this to filter the resulting keys and query an end-user through a graphical user interface.
                           </p>
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-E0A44B4B-A888-4997-AB5E-5E0580FF87DE" name="GUID-E0A44B4B-A888-4997-AB5E-5E0580FF87DE"></a><h6 id="JSSEC-GUID-E0A44B4B-A888-4997-AB5E-5E0580FF87DE" class="sect6">Creating Your Own X509KeyManager</h6>
                        <div>
                           <p></p>
                           <div class="section">
                              <p>If the default <code class="codeph">X509KeyManager</code> behavior is not suitable for your situation, then you can create your own <code class="codeph">X509KeyManager</code> in a way similar to that shown in <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-E1205974-3249-4E40-83C0-5F89C7375CF4" title="If the supplied X509TrustManager behavior is not suitable for your situation, then you can create your own X509TrustManager by either creating and registering your own TrustManagerFactory or by implementing the X509TrustManager interface directly.">Creating Your Own X509TrustManager</a>.
                              </p>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-5C4AC46A-DE04-4D72-B94A-35C1F1B94A41" name="GUID-5C4AC46A-DE04-4D72-B94A-35C1F1B94A41"></a><h5 id="JSSEC-GUID-5C4AC46A-DE04-4D72-B94A-35C1F1B94A41" class="sect5">X509ExtendedKeyManager Class</h5>
                     <div>
                        <p>The <code class="codeph">X509ExtendedKeyManager</code> abstract class is an implementation of the <code class="codeph">X509KeyManager</code> interface that allows for connection-specific key selection. It adds two methods that select a key alias for client or server based on the key type, allowed issuers, and current <code class="codeph">SSLEngine</code>:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li><code class="codeph">public String chooseEngineClientAlias(String[] keyType, Principal[] issuers, SSLEngine engine)</code></li>
                           <li><code class="codeph">public String chooseEngineServerAlias(String keyType, Principal[] issuers, SSLEngine engine)</code></li>
                        </ul>
                        <p>If a key manager is not an instance of the <code class="codeph">X509ExtendedKeyManager</code> class, then it will not work with the <code class="codeph">SSLEngine</code> class.
                        </p>
                        <p>For JSSE providers and key manager implementations, the <code class="codeph">X509ExtendedKeyManager</code> class is highly recommended over the legacy <code class="codeph">X509KeyManager</code> interface.
                        </p>
                        <p>In TLS 1.2 and later, both client and server can specify which hash and signature algorithms they will accept. To pass the authentication required by the remote side, local key selection decisions must be based on both X509 certificates and the remote accepted hash and signature algorithms. The remote accepted hash and signature algorithms can be retrieved using the <code class="codeph">ExtendedSSLSession.getPeerSupportedSignatureAlgorithms()</code> method.
                        </p>
                        <p>You can create your own <code class="codeph">X509ExtendedKeyManager</code> subclass in a way similar to that shown in <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-E1205974-3249-4E40-83C0-5F89C7375CF4" title="If the supplied X509TrustManager behavior is not suitable for your situation, then you can create your own X509TrustManager by either creating and registering your own TrustManagerFactory or by implementing the X509TrustManager interface directly.">Creating Your Own X509TrustManager</a>.
                        </p>
                        <p>Support for the <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F">Server Name Indication (SNI) Extension</a> on the server side enables the key manager to check the server name and select the appropriate key accordingly. For example, suppose there are three key entries with certificates in the keystore:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li><code class="codeph">cn=www.example.com</code></li>
                           <li><code class="codeph">cn=www.example.org</code></li>
                           <li><code class="codeph">cn=www.example.net</code></li>
                        </ul>
                        <p>If the ClientHello message requests to connect to <code class="codeph">www.example.net</code> in the SNI extension, then the server should be able to select the certificate with subject <code class="codeph">cn=www.example.net</code>.
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-9D7375F9-D688-436D-A214-02653F50ED32" name="GUID-9D7375F9-D688-436D-A214-02653F50ED32"></a><h5 id="JSSEC-GUID-9D7375F9-D688-436D-A214-02653F50ED32" class="sect5">Relationship Between a TrustManager and a KeyManager</h5>
                     <div>
                        <p>Historically, there has been confusion regarding the functionality of a <code class="codeph">TrustManager</code> and a <code class="codeph">KeyManager</code>.
                        </p>
                        <p>A <code class="codeph">TrustManager</code> determines whether the remote authentication credentials (and thus the connection) should be trusted.
                        </p>
                        <p>A <code class="codeph">KeyManager</code> determines which authentication credentials to send to the remote host.
                        </p>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-1B0C19BB-0F27-4757-9CA5-D03037C4E658" name="GUID-1B0C19BB-0F27-4757-9CA5-D03037C4E658"></a><h4 id="JSSEC-GUID-1B0C19BB-0F27-4757-9CA5-D03037C4E658" class="sect4">Secondary Support Classes and Interfaces</h4>
                  <div>
                     <p>These classes are provided as part of the JSSE API to support the creation, use, and management of secure sockets. They are less likely to be used by secure socket applications than are the core and support classes. The secondary support classes and interfaces are part of the <code class="codeph">javax.net.ssl</code> and <code class="codeph">javax.security.cert</code> packages.
                     </p>
                  </div>
                  <div class="sect4"><a id="GUID-BC9AD59B-05B6-4ACA-9CDD-D18ACEA3840D" name="GUID-BC9AD59B-05B6-4ACA-9CDD-D18ACEA3840D"></a><h5 id="JSSEC-GUID-BC9AD59B-05B6-4ACA-9CDD-D18ACEA3840D" class="sect5">SSLParameters Class</h5>
                     <div>
                        <p>The <code class="codeph">SSLParameters</code> class encapsulates the following parameters that affect a SSL/TLS/DTLS connection:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>The list of cipher suites to be accepted in a TLS/DTLS handshake</li>
                           <li>The list of protocols to be allowed</li>
                           <li>The endpoint identification algorithm during TLS/DTLS handshaking</li>
                           <li>The server names and server name matchers (see <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F">Server Name Indication (SNI) Extension</a>)
                           </li>
                           <li>The cipher suite preference to be used in a TLS/DTLS handshake</li>
                           <li>Algorithm during TLS/DTLS handshaking</li>
                           <li>The Server Name Indication (SNI)</li>
                           <li>The maximum network packet size</li>
                           <li>The algorithm constraints and whether TLS/DTLS servers should request or require client authentication</li>
                        </ul>
                        <p>You can retrieve the current <code class="codeph">SSLParameters</code> for an <code class="codeph">SSLSocket</code> or <code class="codeph">SSLEngine</code> by using the following methods:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li><code class="codeph">getSSLParameters()</code> in an <code class="codeph">SSLSocket</code>, <code class="codeph">SSLServerSocket</code>, and <code class="codeph">SSLEngine</code></li>
                           <li><code class="codeph">getDefaultSSLParameters()</code> and <code class="codeph">getSupportedSSLParamters()</code> in an <code class="codeph">SSLContext</code></li>
                        </ul>
                        <p>You can assign <code class="codeph">SSLParameters</code> with the <code class="codeph">setSSLParameters()</code> method in an <code class="codeph">SSLSocket</code>, <code class="codeph">SSLServerSocket</code> and <code class="codeph">SSLEngine</code>.
                        </p>
                        <p>You can explicitly set the server name indication with the <code class="codeph">SSLParameters.setServerNames()</code> method. The server name indication in client mode also affects endpoint identification. In the implementation of <code class="codeph">X509ExtendedTrustManager</code>, it uses the server name indication retrieved by the <code class="codeph">ExtendedSSLSession.getRequestedServerNames()</code> method. See <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-BC9AD59B-05B6-4ACA-9CDD-D18ACEA3840D__SAMPLECODETOSETTHESERVERNAMEINDICAT-6A7C526D">Example 8-14</a>.
                        </p>
                        <div class="example" id="GUID-BC9AD59B-05B6-4ACA-9CDD-D18ACEA3840D__SAMPLECODETOSETTHESERVERNAMEINDICAT-6A7C526D">
                           <p class="titleinexample">Example 8-14 Sample Code to Set Server Name Indication</p>
                           <p>This example uses the host name in the server name indication (<code class="codeph">www.example.com</code>) to make endpoint identification against the peer's identity presented in the end-entity's X.509 certificate.
                           </p><pre class="codeblock"><code>    SSLSocketFactory factory = ...
    SSLSocket sslSocket = factory.createSocket("172.16.10.6", 443);
    // SSLEngine sslEngine = sslContext.createSSLEngine("172.16.10.6", 443);

    SNIHostName serverName = new SNIHostName("www.example.com");
    List&lt;SNIServerName&gt; serverNames = new ArrayList&lt;&gt;(1);
    serverNames.add(serverName);
 
    SSLParameters params = sslSocket.getSSLParameters();
    params.setServerNames(serverNames);
    sslSocket.setSSLParameters(params);
    // sslEngine.setSSLParameters(params);
</code></pre></div>
                        <!-- class="example" -->
                     </div>
                     <div class="sect5"><a id="GUID-EFC2FACC-680C-42CE-A3A9-E9A6673EA813" name="GUID-EFC2FACC-680C-42CE-A3A9-E9A6673EA813"></a><h6 id="JSSEC-GUID-EFC2FACC-680C-42CE-A3A9-E9A6673EA813" class="sect6">Cipher Suite Preference</h6>
                        <div>
                           <p>During TLS handshaking, the client requests to negotiate a cipher suite from a list of cryptographic options that it supports, starting with its first preference. Then, the server selects a single cipher suite from the list of cipher suites requested by the client. Normally, the selection honors the client's preference. However, to mitigate the risks of using weak cipher suites, the server may select cipher suites based on its own preference rather than the client's preference, by invoking the method <code class="codeph">SSLParameters.setUseCipherSuitesOrder(true)</code>.
                           </p>
                        </div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-4E20A067-B139-4754-B4B3-AAF372F76D02" name="GUID-4E20A067-B139-4754-B4B3-AAF372F76D02"></a><h5 id="JSSEC-GUID-4E20A067-B139-4754-B4B3-AAF372F76D02" class="sect5">SSLSessionContext Interface</h5>
                     <div>
                        <p></p>
                        <p>The <code class="codeph">javax.net.ssl.SSLSessionContext</code> interface is a grouping of <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-AB362290-033A-4D3B-AAF3-1BFEB1CD472B" title="The javax.net.ssl.SSLSession interface represents a security context negotiated between the two peers of an SSLSocket or SSLEngine connection. After a session has been arranged, it can be shared by future SSLSocket or SSLEngine objects connected between the same two peers.">SSLSession</a> objects associated with a single entity. For example, it could be associated with a server or client that participates in many sessions concurrently. The methods in this interface enable the enumeration of all sessions in a context and allow lookup of specific sessions via their session IDs.
                        </p>
                        <p>An <code class="codeph">SSLSessionContext</code> may optionally be obtained from an <code class="codeph">SSLSession</code> by calling the SSLSession <code class="codeph">getSessionContext()</code> method. The context may be unavailable in some environments, in which case the <code class="codeph">getSessionContext()</code> method returns null.
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-F2F8AC17-849A-40EE-A385-FD15328999B6" name="GUID-F2F8AC17-849A-40EE-A385-FD15328999B6"></a><h5 id="JSSEC-GUID-F2F8AC17-849A-40EE-A385-FD15328999B6" class="sect5">SSLSessionBindingListener Interface</h5>
                     <div>
                        <p></p>
                        <p>The <code class="codeph">javax.net.ssl.SSLSessionBindingListener</code> interface is implemented by objects that are notified when they are being bound or unbound from an <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-AB362290-033A-4D3B-AAF3-1BFEB1CD472B" title="The javax.net.ssl.SSLSession interface represents a security context negotiated between the two peers of an SSLSocket or SSLEngine connection. After a session has been arranged, it can be shared by future SSLSocket or SSLEngine objects connected between the same two peers.">SSLSession</a>.
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-C32994C1-0F5E-42D0-9CB6-EF4422024730" name="GUID-C32994C1-0F5E-42D0-9CB6-EF4422024730"></a><h5 id="JSSEC-GUID-C32994C1-0F5E-42D0-9CB6-EF4422024730" class="sect5">SSLSessionBindingEvent Class</h5>
                     <div>
                        <p></p>
                        <p>The <code class="codeph">javax.net.ssl.SSLSessionBindingEvent</code> class defines the event communicated to an <span class="apiname">SSLSessionBindingListener</span> (see <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-F2F8AC17-849A-40EE-A385-FD15328999B6">SSLSessionBindingListener Interface</a>) when it is bound or unbound from an <span class="apiname">SSLSession</span> (see <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-AB362290-033A-4D3B-AAF3-1BFEB1CD472B" title="The javax.net.ssl.SSLSession interface represents a security context negotiated between the two peers of an SSLSocket or SSLEngine connection. After a session has been arranged, it can be shared by future SSLSocket or SSLEngine objects connected between the same two peers.">SSLSession and ExtendedSSLSession</a>).
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-DFBAA9D1-C08B-48C9-88FE-F88003A6A6C7" name="GUID-DFBAA9D1-C08B-48C9-88FE-F88003A6A6C7"></a><h5 id="JSSEC-GUID-DFBAA9D1-C08B-48C9-88FE-F88003A6A6C7" class="sect5">HandShakeCompletedListener Interface</h5>
                     <div>
                        <p>The <code class="codeph">javax.net.ssl.HandShakeCompletedListener</code> interface is an interface implemented by any class that is notified of the completion of an SSL protocol handshake on a given <code class="codeph">SSLSocket</code> connection.
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-F242B876-6932-4B17-A755-1D9AFA25E54B" name="GUID-F242B876-6932-4B17-A755-1D9AFA25E54B"></a><h5 id="JSSEC-GUID-F242B876-6932-4B17-A755-1D9AFA25E54B" class="sect5">HandShakeCompletedEvent Class</h5>
                     <div>
                        <p></p>
                        <p>The <code class="codeph">javax.net.ssl.HandShakeCompletedEvent</code> class defines the event communicated to a <span class="apiname">HandShakeCompletedListener</span> (see <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-DFBAA9D1-C08B-48C9-88FE-F88003A6A6C7" title="The javax.net.ssl.HandShakeCompletedListener interface is an interface implemented by any class that is notified of the completion of an SSL protocol handshake on a given SSLSocket connection.">HandShakeCompletedListener Interface</a>) upon completion of an SSL protocol handshake on a given <code class="codeph">SSLSocket</code> connection.
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-9E46E5AA-FE3E-48D7-B616-98A143F74587" name="GUID-9E46E5AA-FE3E-48D7-B616-98A143F74587"></a><h5 id="JSSEC-GUID-9E46E5AA-FE3E-48D7-B616-98A143F74587" class="sect5">HostnameVerifier Interface</h5>
                     <div>
                        <p></p>
                        <p>If the SSL/TLS implementation's standard host name verification logic fails, then the implementation calls the <code class="codeph">verify()</code> method of the class that implements this interface and is assigned to this <code class="codeph">HttpsURLConnection</code> instance. If the callback class can determine that the host name is acceptable given the parameters, it reports that the connection should be allowed. An unacceptable response causes the connection to be terminated. See <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-9E46E5AA-FE3E-48D7-B616-98A143F74587__SAMPLECODEFORHOSTNAMEVERIFIERINTERF-6A7C5993">Example 8-15</a>.
                        </p>
                        <p>See <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/HttpsURLConnection.html" target="_blank"><code class="codeph">HttpsURLConnection</code></a> for more information about how to assign the <code class="codeph">HostnameVerifier</code> to the <code class="codeph">HttpsURLConnection</code>.
                        </p>
                        <div class="example" id="GUID-9E46E5AA-FE3E-48D7-B616-98A143F74587__SAMPLECODEFORHOSTNAMEVERIFIERINTERF-6A7C5993">
                           <p class="titleinexample">Example 8-15 Sample Code for Implementing the HostnameVerifier Interface</p>
                           <p>The following example illustrates a class that implements <code class="codeph">HostnameVerifier</code> interface:
                           </p><pre class="codeblock"><code>    public class MyHostnameVerifier implements HostnameVerifier {
    
        public boolean verify(String hostname, SSLSession session) {
            // pop up an interactive dialog box
            // or insert additional matching logic
            if (good_address) {
                return true;
            } else {
                return false;
            }
        }
    }
    
    //...deleted...
    
    HttpsURLConnection urlc = (HttpsURLConnection)
      (new URL("https://www.example.com/")).openConnection();
    urlc.setHostnameVerifier(new MyHostnameVerifier());
</code></pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-1B4C6B3B-CDB3-433D-8F24-41EF5DE2FA5F" name="GUID-1B4C6B3B-CDB3-433D-8F24-41EF5DE2FA5F"></a><h5 id="JSSEC-GUID-1B4C6B3B-CDB3-433D-8F24-41EF5DE2FA5F" class="sect5">X509Certificate Class</h5>
                     <div>
                        <p>Many secure socket protocols perform authentication using public key certificates, also called X.509 certificates. This is the default authentication mechanism for the TLS protocol.</p>
                        <p>The <code class="codeph">java.security.cert.X509Certificate</code> abstract class provides a standard way to access the attributes of X.509 certificates.
                        </p>
                        <div class="infoboxnote" id="GUID-1B4C6B3B-CDB3-433D-8F24-41EF5DE2FA5F__GUID-C14C49BA-6583-4041-87ED-DC62E7F52B5F">
                           <p class="notep1">Note:</p> The <code class="codeph">javax.security.cert.X509Certificate</code> class is supported only for backward compatibility with previous (1.0.x and 1.1.x) versions of JSSE. New applications should use the <code class="codeph">java.security.cert.X509Certificate</code> class instead.
                        </div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-54BC5FB3-3841-4005-A876-9FA2F49B2D0F" name="GUID-54BC5FB3-3841-4005-A876-9FA2F49B2D0F"></a><h5 id="JSSEC-GUID-54BC5FB3-3841-4005-A876-9FA2F49B2D0F" class="sect5">AlgorithmConstraints Interface</h5>
                     <div>
                        <p>The <code class="codeph">java.security.AlgorithmConstraints</code> interface is used for controlling allowed cryptographic algorithms. <code class="codeph">AlgorithmConstraints</code> defines three <code class="codeph">permits()</code> methods. These methods tell whether an algorithm name or a key is permitted for certain cryptographic functions. Cryptographic functions are represented by a set of <code class="codeph">CryptoPrimitive</code>, which is an enumeration containing fields like <code class="codeph">STREAM_CIPHER</code>, <code class="codeph">MESSAGE_DIGEST</code>, and <code class="codeph">SIGNATURE</code>.
                        </p>
                        <p>Thus, an <code class="codeph">AlgorithmConstraints</code> implementation can answer questions like: Can I use this key with this algorithm for the purpose of a cryptographic operation?
                        </p>
                        <p>An <code class="codeph">AlgorithmConstraints</code> object can be associated with an <code class="codeph">SSLParameters</code> object by using the new <code class="codeph">setAlgorithmConstraints()</code> method. The current <code class="codeph">AlgorithmConstraints</code> object for an <code class="codeph">SSLParameters</code> object is retrieved using the <code class="codeph">getAlgorithmConstraints()</code> method.
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-651B5070-F586-4504-A6CD-8BEB2D928D47" name="GUID-651B5070-F586-4504-A6CD-8BEB2D928D47"></a><h5 id="JSSEC-GUID-651B5070-F586-4504-A6CD-8BEB2D928D47" class="sect5">StandardConstants Class</h5>
                     <div>
                        <p>The <code class="codeph">StandardConstants</code> class is used to represent standard constants definitions in JSSE.
                        </p>
                        <p><code class="codeph">StandardConstants.SNI_HOST_NAME</code> represents a domain name server (DNS) host name in a <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F">Server Name Indication (SNI)</a> extension, which can be used when instantiating an <code class="codeph">SNIServerName</code> or <code class="codeph">SNIMatcher</code> object.
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-ADD484B7-244A-4FBC-AEF0-96873890CD6B" name="GUID-ADD484B7-244A-4FBC-AEF0-96873890CD6B"></a><h5 id="JSSEC-GUID-ADD484B7-244A-4FBC-AEF0-96873890CD6B" class="sect5">SNIServerName Class</h5>
                     <div>
                        <p></p>
                        <p>An instance of the abstract <code class="codeph">SNIServerName</code> class represents a server name in the <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F">Server Name Indication (SNI)</a> extension. It is instantiated using the type and encoded value of the specified server name.
                        </p>
                        <p>You can use the <code class="codeph">getType()</code> and <code class="codeph">getEncoded()</code> methods to return the server name type and a copy of the encoded server name value, respectively. The <code class="codeph">equals()</code> method can be used to check if some other object is "equal" to this server name. The <code class="codeph">hashCode()</code> method returns a hash code value for this server name. To get a string representation of the server name (including the server name type and encoded server name value), use the <code class="codeph">toString()</code> method.
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-073F0493-3DB8-4388-818B-83E92021EF45" name="GUID-073F0493-3DB8-4388-818B-83E92021EF45"></a><h5 id="JSSEC-GUID-073F0493-3DB8-4388-818B-83E92021EF45" class="sect5">SNIMatcher Class</h5>
                     <div>
                        <p></p>
                        <p>An instance of the abstract <code class="codeph">SNIMatcher</code> class performs match operations on an <code class="codeph">SNIServerName</code> object. Servers can use information from the <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F">Server Name Indication (SNI)</a> extension to decide if a specific <code class="codeph">SSLSocket</code> or <code class="codeph">SSLEngine</code> should accept a connection. For example, when multiple "virtual" or "name-based" servers are hosted on a single underlying network address, the server application can use SNI information to determine whether this server is the exact server that the client wants to access. Instances of this class can be used by a server to verify the acceptable server names of a particular type, such as host names.
                        </p>
                        <p>The <code class="codeph">SNIMatcher</code> class is instantiated using the specified server name type on which match operations will be performed. To match a given <code class="codeph">SNIServerName</code>, use the <code class="codeph">matches()</code> method. To return the server name type of the given <code class="codeph">SNIMatcher</code> object, use the <code class="codeph">getType()</code> method.
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-E10158C4-E808-41B7-9958-A119927743D8" name="GUID-E10158C4-E808-41B7-9958-A119927743D8"></a><h5 id="JSSEC-GUID-E10158C4-E808-41B7-9958-A119927743D8" class="sect5">SNIHostName Class</h5>
                     <div>
                        <p></p>
                        <p>An instance of the <code class="codeph">SNIHostName</code> class (which extends the <code class="codeph">SNIServerName</code> class) represents a server name of type "host_name" (see <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-651B5070-F586-4504-A6CD-8BEB2D928D47" title="The StandardConstants class is used to represent standard constants definitions in JSSE.">StandardConstants Class</a>) in the <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F">Server Name Indication (SNI) Extension</a>. To instantiate an <code class="codeph">SNIHostName</code>, specify the fully qualified DNS host name of the server (as understood by the client) as a <code class="codeph">String</code> argument. The argument is illegal in the following cases:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>The argument is empty.</li>
                           <li>The argument ends with a trailing period.</li>
                           <li>The argument is not a valid Internationalized Domain Name (IDN) compliant with the RFC 3490 specification.</li>
                        </ul>
                        <p>You can also instantiate an <code class="codeph">SNIHostName</code> by specifying the encoded host name value as a byte array. This method is typically used to parse the encoded name value in a requested SNI extension. Otherwise, use the <code class="codeph">SNIHostName(String hostname)</code> constructor. The <code class="codeph">encoded</code> argument is illegal in the following cases:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>The argument is empty.</li>
                           <li>The argument ends with a trailing period.</li>
                           <li>The argument is not a valid Internationalized Domain Name (IDN) compliant with the RFC 3490 specification.</li>
                           <li>The argument is not encoded in UTF-8 or US-ASCII.</li>
                        </ul>
                        <div class="p">
                           <div class="infoboxnote" id="GUID-E10158C4-E808-41B7-9958-A119927743D8__GUID-7C99C76D-9832-47F9-8FF8-7FD2123DE7EC">
                              <p class="notep1">Note:</p>The <code class="codeph">encoded</code> byte array passed in as an argument is cloned to protect against subsequent modification.
                           </div> 
                        </div>
                        <p>To return the host name of an <code class="codeph">SNIHostName</code> object in US-ASCII encoding, use the <code class="codeph">getAsciiName()</code> method. To compare a server name to another object, use the <code class="codeph">equals()</code> method (comparison is <span class="italic">not</span> case-sensitive). To return a hash code value of an <code class="codeph">SNIHostName</code>, use the <code class="codeph">hashCode()</code> method. To return a string representation of an <code class="codeph">SNIHostName</code>, including the DNS host name, use the <code class="codeph">toString()</code> method.
                        </p>
                        <p>You can create an <code class="codeph">SNIMatcher</code> object for an <code class="codeph">SNIHostName</code> object by passing a regular expression representing one or more host names to match to the <code class="codeph">createSNIMatcher()</code> method.
                        </p>
                     </div>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9" name="GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9"></a><h3 id="JSSEC-GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9" class="sect3">Customizing JSSE</h3>
               <div>
                  <p>JSSE includes a standard implementation that can be customized by plugging in different implementations or specifying the default keystore, and so on.</p>
                  <div class="section">
                     <p><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9__SECURITYPROPERTIESANDCUSTOMIZEITEMS-DCEC7645" title="List of Security Properties and the customizable items.">Table 8-2</a> and <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9__SYSTEMPROPERTIESANDCUSTOMIZEITEMSIN-DCEEB591" title="List of system properties and customized items.">Table 8-3</a> summarize which aspects can be customized, what the defaults are, and which mechanisms are used to provide customization.
                     </p>
                     <p>Some of the customizations are done by setting system property or Security Property values. Sections following the table explain how to set such property values.</p>
                     <div class="p">
                        <div class="infoboxnote" id="GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9__GUID-6E3ACF45-C569-4DA9-9905-08713A2D064C">
                           <p class="notep1">Note:</p>Many of the properties shown in this table are currently used by the JSSE implementation, but there is no guarantee that they will continue to have the same names and types (system or security) or even that they will exist at all in future releases. All such properties are flagged with an asterisk (*). They are documented here for your convenience for use with the JSSE implementation.
                        </div> 
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9__SECURITYPROPERTIESANDCUSTOMIZEITEMS-DCEC7645" title="List of Security Properties and the customizable items.">Table 8-2</a> shows items that are customized by setting the <code class="codeph">java.security.Security</code> property. See <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-38CC6235-823B-49D7-A566-4BEA1B64C9C6">How to Specify a java.security.Security Property</a></p>
                     <div class="tblformalwide" id="GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9__SECURITYPROPERTIESANDCUSTOMIZEITEMS-DCEC7645">
                        <p class="titleintable">Table 8-2 Security Properties and Customized Items</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="Security Properties and Customized Items" summary="List of Security Properties and the customizable items." width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" id="d112429e4159">Security Property</th>
                                 <th align="left" valign="bottom" id="d112429e4161">Customized Item</th>
                                 <th align="left" valign="bottom" id="d112429e4163">Default Value</th>
                                 <th align="left" valign="bottom" id="d112429e4165">Notes</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4169" headers="d112429e4159 d112429e4165 "><code class="codeph">cert.provider.x509v1</code></td>
                                 <td align="left" valign="top" headers="d112429e4169 d112429e4161 "><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-F196CEDD-DC14-40EA-852A-133DB9BA798B" title="The X509Certificate implementation returned by the X509Certificate.getInstance() method is by default the implementation from the JSSE implementation.">Customizing the X509Certificate Implementation</a></td>
                                 <td align="left" valign="top" headers="d112429e4169 d112429e4163 ">X509Certificate implementation from Oracle</td>
                                 <td align="left" valign="top" id="d112429e4183" headers="d112429e4159 d112429e4165 ">
                                    <p>None</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4187" headers="d112429e4159 d112429e4165 "><code class="codeph">security.provider.<span class="variable" translate="no">n</span></code> 
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4187 d112429e4161 ">Cryptographic service provider; see <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-8BC473B2-CD64-4E8B-8136-80BB286091B1" title="The JDK comes with a JSSE Cryptographic Service Provider, or provider for short, named SunJSSE. Providers are essentially packages that implement one or more engine classes for specific cryptographic algorithms.">Customizing the Provider Implementation</a> and <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-316FB978-7588-442E-B829-B4973DB3B584" title="The SunJSSE provider uses the SunJCE implementation for all its cryptographic needs. Although it is recommended that you leave the provider at its regular position, you can use implementations from other JCA or JCE providers by registering them before the SunJCE provider.">Customizing the Encryption Algorithm Providers</a></td>
                                 <td align="left" valign="top" headers="d112429e4187 d112429e4163 ">The first five providers in order of priority are:
                                    <ol>
                                       <li>SUN</li>
                                       <li>SunRsaSign</li>
                                       <li>SunEC</li>
                                       <li>SunJSSE</li>
                                       <li>SunJCE</li>
                                    </ol>
                                 </td>
                                 <td align="left" valign="top" id="d112429e4225" headers="d112429e4159 d112429e4165 ">Specify the provider in the <code class="codeph">security.provider.<span class="variable" translate="no">n</span>=</code> line in security properties file, where <code class="codeph"><span class="variable" translate="no">n</span></code> is an integer whose value is equal or greater than 1.
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4238" headers="d112429e4159 d112429e4165 ">*<code class="codeph">ssl.SocketFactory.provider</code> 
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4238 d112429e4161 ">Default <code class="codeph">SSLSocketFactory</code> implementation
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4238 d112429e4163 "><code class="codeph">SSLSocketFactory</code> implementation from Oracle
                                 </td>
                                 <td align="left" valign="top" id="d112429e4252" headers="d112429e4159 d112429e4165 ">
                                    <p>None</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4256" headers="d112429e4159 d112429e4165 ">*<code class="codeph">ssl.ServerSocketFactory.provider</code> 
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4256 d112429e4161 ">Default <code class="codeph">SSLServerSocketFactory</code> implementation
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4256 d112429e4163 "><code class="codeph">SSLServerSocketFactory</code> implementation from Oracle
                                 </td>
                                 <td align="left" valign="top" id="d112429e4270" headers="d112429e4159 d112429e4165 ">
                                    <p>None</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4274" headers="d112429e4159 d112429e4165 "><code class="codeph">ssl.KeyManagerFactory.algorithm</code></td>
                                 <td align="left" valign="top" headers="d112429e4274 d112429e4161 ">Default key manager factory algorithm name (see <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-0ACD9274-607C-49BE-AED9-BEE2B4F2BEF2">Customizing the Default Key Managers and Trust Managers</a>)
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4274 d112429e4163 ">SunX509</td>
                                 <td align="left" valign="top" id="d112429e4286" headers="d112429e4159 d112429e4165 ">
                                    <p>None</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4290" headers="d112429e4159 d112429e4165 ">*<code class="codeph">jdk.certpath.disabledAlgorithms</code> 
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4290 d112429e4161 ">Disabled certificate verification cryptographic algorithm (see <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-0A438179-32A7-4900-A81C-29E3073E1E90" title="In some environments, certain algorithms or key lengths may be undesirable when using TLS/DTLS. The Oracle JDK uses the jdk.certpath.disabledAlgorithms and jdk.tls.disabledAlgorithm Security Properties to disable algorithms during TLS/DTLS protocol negotiation, including version negotiation, cipher suites selection, peer authentication, and key exchange mechanisms. Note that these Security Properties are not guaranteed to be used by other JDK implementations. See the <java-home&gt;/conf/security/java.security file for information about the syntax of these Security Properties and their current active values.">Disabled and Restricted Cryptographic Algorithms</a>)
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4290 d112429e4163 ">
                                    <p>MD2, MD5, SHA1 jdkCA &amp; usage TLSServer, RSA keySize &lt; 1024, DSA keySize &lt; 1024, EC keySize &lt; 224<a id="GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9__RESTRICTED_ALGORITHMS_MAY_CHANGE_FOOTNOTE" name="GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9__RESTRICTED_ALGORITHMS_MAY_CHANGE_FOOTNOTE" href="#GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9__RESTRICTED_ALGORITHMS_MAY_CHANGE_FOOTNOTE" onclick='footdisplay(2, "The list of restricted, disabled, and legacy algorithms specified in these Security Properties may change; see the java.security file in your JDK installation for the latest values.")'><sup>Foot&nbsp;2</sup></a></p>
                                 </td>
                                 <td align="left" valign="top" id="d112429e4322" headers="d112429e4159 d112429e4165 ">
                                    <p>None</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4326" headers="d112429e4159 d112429e4165 "><code class="codeph">ssl.TrustManagerFactory.algorithm</code></td>
                                 <td align="left" valign="top" headers="d112429e4326 d112429e4161 ">Default trust manager factory algorithm name (see <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-0ACD9274-607C-49BE-AED9-BEE2B4F2BEF2">Customizing the Default Key Managers and Trust Managers</a>)
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4326 d112429e4163 ">PKIX</td>
                                 <td align="left" valign="top" id="d112429e4338" headers="d112429e4159 d112429e4165 ">
                                    <p>None</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4342" headers="d112429e4159 d112429e4165 "><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-316FB978-7588-442E-B829-B4973DB3B584" title="The SunJSSE provider uses the SunJCE implementation for all its cryptographic needs. Although it is recommended that you leave the provider at its regular position, you can use implementations from other JCA or JCE providers by registering them before the SunJCE provider.">JCE encryption algorithms used by the SunJSSE provider</a></td>
                                 <td align="left" valign="top" headers="d112429e4342 d112429e4161 ">Give alternative JCE algorithm providers a higher preference order than the SunJCE provider</td>
                                 <td align="left" valign="top" headers="d112429e4342 d112429e4163 ">SunJCE implementations</td>
                                 <td align="left" valign="top" id="d112429e4356" headers="d112429e4159 d112429e4165 ">
                                    <p>None</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4360" headers="d112429e4159 d112429e4165 ">
                                    <p></p>*<code class="codeph">jdk.tls.disabledAlgorithms</code> 
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4360 d112429e4161 "><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-0A438179-32A7-4900-A81C-29E3073E1E90" title="In some environments, certain algorithms or key lengths may be undesirable when using TLS/DTLS. The Oracle JDK uses the jdk.certpath.disabledAlgorithms and jdk.tls.disabledAlgorithm Security Properties to disable algorithms during TLS/DTLS protocol negotiation, including version negotiation, cipher suites selection, peer authentication, and key exchange mechanisms. Note that these Security Properties are not guaranteed to be used by other JDK implementations. See the <java-home&gt;/conf/security/java.security file for information about the syntax of these Security Properties and their current active values.">Disabled and Restricted Cryptographic Algorithms</a></td>
                                 <td align="left" valign="top" headers="d112429e4360 d112429e4163 ">
                                    <p>SSLv3, RC4, MD5withRSA, DH keySize &lt; 1024, EC keySize &lt; 224<a id="fnsrc_d112429e4386" name="fnsrc_d112429e4386" href="#fnsrc_d112429e4386" onclick='footdisplay(2, "The list of restricted, disabled, and legacy algorithms specified in these Security Properties may change; see the java.security file in your JDK installation for the latest values.")'><sup>Footref&nbsp;2</sup></a></p>
                                 </td>
                                 <td align="left" valign="top" id="d112429e4388" headers="d112429e4159 d112429e4165 ">Disables specific algorithms (protocols versions, cipher suites, key exchange mechanisms, etc.) that will not be negotiated for TLS/DTLS connections, even if they are enabled explicitly in an application</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4391" headers="d112429e4159 d112429e4165 ">
                                    <p></p>*<code class="codeph">jdk.tls.legacyAlgorithms</code></td>
                                 <td align="left" valign="top" headers="d112429e4391 d112429e4161 "><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-3D5E4A8B-F8F3-49E0-AE55-D12A844FADB1" title="In some environments, a certain algorithm may be undesirable but it cannot be disabled because of its use in legacy applications. Legacy algorithms may still be supported, but applications should not use them as the security strength of legacy algorithms is usually not strong enough. During TLS/DTLS security parameters negotiation, legacy algorithms are not negotiated unless there are no other candidates. The Security Property jdk.tls.legacyAlgorithms specifies which algorithms the Oracle JDK considers as legacy algorithms. <java-home&gt;/conf/security/java.security file for the syntax of this Security Property.">Legacy Cryptographic Algorithms</a></td>
                                 <td align="left" valign="top" headers="d112429e4391 d112429e4163 ">
                                    <p>K_NULL, C_NULL, M_NULL, DH_anon, ECDH_anon, RC4_128, RC4_40, DES_CBC, DES40_CBC, 3DES_EDE_CBC<a id="fnsrc_d112429e4413" name="fnsrc_d112429e4413" href="#fnsrc_d112429e4413" onclick='footdisplay(2, "The list of restricted, disabled, and legacy algorithms specified in these Security Properties may change; see the java.security file in your JDK installation for the latest values.")'><sup>Footref&nbsp;2</sup></a></p>
                                 </td>
                                 <td align="left" valign="top" id="d112429e4415" headers="d112429e4159 d112429e4165 ">Specifies which algorithms are considered legacy algorithms, which are not negotiated during TLS/DTLS security parameters negotiation unless there are no other candidates.</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4418" headers="d112429e4159 d112429e4165 "><code class="codeph">jdk.tls.server.defaultDHEParameters</code></td>
                                 <td align="left" valign="top" headers="d112429e4418 d112429e4161 ">Diffie-Hellman groups</td>
                                 <td align="left" valign="top" headers="d112429e4418 d112429e4163 ">Safe prime Diffie-Hellman groups in OpenJDK TLS/DTLS implementation</td>
                                 <td align="left" valign="top" id="d112429e4425" headers="d112429e4159 d112429e4165 ">Defines default finite field Diffie-Hellman ephemeral (DHE) parameters for (Datagram) Transport Layer Security ((D)TLS) processing</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4429" headers="d112429e4159 d112429e4165 ">*<code class="codeph">jdk.tls.keyLimits</code></td>
                                 <td align="left" valign="top" headers="d112429e4429 d112429e4161 "><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-B970ADD6-1E9F-4C18-A26E-0679B50CC946" title="You can specify a limit on the amount of data an algorithm may encrypt with a specific set of keys with the jdk.tls.keyLimits Security Property. Once this limit is reached, a KeyUpdate post-handshake message is sent, which requests that the current set of keys be updated. This Security Property is only for symmetrical ciphers with TLS 1.3.">Limiting Amount of Data Algorithms May Encrypt with a Set of Keys</a></td>
                                 <td align="left" valign="top" headers="d112429e4429 d112429e4163 ">AES/GCM/NoPadding KeyUpdate 2^37</td>
                                 <td align="left" valign="top" id="d112429e4444" headers="d112429e4159 d112429e4165 ">Limits the amount of data an algorithm may encrypt with a specific set of keys; once this limit is reached, a KeyUpdate post-handshake message is sent, which requests that the current set of keys be updated.</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4447" headers="d112429e4159 d112429e4165 ">*<code class="codeph">ocsp.enable</code></td>
                                 <td align="left" valign="top" headers="d112429e4447 d112429e4161 "><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-E1A3A7C3-309A-4415-903B-B31C96F68C86" title="Use the Online Certificate Status Protocol (OCSP) to determine the X.509 certificate revocation status during the Transport Layer Security (TLS) handshake.">Client-Driven OCSP and OCSP Stapling</a></td>
                                 <td align="left" valign="top" headers="d112429e4447 d112429e4163 ">false</td>
                                 <td align="left" valign="top" id="d112429e4459" headers="d112429e4159 d112429e4165 ">Enables client-driven Online Certificate Status Protocol (OCSP).
                                    <p>You must also enable revocation checking; see <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-4E3834C7-E741-499E-9646-3557670FD88A" title="Client-driven OCSP is enabled by enabling revocation checking and enabling OCSP.">Setting up a Java Client to use Client-Driven OCSP</a>.
                                    </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p class="tablefootnote"><sup class="tablefootnote">Footnote&nbsp;2 </sup>The list of restricted, disabled, and legacy algorithms specified in these Security Properties may change; see the <code>java.security</code> file in your JDK installation for the latest values.
                     </p>
                     <p>* <span>This Security Property is currently used by the JSSE implementation, but it is not guaranteed to be examined and used by other implementations. If it <span class="variable" translate="no">is</span> examined by another implementation, then that implementation should handle it in the same manner as the JSSE implementation does. There is no guarantee the property will continue to exist or be of the same type (system or security) in future releases.</span></p>
                  </div>
                  <!-- class="section" -->
                  <div class="section"><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9__SYSTEMPROPERTIESANDCUSTOMIZEITEMSIN-DCEEB591" title="List of system properties and customized items.">Table 8-3</a> shows items that are customized by setting <code class="codeph">java.lang.System</code> property. See <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-460C3E5A-A373-4742-9E84-EB42A7A3C363">How to Specify a java.lang.System Property</a>.
                     <div class="tblformalwide" id="GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9__SYSTEMPROPERTIESANDCUSTOMIZEITEMSIN-DCEEB591">
                        <p class="titleintable">Table 8-3 System Properties and Customized Items</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="System Properties and Customized Items" summary="List of system properties and customized items." width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" id="d112429e4502">System Property</th>
                                 <th align="left" valign="bottom" id="d112429e4504">Customized Item</th>
                                 <th align="left" valign="bottom" id="d112429e4506">Default</th>
                                 <th align="left" valign="bottom" id="d112429e4508">Notes</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4512" headers="d112429e4502 "><code class="codeph">java.protocol.handler.pkgs</code></td>
                                 <td align="left" valign="top" headers="d112429e4512 d112429e4504 "><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-7EBD6A94-9ADE-4321-8915-17B3763F8E77" title="You can communicate securely with an SSL-enabled web server by using the HTTPS URL scheme for the java.net.URL class. The JDK provides a default HTTPS URL implementation.">Specifying an Alternative HTTPS Protocol Implementation</a></td>
                                 <td align="left" valign="top" headers="d112429e4512 d112429e4506 ">Implementation from Oracle</td>
                                 <td align="left" valign="top" headers="d112429e4512 d112429e4508 ">
                                    <p>None</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4530" headers="d112429e4502 ">*<code class="codeph">javax.net.ssl.keyStore</code>  
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4530 d112429e4504 ">Default keystore; see <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150">Customizing the Default Keystores and Truststores, Store Types, and Store Passwords</a></td>
                                 <td align="left" valign="top" headers="d112429e4530 d112429e4506 ">
                                    <p>None</p>
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4530 d112429e4508 ">The value <code class="codeph">NONE</code> may be specified. This setting is appropriate if the keystore is not file-based (for example, it resides in a hardware token)
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4550" headers="d112429e4502 ">*<code class="codeph">javax.net.ssl.keyStorePassword</code></td>
                                 <td align="left" valign="top" headers="d112429e4550 d112429e4504 ">Default keystore password; see <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150">Customizing the Default Keystores and Truststores, Store Types, and Store Passwords</a></td>
                                 <td align="left" valign="top" headers="d112429e4550 d112429e4506 ">
                                    <p>None</p>
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4550 d112429e4508 ">
                                    <p>It is inadvisable to specify the password in a way that exposes it to discovery by other users.</p>
                                    <p>For example, specifying the password on the command line. To keep the password secure, have the application prompt for the password, or specify the password in a properly protected option file</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4569" headers="d112429e4502 ">*<code class="codeph">javax.net.ssl.keyStoreProvider</code> 
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4569 d112429e4504 ">Default keystore provider; see <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150">Customizing the Default Keystores and Truststores, Store Types, and Store Passwords</a></td>
                                 <td align="left" valign="top" headers="d112429e4569 d112429e4506 ">
                                    <p>None</p>
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4569 d112429e4508 ">
                                    <p>None</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4587" headers="d112429e4502 ">*<code class="codeph">javax.net.ssl.keyStoreType</code> 
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4587 d112429e4504 ">Default keystore type; see <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150">Customizing the Default Keystores and Truststores, Store Types, and Store Passwords</a></td>
                                 <td align="left" valign="top" headers="d112429e4587 d112429e4506 "><code class="codeph">KeyStore.getDefaultType()</code></td>
                                 <td align="left" valign="top" headers="d112429e4587 d112429e4508 ">
                                    <p>None</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4605" headers="d112429e4502 ">*<code class="codeph">javax.net.ssl.trustStore</code> 
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4605 d112429e4504 ">Default truststore; see <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150">Customizing the Default Keystores and Truststores, Store Types, and Store Passwords</a></td>
                                 <td align="left" valign="top" headers="d112429e4605 d112429e4506 "><code class="codeph">jssecacerts</code>, if it exists. 
                                    <p>Otherwise, <code class="codeph">cacerts</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4605 d112429e4508 ">
                                    <p>None</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4628" headers="d112429e4502 ">*<code class="codeph">javax.net.ssl.trustStorePassword</code> 
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4628 d112429e4504 ">Default truststore password; see <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150">Customizing the Default Keystores and Truststores, Store Types, and Store Passwords</a></td>
                                 <td align="left" valign="top" headers="d112429e4628 d112429e4506 ">
                                    <p>None</p>
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4628 d112429e4508 ">
                                    <p>It is inadvisable to specify the password in a way that exposes it to discovery by other users. </p>
                                    <p>For example, specifying the password on the command line. To keep the password secure, have the application prompt for the password, or specify the password in a properly protected option file</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4648" headers="d112429e4502 ">*<code class="codeph">javax.net.ssl.trustStoreProvider</code> 
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4648 d112429e4504 ">Default truststore provider; see <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150">Customizing the Default Keystores and Truststores, Store Types, and Store Passwords</a></td>
                                 <td align="left" valign="top" headers="d112429e4648 d112429e4506 ">
                                    <p>None</p>
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4648 d112429e4508 ">
                                    <p>None</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4666" headers="d112429e4502 ">*<code class="codeph">javax.net.ssl.trustStoreType</code> 
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4666 d112429e4504 ">Default truststore type; see <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150">Customizing the Default Keystores and Truststores, Store Types, and Store Passwords</a></td>
                                 <td align="left" valign="top" headers="d112429e4666 d112429e4506 "><code class="codeph">KeyStore.getDefaultType()</code></td>
                                 <td align="left" valign="top" headers="d112429e4666 d112429e4508 ">The value <code class="codeph">NONE</code> may be specified. This setting is appropriate if the truststore is not file-based (for example, it resides in a hardware token)
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4686" headers="d112429e4502 ">*<code class="codeph">https.proxyHost</code></td>
                                 <td align="left" valign="top" headers="d112429e4686 d112429e4504 ">Default proxy host</td>
                                 <td align="left" valign="top" headers="d112429e4686 d112429e4506 ">
                                    <p>None</p>
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4686 d112429e4508 ">
                                    <p>None</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4699" headers="d112429e4502 ">*<code class="codeph">https.proxyPort</code> 
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4699 d112429e4504 ">Default proxy port</td>
                                 <td align="left" valign="top" headers="d112429e4699 d112429e4506 ">80</td>
                                 <td align="left" valign="top" headers="d112429e4699 d112429e4508 ">
                                    <p>None</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4713" headers="d112429e4502 ">*<code class="codeph">jsse.enableSNIExtension</code> 
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4713 d112429e4504 ">Server Name Indication option</td>
                                 <td align="left" valign="top" headers="d112429e4713 d112429e4506 "><code class="codeph">true</code></td>
                                 <td align="left" valign="top" headers="d112429e4713 d112429e4508 ">Server Name Indication (SNI) is a TLS extension, defined in <a href="http://www.ietf.org/rfc/rfc6066.txt" target="_blank">RFC 6066</a>. It enables TLS connections to virtual servers, in which multiple servers for different network names are hosted at a single underlying network address. Some very old TLS vendors may not be able handle TLS extensions. In this case, set this property to <code class="codeph">false</code> to disable the SNI extension
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4733" headers="d112429e4502 ">*<code class="codeph">https.cipherSuites</code></td>
                                 <td align="left" valign="top" headers="d112429e4733 d112429e4504 ">Default cipher suites for HTTPS connections</td>
                                 <td align="left" valign="top" headers="d112429e4733 d112429e4506 ">Determined by the socket factory.</td>
                                 <td align="left" valign="top" headers="d112429e4733 d112429e4508 ">
                                    <p>This contains a comma-separated list of cipher suite names specifying which cipher suites to enable for use on this <code class="codeph">HttpsURLConnection</code>. See the <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLSocket.html#setEnabledProtocols-java.lang.String:A-" target="_blank"><code class="codeph">SSLSocket.setEnabledCipherSuites(String[])</code></a> method. Note that this method sets the preference order of the ClientHello cipher suites directly from the <span class="apiname">String</span> array passed to it.
                                    </p> 
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4757" headers="d112429e4502 ">*<code class="codeph" id="GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9__HTTPS.PROTOCOLS_PROPERTY">https.protocols</code></td>
                                 <td align="left" valign="top" headers="d112429e4757 d112429e4504 ">Default handshaking protocols for HTTPS connections</td>
                                 <td align="left" valign="top" headers="d112429e4757 d112429e4506 ">Determined by the socket factory.</td>
                                 <td align="left" valign="top" headers="d112429e4757 d112429e4508 ">
                                    <p>This contains a comma-separated list of protocol suite names specifying which protocol suites to enable on this <code class="codeph">HttpsURLConnection</code>. See <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLSocket.html#setEnabledCipherSuites-java.lang.String:A-" target="_blank"><code class="codeph">SSLSocket.setEnabledProtocols(String[])</code></a></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4776" headers="d112429e4502 ">* Customize via <code class="codeph">port</code> field in the HTTPS URL.
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4776 d112429e4504 ">Default HTTPS port</td>
                                 <td align="left" valign="top" headers="d112429e4776 d112429e4506 ">443</td>
                                 <td align="left" valign="top" headers="d112429e4776 d112429e4508 ">
                                    <p>None</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4789" headers="d112429e4502 ">*<code class="codeph">jsse.SSLEngine.acceptLargeFragments</code></td>
                                 <td align="left" valign="top" headers="d112429e4789 d112429e4504 ">Default sizing buffers for large TLS packets</td>
                                 <td align="left" valign="top" headers="d112429e4789 d112429e4506 ">
                                    <p>None</p>
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4789 d112429e4508 ">
                                    <p>Setting this system property to <code class="codeph">true</code>, <code class="codeph">SSLSession</code> will size buffers to handle <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-AB362290-033A-4D3B-AAF3-1BFEB1CD472B__GUID-17258111-C234-4640-B886-D85221CCE842">large data packets</a> by default. This may cause applications to allocate unnecessarily large <code class="codeph">SSLEngine</code> buffers. Instead, applications should <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744" title="The status of the SSLEngine is represented by SSLEngineResult.Status.">dynamically check for buffer overflow conditions</a> and resize buffers as appropriate
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4825" headers="d112429e4502 "><code class="codeph">jdk.tls.client.cipherSuites</code></td>
                                 <td align="left" valign="top" headers="d112429e4825 d112429e4504 ">Client-side default enabled cipher suites; see <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-D61663E8-2405-4B2D-A1F1-B8C7EA2688DB" title="You can specify the default enabled cipher suites in your application or with the system properties jdk.tls.client.cipherSuites and jdk.tls.server.cipherSuites.">Specifying Default Enabled Cipher Suites</a></td>
                                 <td align="left" valign="top" headers="d112429e4825 d112429e4506 "><a href="oracle-providers.html#GUID-7093246A-31A3-4304-AC5F-5FB6400405E2__CIPHERSUITESSUPPORTEDBYSUNJSSE-29E460FE" title="List of cipher suites supported by SunJSSE, whether they are enabled or disabled by default, and the release in which they were introduced">Table 4-11</a>, Cipher Suites Supported by SunJSSE
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4825 d112429e4508 "><span class="bold">Caution</span>: These system properties can be used to configure weak cipher suites, or the configured cipher suites may be weak in the future. It is not recommended that you use these system properties without understanding the risks.
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4852" headers="d112429e4502 "><code class="codeph" id="GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9__JDK.TLS.CLIENT.PROTOCOLS_PROPERTY">jdk.tls.client.protocols</code> 
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4852 d112429e4504 ">Default handshaking protocols for TLS/DTLS clients. See <a href="oracle-providers.html#GUID-7093246A-31A3-4304-AC5F-5FB6400405E2">The SunJSSE Provider</a></td>
                                 <td align="left" valign="top" headers="d112429e4852 d112429e4506 ">
                                    <p>None</p>
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4852 d112429e4508 ">
                                    <p>To enable specific <code class="codeph">SunJSSE</code> protocols on the client, specify them in a comma-separated list within quotation marks; all other supported protocols are not enabled on the client
                                    </p>
                                    <div class="p">For example, 
                                       <ul style="list-style-type: disc;">
                                          <li>
                                             <p>If <code class="codeph">jdk.tls.client.protocols=</code><code class="codeph">"TLSv1,TLSv1.1"</code>, then the default protocol settings on the client for TLSv1 and TLSv1.1 are enabled, while SSLv3, TLSv1.2, TLSv1.3, and SSLv2Hello are not enabled
                                             </p>
                                          </li>
                                          <li>
                                             <p>If <code class="codeph">jdk.tls.client.protocols="DTLSv1.2"</code> , then the protocol setting on the client for DTLS1.2 is enabled, while DTLS1.0 is not enabled
                                             </p>
                                          </li>
                                       </ul>
                                    </div>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4887" headers="d112429e4502 "><code class="codeph">jdk.tls.server.cipherSuites</code></td>
                                 <td align="left" valign="top" headers="d112429e4887 d112429e4504 ">Server-side default enabled cipher suites. See <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-D61663E8-2405-4B2D-A1F1-B8C7EA2688DB" title="You can specify the default enabled cipher suites in your application or with the system properties jdk.tls.client.cipherSuites and jdk.tls.server.cipherSuites.">Specifying Default Enabled Cipher Suites</a></td>
                                 <td align="left" valign="top" headers="d112429e4887 d112429e4506 "><a href="oracle-providers.html#GUID-7093246A-31A3-4304-AC5F-5FB6400405E2__CIPHERSUITESSUPPORTEDBYSUNJSSE-29E460FE" title="List of cipher suites supported by SunJSSE, whether they are enabled or disabled by default, and the release in which they were introduced">Table 4-11</a>, Cipher Suites Supported by SunJSSE
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4887 d112429e4508 "><span class="bold">Caution</span>: These system properties can be used to configure weak cipher suites, or the configured cipher suites may be weak in the future. It is not recommended that you use these system properties without understanding the risks.
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4914" headers="d112429e4502 "><code class="codeph">jdk.tls.server.protocols</code></td>
                                 <td align="left" valign="top" headers="d112429e4914 d112429e4504 ">Default handshaking protocols for TLS/DTLS servers. See <a href="oracle-providers.html#GUID-7093246A-31A3-4304-AC5F-5FB6400405E2">The SunJSSE Provider</a></td>
                                 <td align="left" valign="top" headers="d112429e4914 d112429e4506 ">None</td>
                                 <td align="left" valign="top" headers="d112429e4914 d112429e4508 ">
                                    <p>To configure the default enabled protocol suite in the server side of a SunJSSE provider, specify the protocols in a comma-separated list within quotation marks.</p>
                                    <p>The protocols in this list are standard SSL protocol names as described in <a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html" target="_blank">Java Security Standard Algorithm Names</a>.
                                    </p>
                                    <p>Note that this System Property impacts only the default protocol suite (SSLContext of the algorithms SSL, TLS and DTLS). If an application uses a version-specific SSLContext (SSLv3, TLSv1, TLSv1.1, TLSv1.2, TLSv1.3, DTLSv1.0, or DTLSv1.2), or sets the enabled protocol version explicitly, this System Property has no impact.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4935" headers="d112429e4502 "><code class="codeph">jdk.tls.ephemeralDHKeySize</code></td>
                                 <td align="left" valign="top" headers="d112429e4935 d112429e4504 "><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-D9B216E8-3EFC-4882-B76E-17A87D8F2F9D" title="In TLS/DTLS connections, ephemeral Diffie-Hellman (DH) keys may be used internally during the handshaking. The SunJSSE provider provides a flexible approach to customize the strength of the ephemeral DH key size during TLS/DTLS handshaking.">Customizing Size of Ephemeral Diffie-Hellman Keys</a></td>
                                 <td align="left" valign="top" headers="d112429e4935 d112429e4506 ">1024 bits</td>
                                 <td align="left" valign="top" headers="d112429e4935 d112429e4508 ">
                                    <p>None</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4950" headers="d112429e4502 "><code class="codeph">jdk.tls.namedGroups</code></td>
                                 <td align="left" valign="top" headers="d112429e4950 d112429e4504 ">
                                    <p>Customizing the supported named groups for TLS/DTLS key exchange</p>
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4950 d112429e4506 ">
                                    <p>If this System Property is not defined or the value is empty, then the implementation default groups and preferences will be used.</p>
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4950 d112429e4508 ">
                                    <p>This contains a comma-separated list within quotation marks of enabled named groups in preference order. For example:</p>
                                    <p><code class="codeph">jdk.tls.namedGroups="secp521r1,secp256r1, ffdhe2048"</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4967" headers="d112429e4502 "><code class="codeph">jsse.enableMFLNExtension</code></td>
                                 <td align="left" valign="top" headers="d112429e4967 d112429e4504 "><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-41D5F11E-81BD-4C03-A315-48016D9B9B36" title="In order to negotiate smaller maximum fragment lengths, clients have an option to include an extension of type max_fragment_length in the ClientHello message. A system property jsse.enableMFLNExtension, can be used to enable or disable the MFLN extension for TLS/DTLS.">Customizing Maximum Fragment Length Negotiation (MFLN) Extension</a></td>
                                 <td align="left" valign="top" headers="d112429e4967 d112429e4506 ">false</td>
                                 <td align="left" valign="top" headers="d112429e4967 d112429e4508 ">
                                    <p>None</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e4988" headers="d112429e4502 "><code class="codeph">jsse.enableFFDHEExtension</code></td>
                                 <td align="left" valign="top" headers="d112429e4988 d112429e4504 ">
                                    <p>Enables or disables Finite Field Diffie-Hellman Ephemeral (FFDHE) parameters for TLS/DTLS key exchange</p>
                                 </td>
                                 <td align="left" valign="top" headers="d112429e4988 d112429e4506 ">true</td>
                                 <td align="left" valign="top" headers="d112429e4988 d112429e4508 ">
                                    <p>FFDHE is a TLS/DTLS extension defined in <a href="https://tools.ietf.org/html/rfc7919" target="_blank">RFC 7919</a>. It enables TLS/DTLS connections to use known finite field Diffie-Hellman groups. Some very old TLS vendors may not be able handle TLS extensions. In this case, set this property to false to disable the FFDHE extension.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d112429e5004" headers="d112429e4502 ">*<code class="codeph">com.sun.net.ssl.checkRevocation</code></td>
                                 <td align="left" valign="top" headers="d112429e5004 d112429e4504 ">Revocation checking</td>
                                 <td align="left" valign="top" headers="d112429e5004 d112429e4506 ">false</td>
                                 <td align="left" valign="top" headers="d112429e5004 d112429e4508 ">You must enable revocation checking to enable client-driven OCSP; see <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-E1A3A7C3-309A-4415-903B-B31C96F68C86" title="Use the Online Certificate Status Protocol (OCSP) to determine the X.509 certificate revocation status during the Transport Layer Security (TLS) handshake.">Client-Driven OCSP and OCSP Stapling</a>.
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>* <span>This system property is currently used by the JSSE implementation, but it is not guaranteed to be examined and used by other implementations. If it <span class="variable" translate="no">is</span> examined by another implementation, then that implementation should handle it in the same manner as the JSSE implementation does. There is no guarantee the property will continue to exist or be of the same type (system or security) in future releases.</span></p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div class="sect3"><a id="GUID-460C3E5A-A373-4742-9E84-EB42A7A3C363" name="GUID-460C3E5A-A373-4742-9E84-EB42A7A3C363"></a><h4 id="JSSEC-GUID-460C3E5A-A373-4742-9E84-EB42A7A3C363" class="sect4">How to Specify a java.lang.System Property</h4>
                  <div>
                     <p></p>
                     <div class="section">You can customize some aspects of JSSE by setting system properties. There are several ways to set these properties:</div>
                     <!-- class="section" -->
                     <ul>
                        <li class="stepexpand"><span>To set a system property statically, use the <code class="codeph">-D</code> option of the <code class="codeph">java</code> command. For example, to run an application named MyApp and set the <code class="codeph">javax.net.ssl.trustStore</code> system property to specify a truststore named MyCacertsFile. See <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150">truststore</a>. Enter the following:</span><div><pre class="codeblock"><code>
        java -Djavax.net.ssl.trustStore=MyCacertsFile MyApp
                
</code></pre></div>
                        </li>
                        <li class="stepexpand"><span>To set a system property dynamically, call the <code class="codeph">java.lang.System.setProperty()</code> method in your code:</span><div><pre class="codeblock"><code>
        System.setProperty("<span class="variable" translate="no">propertyName</span>", "<span class="variable" translate="no">propertyValue</span>");
                
</code></pre></div>
                           <div>For example, a <code class="codeph">setProperty()</code> call corresponding to the previous example for setting the <code class="codeph">javax.net.ssl.trustStore</code> system property to specify a truststore named "<code class="codeph">MyCacertsFile</code>" would be:<pre class="codeblock"><code>
        System.setProperty("javax.net.ssl.trustStore", "MyCacertsFile");
                
</code></pre></div>
                        </li>
                     </ul>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-38CC6235-823B-49D7-A566-4BEA1B64C9C6" name="GUID-38CC6235-823B-49D7-A566-4BEA1B64C9C6"></a><h4 id="JSSEC-GUID-38CC6235-823B-49D7-A566-4BEA1B64C9C6" class="sect4">How to Specify a java.security.Security Property</h4>
                  <div>
                     <p></p>
                     <div class="section">You can customize some aspects of JSSE by setting Security Properties. You can set a Security Property either statically or dynamically:</div>
                     <!-- class="section" -->
                     <ul>
                        <li class="stepexpand"><span>To set a Security Property statically, add a line to the security properties file. The security properties file is located at <code><span class="variable" translate="no">java-home</span>/conf/security/java.security</code></span><div>
                              <dl>
                                 <dt class="dlterm"><a name="GUID-38CC6235-823B-49D7-A566-4BEA1B64C9C6__GUID-548CD27A-7959-4905-8A44-EA4F9CE36641">
                                       <!-- --></a><span class="variable" translate="no">java-home</span></dt>
                                 <dd>See <a href="terms-and-definitions.html" title="The following are commonly used cryptography terms and their definitions.">Terms and Definitions</a></dd>
                              </dl>
                              <p>To specify a Security Property value in the security properties file, you add a line of the following form:</p> <pre class="codeblock"><code><span class="variable" translate="no">propertyName</span>=<span class="variable" translate="no">propertyValue</span>
</code></pre> </div>
                           <div>
                              <p>For example, suppose that you want to specify a different key manager factory algorithm name than the default SunX509. You do this by specifying the algorithm name as the value of a Security Property named <code class="codeph">ssl.KeyManagerFactory.algorithm</code>. For example, to set the value to MyX509, add the following line to the security properties file:
                              </p> <pre class="codeblock"><code>ssl.KeyManagerFactory.algorithm=MyX509
</code></pre></div>
                        </li>
                        <li class="stepexpand"><span>To set a Security Property dynamically, call the <code class="codeph">java.security.Security.setProperty</code> method in your code:</span><div><pre class="codeblock"><code>Security.setProperty("<span class="variable" translate="no">propertyName</span>," "<span class="variable" translate="no">propertyValue</span>");
</code></pre></div>
                           <div>For example, a call to the <code class="codeph">setProperty()</code> method corresponding to the previous example for specifying the key manager factory algorithm name would be:<pre class="codeblock"><code>Security.setProperty("ssl.KeyManagerFactory.algorithm", "MyX509");
</code></pre></div>
                        </li>
                     </ul>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-F196CEDD-DC14-40EA-852A-133DB9BA798B" name="GUID-F196CEDD-DC14-40EA-852A-133DB9BA798B"></a><h4 id="JSSEC-GUID-F196CEDD-DC14-40EA-852A-133DB9BA798B" class="sect4">Customizing the X509Certificate Implementation</h4>
                  <div>
                     <p>The X509Certificate implementation returned by the <code class="codeph">X509Certificate.getInstance()</code> method is by default the implementation from the JSSE implementation.
                     </p>
                     <div class="section">To cause a different implementation to be returned:</div>
                     <!-- class="section" -->
                     <div class="section">Specify the name (and package) of the other implementation's class as the value of a <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-38CC6235-823B-49D7-A566-4BEA1B64C9C6">How to Specify a java.security.Security Property</a> named <code class="codeph">cert.provider.x509v1</code>.
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-F196CEDD-DC14-40EA-852A-133DB9BA798B__GUID-79B9F37D-F567-454A-AD1C-7CEDD90571EE">For example, if the class is called <code class="codeph">MyX509CertificateImpl</code> and it appears in the <code class="codeph">com.cryptox</code> package, then you should add the following line to the security properties file:<pre class="codeblock"><code>
    cert.provider.x509v1=com.cryptox.MyX509CertificateImpl
</code></pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-D61663E8-2405-4B2D-A1F1-B8C7EA2688DB" name="GUID-D61663E8-2405-4B2D-A1F1-B8C7EA2688DB"></a><h4 id="JSSEC-GUID-D61663E8-2405-4B2D-A1F1-B8C7EA2688DB" class="sect4">Specifying Default Enabled Cipher Suites</h4>
                  <div>
                     <p>You can specify the default enabled cipher suites in your application or with the system properties <code class="codeph">jdk.tls.client.cipherSuites</code> and <code class="codeph">jdk.tls.server.cipherSuites</code>.
                     </p>
                     <div class="infoboxnote" id="GUID-D61663E8-2405-4B2D-A1F1-B8C7EA2688DB__GUID-02A9D641-DC20-473E-8C89-6BBC11F59960">
                        <p class="notep1">Note:</p>The actual use of enabled cipher suites is restricted by algorithm constraints.
                     </div>
                     <p>The set of cipher suites to enable by default is determined by one of the following ways in this order of preference:</p>
                     <ol>
                        <li>Explicitly set by application</li>
                        <li>Specified by system property</li>
                        <li>Specified by JSSE provider defaults</li>
                     </ol>
                     <p>For example, explicitly setting the default enabled cipher suites in your application overrides settings specified in <code class="codeph">jdk.tls.client.cipherSuites</code> or <code class="codeph">jdk.tls.server.cipherSuites</code> as well as JSSE provider defaults.
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-D61663E8-2405-4B2D-A1F1-B8C7EA2688DB__GUID-C5542CBE-3EEB-4E9B-9772-2BF71110A0FC">Explicitly Set by Application</p>
                        <p>You can set which cipher suites are enabled with one of the following methods:</p>
                        <ul style="list-style-type: disc;">
                           <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLSocket.html#setEnabledCipherSuites-java.lang.String:A-" target="_blank"><span class="apiname">SSLSocket.setEnabledCipherSuites(String[])</span></a></li>
                           <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLEngine.html#setEnabledCipherSuites-java.lang.String:A-" target="_blank"><span class="apiname">SSLEngine.setEnabledCipherSuites(String[])</span></a></li>
                           <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLServerSocket.html#setEnabledCipherSuites-java.lang.String:A-" target="_blank"><span class="apiname">SSLServerSocket.setEnabledCipherSuites(String[])</span></a></li>
                           <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLParameters.html#SSLParameters-java.lang.String:A-" target="_blank"><span class="apiname">SSLParameters(String[] cipherSuites)</span></a></li>
                           <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLParameters.html#SSLParameters-java.lang.String:A-java.lang.String:A-" target="_blank"><span class="apiname">SSLParameters(String[] cipherSuites, String[] protocols)</span></a></li>
                           <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLParameters.html#setCipherSuites-java.lang.String:A-" target="_blank"><span class="apiname">SSLParameters.setCipherSuites(String[])</span></a></li>
                           <li><code class="codeph">https.cipherSuites</code> system property for <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/HttpsURLConnection.html" target="_blank"><span class="apiname">HttpsURLConnection</span></a></li>
                        </ul>    
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-D61663E8-2405-4B2D-A1F1-B8C7EA2688DB__GUID-EC7E69C3-7443-409D-B4F0-9B96C08808C9">Specified by System Property</p>
                        <p>The system property <code class="codeph">jdk.tls.client.cipherSuites</code> specifies the default enabled cipher suites on the client side; <code class="codeph">jdk.tls.server.cipherSuites</code> specifies those on the server side.
                        </p>
                        <p>The syntax of the value of these two system properties is a comma-separated list of supported cipher suite names. Unrecognized or unsupported cipher suite names that are specified in these properties are ignored. See <a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html" target="_blank">Java Security Standard Algorithms</a> for standard JSSE cipher suite names.
                        </p>
                        <div class="infoboxnote" id="GUID-D61663E8-2405-4B2D-A1F1-B8C7EA2688DB__GUID-7976F3A1-6661-423E-9226-61DCF6E45E1F">
                           <p class="notep1">Note:</p>These system properties are currently supported by Oracle JDK and OpenJDK. They are not guaranteed to be supported by other JDK implementations.
                        </div>
                        <div class="infoboxnote" id="GUID-D61663E8-2405-4B2D-A1F1-B8C7EA2688DB__GUID-0AD1FE03-21D2-45CF-9E2C-9CC06C8D6F5C">
                           <p class="notep1">Caution:</p>These system properties can be used to configure weak cipher suites, or the configured cipher suites may be weak in the future. It is not recommended that you use these system properties without understanding the risks.
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-D61663E8-2405-4B2D-A1F1-B8C7EA2688DB__GUID-7B4C4C0A-73C7-46B2-9730-41E68CE9AC30">Specified by JSSE Provider Defaults</p>
                        <p>Each JSSE provider has its own default enabled cipher suites. See <a href="oracle-providers.html#GUID-7093246A-31A3-4304-AC5F-5FB6400405E2">The SunJSSE Provider</a> in <a href="oracle-providers.html#GUID-FE2D2E28-C991-4EF9-9DBE-2A4982726313" title="This document contains the technical details of the providers that are included in the JDK. It is assumed that readers have a strong understanding of the Java Cryptography Architecture and Provider Architecture.">JDK Providers Documentation</a> for the cipher suite names supported by the SunJSSE provider and which ones that are enabled by default.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-7EBD6A94-9ADE-4321-8915-17B3763F8E77" name="GUID-7EBD6A94-9ADE-4321-8915-17B3763F8E77"></a><h4 id="JSSEC-GUID-7EBD6A94-9ADE-4321-8915-17B3763F8E77" class="sect4">Specifying an Alternative HTTPS Protocol Implementation</h4>
                  <div>
                     <p>You can communicate securely with an SSL-enabled web server by using the HTTPS URL scheme for the <code class="codeph">java.net.URL</code> class. The JDK provides a default HTTPS URL implementation.
                     </p>
                     <p>If you want an alternative HTTPS protocol implementation to be used, set the <code class="codeph">java.protocol.handler.pkgs</code> <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-460C3E5A-A373-4742-9E84-EB42A7A3C363">How to Specify a java.lang.System Property</a> to include the new class name. This action causes the specified classes to be found and loaded before the JDK default classes. See the <a href="https://docs.oracle.com/javase/10/docs/api/java/net/URL.html" target="_blank"><span class="apiname">URL</span></a> class for details.
                     </p>
                     <div class="p">
                        <div class="infoboxnote" id="GUID-7EBD6A94-9ADE-4321-8915-17B3763F8E77__GUID-E9529FD8-897B-4783-8470-001332442275">
                           <p class="notep1">Note:</p>In past JSSE releases, you had to set the <code class="codeph">java.protocol.handler.pkgs</code> system property during JSSE installation. This step is no longer required unless you want to obtain an instance of <code class="codeph">com.sun.net.ssl.HttpsURLConnection</code>.
                        </div> 
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-8BC473B2-CD64-4E8B-8136-80BB286091B1" name="GUID-8BC473B2-CD64-4E8B-8136-80BB286091B1"></a><h4 id="JSSEC-GUID-8BC473B2-CD64-4E8B-8136-80BB286091B1" class="sect4">Customizing the Provider Implementation</h4>
                  <div>
                     <p>The JDK comes with a JSSE Cryptographic Service Provider, or <span class="variable" translate="no">provider</span> for short, named SunJSSE. Providers are essentially packages that implement one or more engine classes for specific cryptographic algorithms.
                     </p>
                     <p>The JSSE engine classes are <code class="codeph">SSLContext</code>, <code class="codeph">KeyManagerFactory</code>, and <code class="codeph">TrustManagerFactory</code>. See <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-2BCFDD85-D533-4E6C-8CE9-29990DEB0190" title='The Java Cryptography Architecture (JCA) is a major piece of the platform, and contains a "provider" architecture and a set of APIs for digital signatures, message digests (hashes), certificates and certificate validation, encryption (symmetric/asymmetric block/stream ciphers), key generation and management, and secure random number generation, to name a few.'>Java Cryptography Architecture (JCA) Reference Guide</a> to know more about providers and engine classes.
                     </p>
                     <p>Before it can be used, a provider must be registered, either statically or dynamically. You do not need to register the SunJSSE provider because it is preregistered. If you want to use other providers, read the following sections to see how to register them.</p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-59723547-D466-44C9-B066-EC5098B508E6" name="GUID-59723547-D466-44C9-B066-EC5098B508E6"></a><h4 id="JSSEC-GUID-59723547-D466-44C9-B066-EC5098B508E6" class="sect4">Registering the Cryptographic Provider Statically</h4>
                  <div>
                     <p></p>
                     <div class="section">
                        <p>Register a provider statically by adding a line of the following form to the security properties file, <code class="codeph"><span class="codeinlineitalic">&lt;java-home&gt;</span>/conf/security/java.security</code>:
                        </p><pre class="codeblock"><code>security.provider.<span class="variable" translate="no">n</span>=<span class="variable" translate="no">provName</span>|<span class="variable" translate="no">className</span> 
</code></pre><p>This declares a provider, and specifies its preference order <code class="codeph"><span class="variable" translate="no">n</span></code>. The preference order is the order in which providers are searched for requested algorithms when no specific provider is requested. The order is 1-based; 1 is the most preferred, followed by 2, and so on.
                        </p>
                        <p><code class="codeph"><span class="variable" translate="no">provName</span></code> is the provider's name and <code class="codeph"><span class="variable" translate="no">className</span></code> is the fully qualified class name of the provider.
                        </p>
                        <p>Standard security providers are automatically registered for you in the <code class="codeph">java.security</code> security properties file.
                        </p>
                        <p>To use another JSSE provider, add a line registering the other provider, giving it whatever preference order you prefer.</p>
                        <p>You can have more than one JSSE provider registered at the same time. The registered providers may include different implementations for different algorithms for different engine classes, or they may have support for some or all of the same types of algorithms and engine classes. When a particular engine class implementation for a particular algorithm is searched for, if no specific provider is specified for the search, then the providers are searched in preference order and the implementation from the first provider that supplies an implementation for the specified algorithm is used.</p>
                        <p>See <a href="howtoimplaprovider.html#GUID-831AA25F-F702-442D-A2E4-8DA6DEA16F33" title="Register your provider so that the JCE framework can find your provider, either with the ServiceLoader class or in the class path or module path.">Step 8.1: Configure the Provider</a> in <a href="howtoimplaprovider.html#GUID-CC161921-EBD2-48C6-B543-A956658B68B6" title="Follow these steps to implement a provider and integrate it into the JCA framework:">Steps to Implement and Integrate a Provider</a>.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-D5D3557F-069E-48CE-8586-94BCC2B0203A" name="GUID-D5D3557F-069E-48CE-8586-94BCC2B0203A"></a><h4 id="JSSEC-GUID-D5D3557F-069E-48CE-8586-94BCC2B0203A" class="sect4">Registering the Cryptographic Service Provider Dynamically</h4>
                  <div>
                     <p>Instead of registering a provider statically, you can add the provider dynamically at runtime by calling either the <span class="apiname">addProvider</span> or <span class="apiname">insertProviderAt</span> method in the <span class="apiname">Security</span> class. Note that this type of registration is not persistent and can only be done by code which is granted the <code class="codeph">insertProvider.<span class="variable" translate="no">&lt;provider name&gt;</span></code> permission.
                     </p>
                     <div class="section">See <a href="howtoimplaprovider.html#GUID-831AA25F-F702-442D-A2E4-8DA6DEA16F33" title="Register your provider so that the JCE framework can find your provider, either with the ServiceLoader class or in the class path or module path.">Step 8.1: Configure the Provider</a> in <a href="howtoimplaprovider.html#GUID-CC161921-EBD2-48C6-B543-A956658B68B6" title="Follow these steps to implement a provider and integrate it into the JCA framework:">Steps to Implement and Integrate a Provider</a>.
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-9F841002-E08F-48A6-BC57-7D15DE6575DA" name="GUID-9F841002-E08F-48A6-BC57-7D15DE6575DA"></a><h4 id="JSSEC-GUID-9F841002-E08F-48A6-BC57-7D15DE6575DA" class="sect4">Provider Configuration</h4>
                  <div>
                     <p></p>
                     <p>Some providers may require configuration. This is done using the <code class="codeph">configure</code> method of the <code class="codeph">Provider</code> class, prior to calling the <code class="codeph">addProvider</code> method of the <code class="codeph">Security</code> class. See <a href="pkcs11-reference-guide1.html#GUID-C4ABFACB-B2C9-4E71-A313-79F881488BB9">SunPKCS11 Configuration</a> for an example. The <code class="codeph">Provider.configure()</code> method is new to Java SE 9.
                     </p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-C3441400-9D82-4545-ADAE-0C332EA4AC58" name="GUID-C3441400-9D82-4545-ADAE-0C332EA4AC58"></a><h4 id="JSSEC-GUID-C3441400-9D82-4545-ADAE-0C332EA4AC58" class="sect4">Configuring the Preferred Provider for Specific Algorithms</h4>
                  <div>
                     <p>Specify the preferred provider for a specific algorithm in the <code class="codeph">jdk.security.provider.preferred</code> Security Property. By specifying a preferred provider you can configure providers that offer performance gains for specific algorithms but are not the best performing provider for other algorithms. The ordered provider list specified using the <code class="codeph">security.provider.n</code> property is not sufficient to order providers that offer performance gains for specific algorithms but are not the best performing provider for other algorithms. More flexibility is required for configuring the ordering of provider list to achieve performance gains.
                     </p>
                     <div class="section">
                        <p>The <code class="codeph">jdk.security.provider.preferred</code> Security Property allows specific algorithms, or service types to be selected from a preferred set of providers before accessing the list of registered providers. See <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-38CC6235-823B-49D7-A566-4BEA1B64C9C6">How to Specify a java.security.Security Property</a>.
                        </p>
                        <p>The <code class="codeph">jdk.security.provider.preferred</code> Security Property does not register the providers. The ordered provider list must be <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-59723547-D466-44C9-B066-EC5098B508E6">Registering the Cryptographic Provider Statically</a> using the <code class="codeph">security.provider.n</code> property. Any provider that is not registered is ignored.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-C3441400-9D82-4545-ADAE-0C332EA4AC58__GUID-F7D026FC-ED27-4EE6-BC7B-E38147595E77">Specifying the Preferred Provider for an Algorithm</p>
                        <p>The syntax for specifying the preferred providers string in the <code class="codeph">jdk.security.provider.preferred</code> Security Property is a comma-separated list of <code class="codeph">ServiceType.Algorithm:Provider</code></p>
                        <p>In this syntax:</p>
                        <dl>
                           <dt class="dlterm"><a name="GUID-C3441400-9D82-4545-ADAE-0C332EA4AC58__GUID-A708BC0D-1E9B-4CA3-B30A-3765E2E886EA">
                                 <!-- --></a>ServiceType
                           </dt>
                           <dd>
                              <p>The name of the service type (for example: <code class="codeph">"MessageDigest"</code>). ServiceType is optional. If it isn’t specified, then the algorithm applies to all service types.
                              </p>
                           </dd>
                           <dt class="dlterm"><a name="GUID-C3441400-9D82-4545-ADAE-0C332EA4AC58__GUID-B68E7DD5-A337-4754-9BB7-3D4D406A4AC0">
                                 <!-- --></a>Algorithm
                           </dt>
                           <dd>
                              <p>The standard algorithm name. See <a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html" target="_blank">Java Security Standard Algorithm Names</a>. Algorithms can be specified as full standard name, (AES/CBC/PKCS5Padding) or as partial (AES, AES/CBC, AES//PKCS5Padding).
                              </p>
                           </dd>
                           <dt class="dlterm"><a name="GUID-C3441400-9D82-4545-ADAE-0C332EA4AC58__GUID-92F5CD6E-C1BC-44A1-996F-9E00A0EDAC23">
                                 <!-- --></a>Provider
                           </dt>
                           <dd>
                              <p>The name of the provider. Any provider that isn’t listed in&nbsp;the registered list is ignored. See <a href="oracle-providers.html#GUID-FE2D2E28-C991-4EF9-9DBE-2A4982726313" title="This document contains the technical details of the providers that are included in the JDK. It is assumed that readers have a strong understanding of the Java Cryptography Architecture and Provider Architecture.">JDK Providers</a>.
                              </p>
                           </dd>
                        </dl>Entries containing errors such as parsing errors are ignored. Use the command <code class="codeph">java -Djava.security.debug=jca</code> to debug errors.
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-C3441400-9D82-4545-ADAE-0C332EA4AC58__GUID-B0BE646D-CEBB-4721-95BA-DDA285763F0C">Preferred Providers and FIPS</p>
                        <p>If you add a FIPS provider to the <code class="codeph">security.provider.n</code> property, and specify the preferred provider ordering in the <code class="codeph">jdk.security.provider.preferred</code> property then the preferred providers specified in <code class="codeph">jdk.security.provider.preferred </code> are selected first. 
                        </p>
                        <p>Hence, it is recommended that you don’t configure <code class="codeph">jdk.security.provider.preferred</code> property for FIPS provider configurations.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-C3441400-9D82-4545-ADAE-0C332EA4AC58__GUID-BC021D8E-0B67-4B11-8EDA-295C89132AA4">jdk.security.provider.preferred Default Values</p>
                        <p>The <code class="codeph">jdk.security.provider.preferred</code> property is not set by default and is used only for application performance tuning.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-C3441400-9D82-4545-ADAE-0C332EA4AC58__GUID-A00A625D-2596-41C8-BA38-21C71416A1B2">
                        <p class="titleinexample">Example 8-16 Sample jdk.security.provider.preferred Property</p>
                        <p>The syntax for specifying the <code class="codeph">jdk.security.provider.preferred </code> property is as follows:
                        </p>
                        <p><code class="codeph">jdk.security.provider.preferred=AES/GCM/NoPadding:SunJCE, MessageDigest.SHA-256:SUN</code></p>
                        <div class="p">In this syntax:
                           <dl>
                              <dt class="dlterm"><a name="GUID-C3441400-9D82-4545-ADAE-0C332EA4AC58__GUID-28C00AE0-A9A6-45AE-A743-823716638A8D">
                                    <!-- --></a>ServiceType
                              </dt>
                              <dd>MessageDigest</dd>
                              <dt class="dlterm"><a name="GUID-C3441400-9D82-4545-ADAE-0C332EA4AC58__GUID-205A4B26-295A-4488-8B2F-5E47C4219023">
                                    <!-- --></a>Algorithm
                              </dt>
                              <dd>AES/GCM/NoPadding, SHA-256</dd>
                              <dt class="dlterm"><a name="GUID-C3441400-9D82-4545-ADAE-0C332EA4AC58__GUID-05DD7678-1FFD-425E-AE6E-EAFD4619E880">
                                    <!-- --></a>Provider
                              </dt>
                              <dd>SunJCE, SUN</dd>
                           </dl>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150" name="GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150"></a><h4 id="JSSEC-GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150" class="sect4">Customizing the Default Keystores and Truststores, Store Types, and Store Passwords</h4>
                  <div>
                     <p></p>
                     <div class="section">
                        <p>Whenever a default <code class="codeph">SSLSocketFactory</code> or <code class="codeph">SSLServerSocketFactory</code> is created (via a call to <code class="codeph">SSLSocketFactory.getDefault</code> or <code class="codeph">SSLServerSocketFactory.getDefault</code>), and this default <code class="codeph">SSLSocketFactory</code> (or <code class="codeph">SSLServerSocketFactory</code>) comes from the JSSE reference implementation, a default <code class="codeph">SSLContext</code> is associated with the socket factory. (The default socket factory will come from the JSSE implementation.)
                        </p>
                        <p>This default <code class="codeph">SSLContext</code> is initialized with a default <code class="codeph">KeyManager</code> and a default <code class="codeph">TrustManager</code>. If a keystore is specified by the <code class="codeph">javax.net.ssl.keyStore</code> system property and an appropriate <code class="codeph">javax.net.ssl.keyStorePassword</code> system property (see <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-460C3E5A-A373-4742-9E84-EB42A7A3C363">How to Specify a java.lang.System Property</a>), then the <code class="codeph">KeyManager</code> created by the default <code class="codeph">SSLContext</code> will be a <code class="codeph">KeyManager</code> implementation for managing the specified keystore. (The actual implementation will be as specified in <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-0ACD9274-607C-49BE-AED9-BEE2B4F2BEF2">Customizing the Default Key Managers and Trust Managers</a>.) If no such system property is specified, then the keystore managed by the <code class="codeph">KeyManager</code> will be a new empty keystore.
                        </p>
                        <p>Generally, the peer acting as the server in the handshake will need a keystore for its KeyManager in order to obtain credentials for authentication to the client. However, if one of the anonymous cipher suites is selected, then the server's <code class="codeph">KeyManager</code> keystore is not necessary. And, unless the server requires client authentication, the peer acting as the client does not need a <code class="codeph">KeyManager</code> keystore. Thus, in these situations it may be OK if no <code class="codeph">javax.net.ssl.keyStore</code> system property value is defined.
                        </p>
                        <p>Similarly, if a truststore is specified by the <code class="codeph">javax.net.ssl.trustStore</code> system property, then the <code class="codeph">TrustManager</code> created by the default <code class="codeph">SSLContext</code> will be a <code class="codeph">TrustManager</code> implementation for managing the specified truststore. In this case, if such a property exists but the file it specifies does not, then no truststore is used. If no <code class="codeph">javax.net.ssl.trustStore</code> property exists, then a default truststore is searched for. If a truststore named <code><span class="variable" translate="no">java-home</span>/lib/security/jssecacerts</code> is found, it is used. If not, then a truststore named <code><span class="variable" translate="no">java-home</span>/lib/security/cacerts</code> is searched for and used (if it exists). Finally, if a truststore is still not found, then the truststore managed by the <code class="codeph">TrustManager</code> will be a new empty truststore.
                        </p>
                        <div class="infoboxnote" id="GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150__GUID-D83B4C21-5CFE-4043-B74A-0AE5D5EF9F1A">
                           <p class="notep1">Note:</p>
                           <p>The JDK ships with a limited number of trusted root certificates in the <code>java-home/lib/security/cacerts</code> file. As documented in <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/java/javase/11/security&amp;id=JSWOR-GUID-5990A2E4-78E3-47B7-AE75-6D1826259549" target="_blank">keytool</a> in <span id="GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150__JSWOR"><cite>Java Platform, Standard Edition Tools Reference</cite></span>, it is your responsibility to maintain (that is, add and remove) the certificates contained in this file if you use this file as a truststore.
                           </p>
                           <p>Depending on the certificate configuration of the servers that you contact, you may need to add additional root certificates. Obtain the needed specific root certificates from the appropriate vendor.</p>
                        </div> 
                        <p>If the <code class="codeph">javax.net.ssl.keyStoreType</code> and/or <code class="codeph">javax.net.ssl.keyStorePassword</code> system properties are also specified, then they are treated as the default <code class="codeph">KeyManager</code> keystore type and password, respectively. If no type is specified, then the default type is that returned by the <code class="codeph">KeyStore.getDefaultType()</code> method, which is the value of the <code class="codeph">keystore.type</code> Security Property, or "jks" if no such Security Property is specified. If no keystore password is specified, then it is assumed to be a blank string "".
                        </p>
                        <p>Similarly, if the <code class="codeph">javax.net.ssl.trustStoreType</code> and/or <code class="codeph">javax.net.ssl.trustStorePassword</code> system properties are also specified, then they are treated as the default truststore type and password, respectively. If no type is specified, then the default type is that returned by the <code class="codeph">KeyStore.getDefaultType()</code> method. If no truststore password is specified, then it is assumed to be a blank string "".
                        </p>
                        <div class="infoboxnote" id="GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150__GUID-C6D20FF5-6487-4F16-8A53-FC954900DDD1">
                           <p class="notep1">Note:</p>This section describes the current JSSE reference implementation behavior. The system properties described in this section are not guaranteed to continue to have the same names and types (system or security) or even to exist at all in future releases. They are also not guaranteed to be examined and used by any other JSSE implementations. If they <span class="variable" translate="no">are</span> examined by an implementation, then that implementation should handle them in the same manner as the JSSE reference implementation does, as described herein.
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-0ACD9274-607C-49BE-AED9-BEE2B4F2BEF2" name="GUID-0ACD9274-607C-49BE-AED9-BEE2B4F2BEF2"></a><h4 id="JSSEC-GUID-0ACD9274-607C-49BE-AED9-BEE2B4F2BEF2" class="sect4">Customizing the Default Key Managers and Trust Managers</h4>
                  <div>
                     <p></p>
                     <div class="section">
                        <p>As noted in <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150">Customizing the Default Keystores and Truststores, Store Types, and Store Passwords</a>, whenever a default <code class="codeph">SSLSocketFactory</code> or <code class="codeph">SSLServerSocketFactory</code> is created, and this default <code class="codeph">SSLSocketFactory</code> (or <code class="codeph">SSLServerSocketFactory</code>) comes from the JSSE reference implementation, a default <code class="codeph">SSLContext</code> is associated with the socket factory.
                        </p>
                        <p>This default <code class="codeph">SSLContext</code> is initialized with a <code class="codeph">KeyManager</code> and a <code class="codeph">TrustManager</code>. The <code class="codeph">KeyManager</code> and/or <code class="codeph">TrustManager</code> supplied to the default <code class="codeph">SSLContext</code> will be an implementation for managing the specified keystore or truststore, as described in the aforementioned section.
                        </p>
                        <p>The <code class="codeph">KeyManager</code> implementation chosen is determined by first examining the <code class="codeph">ssl.KeyManagerFactory.algorithm</code> <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-38CC6235-823B-49D7-A566-4BEA1B64C9C6">Security Property</a>. If such a property value is specified, then a <code class="codeph">KeyManagerFactory</code> implementation for the specified algorithm is searched for. The implementation from the first provider that supplies an implementation is used. Its <code class="codeph">getKeyManagers()</code> method is called to determine the <code class="codeph">KeyManager</code> to supply to the default <code class="codeph">SSLContext</code>. Technically, <code class="codeph">getKeyManagers()</code> returns an array of <code class="codeph">KeyManager</code> objects, one <code class="codeph">KeyManager</code> for each type of key material. If no such Security Property value is specified, then the default value of SunX509 is used to perform the search.
                        </p>
                        <div class="p">
                           <div class="infoboxnote" id="GUID-0ACD9274-607C-49BE-AED9-BEE2B4F2BEF2__GUID-D15B5C94-B4CF-4B9F-8C02-998660542B84">
                              <p class="notep1">Note:</p>A <code class="codeph">KeyManagerFactory</code> implementation for the SunX509 algorithm is supplied by the SunJSSE provider. The <code class="codeph">KeyManager</code> that it specifies is a <code class="codeph">javax.net.ssl.X509KeyManager</code> implementation.
                           </div> 
                        </div>
                        <p>Similarly, the <code class="codeph">TrustManager</code> implementation chosen is determined by first examining the <code class="codeph">ssl.TrustManagerFactory.algorithm</code> Security Property. If such a property value is specified, then a <code class="codeph">TrustManagerFactory</code> implementation for the specified algorithm is searched for. The implementation from the first provider that supplies an implementation is used. Its <code class="codeph">getTrustManagers()</code> method is called to determine the <code class="codeph">TrustManager</code> to supply to the default <code class="codeph">SSLContext</code>. Technically, <code class="codeph">getTrustManagers()</code> returns an array of <code class="codeph">TrustManager</code> objects, one <code class="codeph">TrustManager</code> for each type of trust material. If no such Security Property value is specified, then the default value of PKIX is used to perform the search.
                        </p>
                        <div class="p">
                           <div class="infoboxnote" id="GUID-0ACD9274-607C-49BE-AED9-BEE2B4F2BEF2__GUID-F1C8A2E0-258D-4164-8DC7-51E303FD09D9">
                              <p class="notep1">Note:</p> A <code class="codeph">TrustManagerFactory</code> implementation for the PKIX algorithm is supplied by the SunJSSE provider. The <code class="codeph">TrustManager</code> that it specifies is a <code class="codeph">javax.net.ssl.X509TrustManager</code> implementation.
                           </div>
                        </div>
                        <div class="p">
                           <div class="infoboxnote" id="GUID-0ACD9274-607C-49BE-AED9-BEE2B4F2BEF2__GUID-053952E0-5D14-45BF-897A-9C6A561DE975">
                              <p class="notep1">Note:</p>This section describes the current JSSE reference implementation behavior. The system properties described in this section are not guaranteed to continue to have the same names and types (system or security) or even to exist at all in future releases. They are also not guaranteed to be examined and used by any other JSSE implementations. If they <span class="variable" translate="no">are</span> examined by an implementation, then that implementation should handle them in the same manner as the JSSE reference implementation does, as described herein.
                           </div> 
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-0A438179-32A7-4900-A81C-29E3073E1E90" name="GUID-0A438179-32A7-4900-A81C-29E3073E1E90"></a><h4 id="JSSEC-GUID-0A438179-32A7-4900-A81C-29E3073E1E90" class="sect4">Disabled and Restricted Cryptographic Algorithms</h4>
                  <div>
                     <p>In some environments, certain algorithms or key lengths may be undesirable when using TLS/DTLS.  The Oracle JDK uses the <code class="codeph">jdk.certpath.disabledAlgorithms</code> and <code class="codeph">jdk.tls.disabledAlgorithm</code> Security Properties to disable algorithms during TLS/DTLS protocol negotiation, including version negotiation, cipher suites selection, peer authentication, and key exchange mechanisms. Note that these Security Properties are not guaranteed to be used by other JDK implementations. See the <code><span class="variable" translate="no">&lt;java-home&gt;</span>/conf/security/java.security</code> file for information about the syntax of these Security Properties and their current active values.
                     </p>
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p> <span class="bold"><code class="codeph">jdk.certpath.disabledAlgorithms</code> Property</span>: <span class="apiname">CertPath</span> code uses the <code class="codeph">jdk.certpath.disabledAlgorithms</code> Security Property to determine which algorithms should not be allowed during <span class="apiname">CertPath</span> checking.  For example, when a TLS server sends an identifying certificate chain, a client <span class="apiname">TrustManager</span> that uses a <span class="apiname">CertPath</span> implementation to verify the received chain will not allow the stated conditions. For example, the following line blocks any MD2-based certificate, as well as SHA1 TLSServer certificates that chain to trust anchors that are pre-installed in the <code>cacaerts</code> keystore. Likewise, this line blocks any RSA key less than 1024 bits.
                              </p><pre class="pre codeblock"><code>jdk.certpath.disabledAlgorithms=MD2, SHA1 jdkCA &amp; usage TLSServer, RSA keySize &lt; 1024</code></pre></li>
                           <li>
                              <p><span class="bold"><code class="codeph">jdk.tls.disabledAlgorithms</code> Property</span>: <span class="apiname">SunJSSE</span> code uses the <code class="codeph">jdk.tls.disabledAlgorithms</code> Security Property to disable TLS/DTLS protocols, cipher suites, keys, and so on. The syntax is similar to the <code class="codeph">jdk.certpath.disabledAlgorithms</code> Security Property. For example, the following line disables the SSLv3 algorithm and all of the TLS_*_RC4_* cipher suites:
                              </p><pre class="pre codeblock"><code>jdk.tls.disabledAlgorithms=SSLv3, RC4</code></pre></li>
                        </ul>
                        <p>If you require a particular condition, you can reactivate it by either removing the associated value in the Security Property in the <code>java.security</code> file or dynamically setting the proper Security Property before JSSE is initialized.
                        </p>
                        <p>Note that these Security Properties effectively create a third set of cipher suites, Disabled. The following list describes these three sets:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="bold">Disabled</span>: If a cipher suite contains any components (for example, RC4) on the disabled list (for example, RC4 is specified in the <code class="codeph">jdk.tls.disabledAlgorithms</code> Security Property), then that cipher suite is disabled and will <span class="bold">not</span> be considered for a connection handshake.
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">Enabled</span>: A list of specific cipher suites that will be considered for a connection.
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">Not Enabled</span>: A list of non-disabled cipher suites that will <span class="bold">not</span> be considered for a connection. To re-enable these cipher suites, call the appropriate <span class="apiname">setEnabledCipherSuites()</span> or <span class="apiname">setSSLParameters()</span> methods.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-3D5E4A8B-F8F3-49E0-AE55-D12A844FADB1" name="GUID-3D5E4A8B-F8F3-49E0-AE55-D12A844FADB1"></a><h4 id="JSSEC-GUID-3D5E4A8B-F8F3-49E0-AE55-D12A844FADB1" class="sect4">Legacy Cryptographic Algorithms</h4>
                  <div>
                     <p>In some environments, a certain algorithm may be undesirable but it cannot be disabled because of its use in legacy applications. Legacy algorithms may still be supported, but applications should not use them as the security strength of legacy algorithms is usually not strong enough. During TLS/DTLS security parameters negotiation, legacy algorithms are not negotiated unless there are no other candidates. The Security Property <code class="codeph">jdk.tls.legacyAlgorithms</code> specifies which algorithms the Oracle JDK considers as legacy algorithms. <code class="codeph"><span class="variable" translate="no">&lt;java-home&gt;</span>/conf/security/java.security</code> file for the syntax of this Security Property.
                     </p>
                     <div class="infoboxnote" id="GUID-3D5E4A8B-F8F3-49E0-AE55-D12A844FADB1__GUID-A538AD87-EC24-4BED-8AA1-1FA33AF6F75A">
                        <p class="notep1">Note:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>If a legacy algorithm is also restricted through the <code class="codeph">jdk.tls.disabledAlgorithms</code> property or the <code class="codeph">java.security.AlgorithmConstraints</code> API (see the method <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLParameters.html#setAlgorithmConstraints(java.security.AlgorithmConstraints)" target="_blank"><code class="codeph">javax.net.ssl.SSLParameters.setAlgorithmConstraints</code></a>), then the algorithm is completely disabled and will not be negotiated.
                              </p>
                           </li>
                           <li>
                              <p>If your application uses an algorithm specified in the Security Property <code class="codeph">jdk.tls.legacyAlgorithms</code>, use an alternative algorithm as soon as possible; a future JDK release may specify a legacy algorithm as a restricted algorithm.
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-316FB978-7588-442E-B829-B4973DB3B584" name="GUID-316FB978-7588-442E-B829-B4973DB3B584"></a><h4 id="JSSEC-GUID-316FB978-7588-442E-B829-B4973DB3B584" class="sect4">Customizing the Encryption Algorithm Providers</h4>
                  <div>
                     <p>The SunJSSE provider uses the SunJCE implementation for all its cryptographic needs. Although it is recommended that you leave the provider at its regular position, you can use implementations from other JCA or JCE providers by registering them <span class="italic">before</span> the SunJCE provider.
                     </p>
                     <div class="section">
                        <p>The standard JCA mechanism (see <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-2DCBD20D-2D5E-4ECA-81A8-1FCE9E961741">How Provider Implementations Are Requested and Supplied</a>) can be used to configure providers, either statically via the security properties file <code class="codeph"><span class="variable" translate="no">&lt;java-home&gt;</span>/conf/security/java.security</code>, or dynamically via the <code class="codeph">addProvider()</code> or <code class="codeph">insertProviderAt()</code> method in the <code class="codeph">java.security.Security</code> class.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-D9B216E8-3EFC-4882-B76E-17A87D8F2F9D" name="GUID-D9B216E8-3EFC-4882-B76E-17A87D8F2F9D"></a><h4 id="JSSEC-GUID-D9B216E8-3EFC-4882-B76E-17A87D8F2F9D" class="sect4">Customizing Size of Ephemeral Diffie-Hellman Keys</h4>
                  <div>
                     <p>In TLS/DTLS connections, ephemeral Diffie-Hellman (DH) keys may be used internally during the handshaking. The SunJSSE provider provides a flexible approach to customize the strength of the ephemeral DH key size during TLS/DTLS handshaking.</p>
                     <div class="section">
                        <p>Diffie-Hellman (DH) keys of sizes less than 1024 bits have been deprecated because of their insufficient strength. You can customize the ephemeral DH key size with the system property <code class="codeph">jdk.tls.ephemeralDHKeySize</code>. This system property does not impact DH key sizes in <code class="codeph">ServerKeyExchange</code> messages for exportable cipher suites. It impacts only the DHE_RSA, DHE_DSS, and DH_anon-based cipher suites in the JSSE Oracle provider.
                        </p>
                        <p>You can specify one of the following values for this property:</p>
                        <ul style="list-style-type: disc;">
                           <li>Undefined: A DH key of size 1024 bits will be used always for non-exportable cipher suites. This is the default value for this property.</li>
                           <li><code class="codeph">legacy</code>: The JSSE Oracle provider preserves the legacy behavior (for example, using ephemeral DH keys of sizes 512 bits and 768 bits) of JDK 7 and earlier releases.
                           </li>
                           <li><code class="codeph">matched</code>: For non-exportable anonymous cipher suites, the DH key size in ServerKeyExchange messages is 1024 bits. For X.509 certificate based authentication (of non-exportable cipher suites), the DH key size matching the corresponding authentication key is used, except that the size must be between 1024 bits and 2048 bits. For example, if the public key size of an authentication certificate is 2048 bits, then the ephemeral DH key size should be 2048 bits unless the cipher suite is exportable. This key sizing scheme keeps the cryptographic strength consistent between authentication keys and key-exchange keys.
                           </li>
                           <li>A valid integer between 1024 and 2048, inclusively: A fixed ephemeral DH key size of the specified value, in bits, will be used for non-exportable cipher suites.</li>
                        </ul>
                        <p>The following table summaries the minimum and maximum acceptable DH key sizes for each of the possible values for the system property <code class="codeph">jdk.tls.ephemeralDHKeySize</code>:
                        </p>
                        <div class="tblformal" id="GUID-D9B216E8-3EFC-4882-B76E-17A87D8F2F9D__GUID-16528793-4333-4BC2-928E-787DFD2C1BA2">
                           <p class="titleintable">Table 8-4 DH Key Sizes for the System Property <code class="codeph">jdk.tls.ephemeralDHKeySize</code></p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="DH Key Sizes for the System Property jdk.tls.ephemeralDHKeySize" summary="The table summaries the minimum and maximum acceptable DH key sizes for each of the possible values for the system property jdk.tls.ephemeralDHKeySize." width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d112429e6212">Value of jdk.tls.ephemeralDHKeySize</th>
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d112429e6214">Undefined</th>
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d112429e6216">legacy</th>
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d112429e6218">matched</th>
                                    <th rowspan="1" colspan="1" align="left" valign="bottom" id="d112429e6220">Integer value (fixed)</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d112429e6224" headers="d112429e6212 ">Exportable DH key size</td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d112429e6224 d112429e6214 ">512</td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d112429e6224 d112429e6216 ">512</td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d112429e6224 d112429e6218 ">512</td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d112429e6224 d112429e6220 ">512</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d112429e6235" headers="d112429e6212 ">Non-exportable anonymous cipher suites</td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d112429e6235 d112429e6214 ">1024</td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d112429e6235 d112429e6216 ">768</td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d112429e6235 d112429e6218 ">1024</td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d112429e6235 d112429e6220 ">The fixed key size is specified by a valid integer property value, which must be between 1024 and 2048, inclusively.</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d112429e6246" headers="d112429e6212 ">Authentication certificate</td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d112429e6246 d112429e6214 ">1024</td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d112429e6246 d112429e6216 ">768</td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d112429e6246 d112429e6218 ">
                                       <p>The key size is the same as the authentication certificate, but must be between 1024 bits and 2048 bits, inclusively. However, the only DH key size that the SunJCE provider supports that is larger than 1024 bits is 2048 bits.</p>
                                       <p>Consequently, you may use the values 1024 or 2048 only.</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d112429e6246 d112429e6220 ">The fixed key size is specified by a valid integer property value, which must be between 1024 and 2048, inclusively.</td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-41D5F11E-81BD-4C03-A315-48016D9B9B36" name="GUID-41D5F11E-81BD-4C03-A315-48016D9B9B36"></a><h4 id="JSSEC-GUID-41D5F11E-81BD-4C03-A315-48016D9B9B36" class="sect4">Customizing Maximum Fragment Length Negotiation (MFLN) Extension</h4>
                  <div>
                     <p>In order to negotiate smaller maximum fragment lengths, clients have an option to include an extension of type <code>max_fragment_length</code> in the ClientHello message. A system property <code class="codeph">jsse.enableMFLNExtension</code>, can be used to enable or disable the MFLN extension for TLS/DTLS.
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-41D5F11E-81BD-4C03-A315-48016D9B9B36__GUID-205DC9FA-8FF1-4204-A93B-F98AD1970E8F">Maximum Fragment Length Negotiation</p>
                        <p>It may be desirable for constrained TLS/DTLS clients to negotiate a smaller maximum fragment length due to memory limitations or bandwidth limitations. In order to negotiate smaller maximum fragment lengths, clients have an option to include an extension of type <code>max_fragment_length</code> in the (extended) ClientHello message. See <a href="http://www.rfc-base.org/txt/rfc-6066.txt" target="_blank">RFC 6066</a>.
                        </p>
                        <p>Once a maximum fragment length has been successfully negotiated, the TLS/DTLS client and server can immediately begin fragmenting messages (including handshake messages) to ensure that no fragment larger than the negotiated length is sent.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-41D5F11E-81BD-4C03-A315-48016D9B9B36__GUID-75708E4F-E271-4F51-8631-8FF8006A8257">System Property jsse.enableMFLNExtension</p>
                        <p>A system property <code class="codeph">jsse.enableMFLNExtension</code> is defined to enable or disable the MFLN extension. The <code class="codeph">jsse.enableMFLNExtension</code> is disabled by default.
                        </p>
                        <p>The value of the system property can be set as follows:</p>
                        <div class="tblformal" id="GUID-41D5F11E-81BD-4C03-A315-48016D9B9B36__GUID-A6CDBCFE-D1FB-4CF8-84A4-C764B31CB09F">
                           <p class="titleintable">Table 8-5 jsse.enableMFLNExtension system property</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="jsse.enableMFLNExtension system property" summary="List of possible values provided for the jsse.enableMFLNExtension system property." width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" id="d112429e6311">System Property</th>
                                    <th align="left" valign="bottom" id="d112429e6313">Description</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d112429e6317" headers="d112429e6311 "><code class="codeph">jsse.enableMFLNExtension</code>=true
                                    </td>
                                    <td align="left" valign="top" headers="d112429e6317 d112429e6313 ">Enable the MFLN extension. If the returned value of <code class="codeph">SSLParameters.getMaximumPacketSize()</code> is less than (2<sup>12</sup> + header-size) the maximum fragment length negotiation extension would be enabled. &nbsp;
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d112429e6330" headers="d112429e6311 "><code class="codeph">jsse.enableMFLNExtension</code>=false
                                    </td>
                                    <td align="left" valign="top" headers="d112429e6330 d112429e6313 ">Disable the MFLN extension. </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-3C9ADC85-E82C-421E-808D-F06028838F47" name="GUID-3C9ADC85-E82C-421E-808D-F06028838F47"></a><h4 id="JSSEC-GUID-3C9ADC85-E82C-421E-808D-F06028838F47" class="sect4">Configuring the Maximum and Minimum Packet Size </h4>
                  <div>
                     <p></p>
                     <div class="section">
                        <p>Set the maximum expected network packet size in bytes for a TLS/DTLS record with the <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLParameters.html#setMaximumPacketSize-int-" target="_blank"><span class="apiname">SSLParameters.setMaximumPacketSize</span></a> method.
                        </p>
                        <p>It is recommended that the packet size should not be less than 256 bytes so that small handshake messages, such as HelloVerifyRequests, are not fragmented.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-B970ADD6-1E9F-4C18-A26E-0679B50CC946" name="GUID-B970ADD6-1E9F-4C18-A26E-0679B50CC946"></a><h4 id="JSSEC-GUID-B970ADD6-1E9F-4C18-A26E-0679B50CC946" class="sect4">Limiting Amount of Data Algorithms May Encrypt with a Set of Keys</h4>
                  <div>
                     <p>You can specify a limit on the amount of data an algorithm may encrypt with a specific set of keys with the <code class="codeph">jdk.tls.keyLimits</code> Security Property. Once this limit is reached, a KeyUpdate post-handshake message is sent, which requests that the current set of keys be updated. This Security Property is only for symmetrical ciphers with TLS 1.3.
                     </p>
                     <p>The syntax for this property is as follows:</p><pre class="pre codeblock"><code>jdk.tls.keyLimits=<span class="variable" translate="no">KeyLimit</span> { , <span class="variable" translate="no">KeyLimit</span> }</code></pre><dl>
                        <dt class="dlterm"><a name="GUID-B970ADD6-1E9F-4C18-A26E-0679B50CC946__GUID-6ABF816F-3121-4CB7-99E7-B8DF02E7EEB4">
                              <!-- --></a>KeyLimit
                        </dt>
                        <dd><pre class="pre codeblock"><code><span class="variable" translate="no">AlgorithmName</span> KeyUpdate <span class="variable" translate="no">Length</span></code></pre></dd>
                        <dt class="dlterm"><a name="GUID-B970ADD6-1E9F-4C18-A26E-0679B50CC946__GUID-7921656C-AEC5-4551-81E3-3C75F0970E36">
                              <!-- --></a>AlgorithmName
                        </dt>
                        <dd>A full algorithm transformation</dd>
                        <dt class="dlterm"><a name="GUID-B970ADD6-1E9F-4C18-A26E-0679B50CC946__GUID-ED46F79E-11D4-4E92-8F61-3402AD26612A">
                              <!-- --></a>Length
                        </dt>
                        <dd>The amount of encrypted data in a session before a KeyUpdate message is sent. This value may be an integer value in bytes or as a power of two, for example, <code class="codeph">2^37</code>.
                        </dd>
                     </dl>
                     <p>For example, the following specifies that a KeyUpdate message is sent once the algorithm AES/GCM/NoPadding has encrypted 2<sup>37</sup> bytes:
                     </p><pre class="pre codeblock"><code>jdk.tls.keyLimits=AES/GCM/NoPadding KeyUpdate 2^37</code></pre></div>
               </div>
               <div class="sect3"><a id="GUID-E1A3A7C3-309A-4415-903B-B31C96F68C86" name="GUID-E1A3A7C3-309A-4415-903B-B31C96F68C86"></a><h4 id="JSSEC-GUID-E1A3A7C3-309A-4415-903B-B31C96F68C86" class="sect4">Client-Driven OCSP and OCSP Stapling</h4>
                  <div>
                     <p>Use the Online Certificate Status Protocol (OCSP) to determine the X.509 certificate revocation status during the Transport Layer Security (TLS) handshake.</p>
                     <div class="p">X.509 certificates used in TLS can be revoked by the issuing Certificate Authority (CA) if there is reason to believe that a certificate is compromised.  You can check the revocation status of certificates during the TLS handshake by using one of the following approaches.
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="bold">Certificate Revocation List (CRL)</span>: A CRL is a simple list of revoked certificates. The application receiving a certificate gets the CRL from a CRL server and checks if the certificate received is on the list. There are two disadvantages to using CRLs that mean a certificate could be revoked:
                              </p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>CRLs can become very large so there can be a substantial increase in network traffic.</p>
                                 </li>
                                 <li>
                                    <p>Many CRLs are created with longer validity periods, which increases the possibility of a certificate being revoked within that validity period and not showing up until the next CRL refresh.</p>
                                 </li>
                              </ul>
                              <p>See <a href="java-pki-programmers-guide.html#GUID-AB96FD45-6F8A-4785-B6C5-082BEB6CDA5E" title="The Java Certification Path API includes the CertStore class for retrieving certificates and CRLs from a repository.">Certificate/CRL Storage Classes</a> in <a href="java-pki-programmers-guide.html#GUID-650D0D53-B617-4055-AFD3-AF5C2629CBBF" title="The Java Certification Path API consists of classes and interfaces for handling certification paths, which are also called certification chains. If a certification path meets certain validation rules, it may be used to securely establish the mapping of a public key to a subject.">Java PKI Programmers Guide</a>.
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">Client-driven OCSP </span>: In client-driven OCSP, the client uses OCSP to contact an OCSP responder to check the certificate’s revocation status. The amount of data required is usually less than that of a CRL, and the OCSP responder is likely to be more up-to-date with the revocation status than a CRL. Each client connecting to a server requires an OCSP response for each certificate being checked. If the server is a popular one, and&nbsp;many&nbsp;of the clients are using client­driven OCSP, these OCSP requests can&nbsp;have a negative effect on the performance of the OCSP responder.
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">OCSP stapling</span>: OCSP stapling enables the server, rather than the client, to make the request to the OCSP responder. The server staples the OCSP response to the certificate and returns it to the client during the TLS handshake. This approach enables the presenter of the certificate, rather than the issuing CA, to bear the resource cost of providing OCSP responses. It also enables the server to cache the OCSP responses and supply them to all clients. This significantly reduces the load on the OCSP responder because the response can be cached and periodically refreshed by the server rather than by each client.
                              </p>
                           </li>
                        </ul> 
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-5B5A093F-FE4E-4D57-B66C-93CD6F78B1D1" name="GUID-5B5A093F-FE4E-4D57-B66C-93CD6F78B1D1"></a><h5 id="JSSEC-GUID-5B5A093F-FE4E-4D57-B66C-93CD6F78B1D1" class="sect5">Client-Driven OCSP and Certificate Revocation</h5>
                     <div>
                        <p>Client-driven Online Certificate Status Protocol (OCSP) enables the client to check the certificate revocation status by connecting to an OCSP responder during the Transport Layer Security (TLS) handshake.</p>
                        <p>The client-driven OCSP request occurs during the TLS handshake just after the client receives the certificate from the server and validates it.</p>
                        <div class="section">
                           <p class="subhead3" id="GUID-5B5A093F-FE4E-4D57-B66C-93CD6F78B1D1__GUID-BA910957-12B8-4ABC-B812-8689DA5B68F4">TLS Handshake with Client-Driven OCSP</p>
                           <p>Client-driven OCSP is used during the TLS handshake between the client and the server to check the server certificate revocation status. After the client receives the certificate, it performs certificate validation. If the validation is successful, then the client verifies that the certificate was not revoked by the issuer. This is done by sending an OCSP request to an OCSP responder. After receiving the OCSP response, the client checks this response before completing the TLS handshake.</p>
                           <p>Usually the client finds the OCSP responder's URL by looking in the Authority Information Access (AIA) extension of the certificate, but it can be set to a static URL through the use of a system property.</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div class="sect5"><a id="GUID-4E3834C7-E741-499E-9646-3557670FD88A" name="GUID-4E3834C7-E741-499E-9646-3557670FD88A"></a><h6 id="JSSEC-GUID-4E3834C7-E741-499E-9646-3557670FD88A" class="sect6">Setting up a Java Client to use Client-Driven OCSP</h6>
                        <div>
                           <p>Client-driven OCSP is enabled by enabling revocation checking and enabling OCSP.</p>
                           <div class="p">To configure a Java client to use client-driven OCSP, the Java client must already be set up to connect to a server using TLS.</div>
                           <!-- class="section" -->
                           <ol>
                              <li class="stepexpand"><span>Enable revocation checking. You can do this in two different ways.</span><ul>
                                    <li>Set the system property <code class="codeph">com.sun.net.ssl.checkRevocation</code> to <code class="codeph">true</code>.
                                    </li>
                                    <li>Use the <code class="codeph">setRevocationEnabled</code> method on <code class="codeph">PKIXParameters</code>. See <a href="java-pki-programmers-guide.html#GUID-3D95A3BE-74CB-4357-BB85-9A8DEA36A457" title="The PKIXParametersClass class specifies the set of input parameters defined by the PKIX certification path validation algorithm. It also includes a few additional useful parameters.">The PKIXParameters Class</a>.
                                    </li>
                                 </ul>
                              </li>
                              <li class="stepexpand"><span>Enable client-driven OCSP:</span><div>
                                    <p>Set the Security Property <code class="codeph">ocsp.enable</code> to <code class="codeph">true</code>.
                                    </p>
                                 </div>
                              </li>
                           </ol>
                           <div class="section">Both steps are necessary. The <code class="codeph">ocsp.enable</code> setting has no effect unless revocation checking is enabled.
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-489366D5-635A-4204-8980-3FB126047C45" name="GUID-489366D5-635A-4204-8980-3FB126047C45"></a><h5 id="JSSEC-GUID-489366D5-635A-4204-8980-3FB126047C45" class="sect5">OCSP Stapling and Certificate Revocation</h5>
                     <div>
                        <p>Online Certificate Status Protocol (OCSP) stapling enables the presenter of a certificate, rather than the issuing Certificate Authority (CA), to bear the resource cost of providing the OCSP responses that contain the certificate’s revocation status.</p>
                        <div class="section">
                           <p class="subhead3" id="GUID-489366D5-635A-4204-8980-3FB126047C45__GUID-AFCEC2A1-F72C-4598-AF5E-4FD0FA912A15">TLS Handshake with OCSP Stapling</p>
                           <p>OCSP stapling is used during the Transport Layer Security (TLS) handshake between the client and the server to check the server certificate revocation status. The server makes the OCSP request to the OCSP responder and staples the OCSP responses to the certificates returned to the client. By having the server make the request to the OCSP responder, the responses can be cached, and then used multiple times for many clients.</p>
                           <p>The client receiving the certificates with stapled OCSP responses validates each certificate, and then checks the OCSP responses before continuing with the handshake. If, from the client’s perspective, the stapled OCSP response from the server for a certificate is missing, the client will attempt to use client-driven OCSP or Certificate Revocation Lists (CRLs) to get revocation information if the following are true:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>The RevocationEnabled flag is set to true through the <a href="https://docs.oracle.com/javase/10/docs/api/java/security/cert/PKIXParameters.html#setRevocationEnabled(boolean)" target="_blank"><span class="apiname">PKIXParameters.setRecovcationEnabled</span></a> method.
                                 </p>
                              </li>
                              <li>
                                 <p>OCSP checking is enabled by setting the <span class="apiname">ocsp.enable</span> Security Property to true.
                                 </p>
                              </li>
                           </ul>
                           <p>OCSP checking works in conjunction with CRLs during revocation checking. See <a href="java-pki-programmers-guide.html#GUID-E6E737DB-4000-4005-969E-BCD0238B1566" title="Client-side support for the On-Line Certificate Status Protocol (OCSP) as defined in RFC 2560 is supported.">Appendix C: OCSP Support</a> in <a href="java-pki-programmers-guide.html#GUID-650D0D53-B617-4055-AFD3-AF5C2629CBBF" title="The Java Certification Path API consists of classes and interfaces for handling certification paths, which are also called certification chains. If a certification path meets certain validation rules, it may be used to securely establish the mapping of a public key to a subject.">Java PKI Programmers Guide</a>.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-489366D5-635A-4204-8980-3FB126047C45__GUID-601E4E6D-6F48-4301-BFF2-346BCCB48536">Status Request Versus Multiple Status Request</p>
                           <p>The OCSP stapling feature implements the TLS Certificate Status Request extension (section 8 of&nbsp;<a href="http://tools.ietf.org/html/rfc6066" target="_blank">RFC 6066</a>) and the Multiple Certificate Status Request Extension (<a href="http://tools.ietf.org/html/rfc6961" target="_blank">RFC 6961</a>).
                           </p>
                           <p>The TLS Certificate Status Request extension requests revocation information for only the server certificate in the certificate chain while the Multiple Certificate Status Request Extension requests revocation information for all certificates in the certificate chain. In the case where only the server certificate's revocation information is sent to the client, other certificates in the chain may be verified using the Certificate Revocation Lists (CRLs) or client-driven OCSP (but the client will need to be set up to do this).</p>
                           <p>Although TLS allows the server to also request the client’s certificate, there is no provision in OCSP stapling that enables the client to contact the appropriate OCSP responder and staple the response to the certificate sent to the server.</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-489366D5-635A-4204-8980-3FB126047C45__GUID-EF6F03FD-1BFA-4848-AB3D-6A3CA98ED14D">The OCSP Request and Response</p>
                           <p>OCSP request and response messages are usually sent over unencrypted HTTP. The response is signed by the CA.</p>
                           <p>If necessary, the stapled responses can be obtained in the client code by calling the <code class="codeph">getStatusResponses</code> method on the <code class="codeph">ExtendedSSLSession</code> object. The method signature is:
                           </p><pre class="pre codeblock"><code>public List&lt;byte[]&gt; getStatusResponses();</code></pre><p>The OCSP response is encoded using the Distinguished Encoding Rules (DER) in a format described by the ASN.1 found in <a href="http://tools.ietf.org/html/rfc6960" target="_blank">RFC 6960</a>.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div class="sect5"><a id="GUID-F15D190D-85A1-4012-8FE3-060DBD90E579" name="GUID-F15D190D-85A1-4012-8FE3-060DBD90E579"></a><h6 id="JSSEC-GUID-F15D190D-85A1-4012-8FE3-060DBD90E579" class="sect6">Setting Up a Java Client to Use OCSP Stapling</h6>
                        <div>
                           <p>Online Certificate Status Protocol (OCSP) stapling is enabled on the client side by setting the system property <code class="codeph">jdk.tls.client.enableStatusRequestExtension</code> to <code class="codeph">true</code> (its default value).
                           </p>
                           <div class="p">To configure a Java client to make use of the OCSP response stapled to the certificate returned by a server, the Java client must already be set up to connect to a server using TLS, and the server must be set up to staple an OCSP response to the certificate it returns part of the TLS handshake.</div>
                           <!-- class="section" -->
                           <ol>
                              <li class="stepexpand"><span>Enable OCSP stapling on the client:</span><div>
                                    <p>If necessary, set the system property <code class="codeph">jdk.tls.client.enableStatusRequestExtension</code> to <code class="codeph">true</code>.
                                    </p>
                                 </div>
                              </li>
                              <li class="stepexpand"><span>Enable revocation checking. You can do this in two different ways.</span><ul>
                                    <li>Set the system property <code class="codeph">com.sun.net.ssl.checkRevocation</code> to <code class="codeph">true</code>. You can do this from the command line or in the code. 
                                    </li>
                                    <li>Use the <code class="codeph">setRevocationEnabled</code> method on the <code class="codeph">PKIXParameters</code> class. See <a href="java-pki-programmers-guide.html#GUID-3D95A3BE-74CB-4357-BB85-9A8DEA36A457" title="The PKIXParametersClass class specifies the set of input parameters defined by the PKIX certification path validation algorithm. It also includes a few additional useful parameters.">The PKIXParameters Class</a>.
                                    </li>
                                 </ul>
                                 <div>
                                    <p>For the client to include the stapled responses received from the server in the certificate validation, revocation checking must be set to <code class="codeph">true</code>. If revocation checking is not set to <code class="codeph">true</code>, then the connection will be allowed to proceed regardless of the presence or status of the revocation information
                                    </p>
                                 </div>
                              </li>
                           </ol>
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-423716FB-DA34-4C73-B3A1-EB4CE120BB62" name="GUID-423716FB-DA34-4C73-B3A1-EB4CE120BB62"></a><h6 id="JSSEC-GUID-423716FB-DA34-4C73-B3A1-EB4CE120BB62" class="sect6">Setting Up a Java Server to Use OCSP Stapling</h6>
                        <div>
                           <p>Online Certificate Status Protocol (OCSP) stapling is enabled on the server by setting the system property <code class="codeph">jdk.tls.server.enableStatusRequestExtension</code> to <code class="codeph">true</code>. (It is set to <code class="codeph">false</code> by default.)
                           </p>
                           <div class="p">The following steps can be used to configure a Java server to connect to an OCSP responder and staple the OCSP response to the certificate to be returned to the client. The Java server must already be set up to respond to clients using TLS.</div>
                           <!-- class="section" -->
                           <ol>
                              <li class="stepexpand"><span>Enable OCSP stapling on the server:</span><div>
                                    <p>Set the system property <code class="codeph">jdk.tls.server.enableStatusRequestExtension</code> to <code class="codeph">true</code>.
                                    </p>
                                 </div>
                              </li>
                              <li class="stepexpand"><strong>Optional: </strong><span>Set other properties as required. See <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-3A540C8F-5EB7-4E96-9051-92A1E2D8AF37" title="This topic lists the effects of setting various properties when using the Online Certificate Status Protocol (OCSP). It shows the properties used in both client-driven OCSP and OCSP stapling."> OCSP Stapling Configuration Properties</a> for a list of the valid properties.</span></li>
                           </ol>
                        </div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-3A540C8F-5EB7-4E96-9051-92A1E2D8AF37" name="GUID-3A540C8F-5EB7-4E96-9051-92A1E2D8AF37"></a><h5 id="JSSEC-GUID-3A540C8F-5EB7-4E96-9051-92A1E2D8AF37" class="sect5">OCSP Stapling Configuration Properties</h5>
                     <div>
                        <p>This topic lists the effects of setting various properties when using the Online Certificate Status Protocol (OCSP). It shows the properties used in both client-driven OCSP and OCSP stapling.</p>
                        <div class="section">
                           <p class="subhead3" id="GUID-3A540C8F-5EB7-4E96-9051-92A1E2D8AF37__GUID-80804982-7A97-4698-A8C4-79246BD5BFCC">Server-side Properties</p>
                           <p> Most of the properties are read at <code class="codeph">SSLContext</code> instantiation time. This means that if you set a property, you must obtain a new <code class="codeph">SSLContext</code> object so that an <code class="codeph">SSLSocket</code> or <code class="codeph">SSLEngine</code> object you obtain from that <code class="codeph">SSLContext</code> object will reflect the property setting. The one exception is the<code class="codeph"> jdk.tls.stapling.responseTimeout</code> property. That property is evaluated when the <code class="codeph">ServerHandshaker</code> object is created (essentially at the same time that an <code class="codeph">SSLSocket</code> or <code class="codeph">SSLEngine</code> object gets created).
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="tblformalwide" id="GUID-3A540C8F-5EB7-4E96-9051-92A1E2D8AF37__GUID-B67B52FB-CD64-48FC-9552-23E929727680">
                              <p class="titleintable">Table 8-6 Server-Side OCSP stapling Properties</p>
                              <table cellpadding="4" cellspacing="0" class="FormalWide" title="Server-Side OCSP stapling Properties" summary="This table shows the properties that can be set for the server in OCSP stapling. Only the first property jdk.tls.server.enableStatusRequestExtension, is needed to enable OCSP stapling." width="100%" frame="hsides" border="1" rules="rows">
                                 <thead>
                                    <tr align="left" valign="top">
                                       <th align="left" valign="bottom" width="45%" id="d112429e6787">Property</th>
                                       <th align="left" valign="bottom" width="40%" id="d112429e6789">Description</th>
                                       <th align="left" valign="bottom" width="15%" id="d112429e6791">Default Value</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="45%" id="d112429e6795" headers="d112429e6787 "><code class="codeph">jdk.tls.server.enableStatusRequestExtension</code></td>
                                       <td align="left" valign="top" width="40%" headers="d112429e6795 d112429e6789 ">Enables the server-side support for OCSP stapling.</td>
                                       <td align="left" valign="top" width="15%" headers="d112429e6795 d112429e6791 ">False</td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="45%" id="d112429e6803" headers="d112429e6787 "><code class="codeph">jdk.tls.stapling.responseTimeout</code></td>
                                       <td align="left" valign="top" width="40%" headers="d112429e6803 d112429e6789 ">
                                          <p>Controls the maximum amount of time the server will use to obtain OCSP responses, whether from the cache or by contacting an OCSP responder.</p>
                                          <p>The responses that are already received will be sent in a <code class="codeph">CertificateStatus</code> message, if applicable based on the type of stapling being done. 
                                          </p>
                                       </td>
                                       <td align="left" valign="top" width="15%" headers="d112429e6803 d112429e6791 ">5000 (integer value in milliseconds)</td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="45%" id="d112429e6817" headers="d112429e6787 "><code class="codeph">jdk.tls.stapling.cacheSize</code></td>
                                       <td align="left" valign="top" width="40%" headers="d112429e6817 d112429e6789 ">
                                          <p>Controls the maximum cache size in entries.</p>
                                          <p> If the cache is full and a new response needs to be cached, then the least recently used cache entry will be replaced with the new one. A value of zero or less for this property means that the cache will have no upper bound on the number of responses it can contain.</p>
                                       </td>
                                       <td align="left" valign="top" width="15%" headers="d112429e6817 d112429e6791 ">256 objects</td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="45%" id="d112429e6828" headers="d112429e6787 "><code class="codeph">jdk.tls.stapling.cacheLifetime</code></td>
                                       <td align="left" valign="top" width="40%" headers="d112429e6828 d112429e6789 ">
                                          <p>Controls the maximum life of a cached response. </p>
                                          <p>It is possible for responses to have shorter lifetimes than the value set with this property if the response has a <span class="bold">nextUpdate</span> field that expires sooner than the cache lifetime. A value of zero or less for this property disables the cache lifetime. If an object has no <span class="bold">nextUpdate</span> value and cache lifetimes are disabled, then the response will not be cached.
                                          </p>
                                       </td>
                                       <td align="left" valign="top" width="15%" headers="d112429e6828 d112429e6791 ">3600 seconds (1 hour)</td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="45%" id="d112429e6845" headers="d112429e6787 "><code class="codeph">jdk.tls.stapling.responderURI</code></td>
                                       <td align="left" valign="top" width="40%" headers="d112429e6845 d112429e6789 ">
                                          <p>Enables the administrator to set a default URI in the event that certificates used for TLS do not have the Authority Info Access (AIA) extension.</p>
                                          <p> It will not override the Authority Info Access extension value unless the <code class="codeph">jdk.tls.stapling.responderOverride</code> property is set. 
                                          </p>
                                       </td>
                                       <td align="left" valign="top" width="15%" headers="d112429e6845 d112429e6791 ">Not set</td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="45%" id="d112429e6859" headers="d112429e6787 "><code class="codeph">jdk.tls.stapling.responderOverride</code></td>
                                       <td align="left" valign="top" width="40%" headers="d112429e6859 d112429e6789 ">
                                          <p>Enables a URI provided through the <code class="codeph">jdk.tls.stapling.responderURI</code> property to override any AIA extension value.
                                          </p>
                                       </td>
                                       <td align="left" valign="top" width="15%" headers="d112429e6859 d112429e6791 ">False</td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="45%" id="d112429e6871" headers="d112429e6787 "><code class="codeph">jdk.tls.stapling.ignoreExtensions</code></td>
                                       <td align="left" valign="top" width="40%" headers="d112429e6871 d112429e6789 ">
                                          <p>Disables the forwarding of OCSP extensions specified in the&nbsp;<code class="codeph">status_request</code>&nbsp;or&nbsp;<code class="codeph">status_request_v2</code>&nbsp;TLS extensions.
                                          </p>
                                       </td>
                                       <td align="left" valign="top" width="15%" headers="d112429e6871 d112429e6791 ">False</td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <!-- class="inftblhruleinformal" -->
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-3A540C8F-5EB7-4E96-9051-92A1E2D8AF37__GUID-379CDCDD-5E02-4D98-A0D1-0583B903AB50">Client-Side Settings</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="tblformal" id="GUID-3A540C8F-5EB7-4E96-9051-92A1E2D8AF37__GUID-F7BC7AEB-8918-40C7-AA80-E0CF554FD1F3">
                              <p class="titleintable">Table 8-7 Client-Side Settings Used in OCSP Stapling</p>
                              <table cellpadding="4" cellspacing="0" class="Formal" title="Client-Side Settings Used in OCSP Stapling" summary="This table shows the effects of different settings of PKIXBuilderParameters and the checkRevocation property (assume OCSP stapling is enabled in both the client and server)." frame="hsides" border="1" rules="rows">
                                 <thead>
                                    <tr align="left" valign="top">
                                       <th align="left" valign="bottom" id="d112429e6901">PKIXBuilderParameters</th>
                                       <th align="left" valign="bottom" id="d112429e6903">checkRevocation Property</th>
                                       <th align="left" valign="bottom" id="d112429e6905">PKIXRevocationChecker</th>
                                       <th align="left" valign="bottom" id="d112429e6907">Result</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" id="d112429e6911" headers="d112429e6901 ">Default</td>
                                       <td align="left" valign="top" headers="d112429e6911 d112429e6903 ">Default</td>
                                       <td align="left" valign="top" headers="d112429e6911 d112429e6905 ">Default</td>
                                       <td align="left" valign="top" headers="d112429e6911 d112429e6907 ">Revocation checking is disabled.</td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" id="d112429e6920" headers="d112429e6901 ">Default</td>
                                       <td align="left" valign="top" headers="d112429e6920 d112429e6903 ">True</td>
                                       <td align="left" valign="top" headers="d112429e6920 d112429e6905 ">Default</td>
                                       <td align="left" valign="top" headers="d112429e6920 d112429e6907 ">Revocation checking is enabled.<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-3A540C8F-5EB7-4E96-9051-92A1E2D8AF37__NOTETHATCLIENT-SIDEOCSPFALLBACKWILL-1B855C3C">[1]</a></td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" id="d112429e6932" headers="d112429e6901 ">Instantiated</td>
                                       <td align="left" valign="top" headers="d112429e6932 d112429e6903 ">Default</td>
                                       <td align="left" valign="top" headers="d112429e6932 d112429e6905 ">Default</td>
                                       <td align="left" valign="top" headers="d112429e6932 d112429e6907 ">Revocation checking is enabled.<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-3A540C8F-5EB7-4E96-9051-92A1E2D8AF37__NOTETHATCLIENT-SIDEOCSPFALLBACKWILL-1B855C3C">[1]</a></td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" id="d112429e6944" headers="d112429e6901 ">Instantiated</td>
                                       <td align="left" valign="top" headers="d112429e6944 d112429e6903 ">Default</td>
                                       <td align="left" valign="top" headers="d112429e6944 d112429e6905 ">Instantiated, added to <code class="codeph">PKIXBuilderParameters</code> object.
                                       </td>
                                       <td align="left" valign="top" headers="d112429e6944 d112429e6907 ">Revocation checking is enabled and<a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-3A540C8F-5EB7-4E96-9051-92A1E2D8AF37__NOTETHATCLIENT-SIDEOCSPFALLBACKWILL-1B855C3C">[1]</a>will behave according to the <code class="codeph">PKIXRevocationChecker</code> settings.
                                       </td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <!-- class="inftblhruleinformal" -->
                           <p id="GUID-3A540C8F-5EB7-4E96-9051-92A1E2D8AF37__NOTETHATCLIENT-SIDEOCSPFALLBACKWILL-1B855C3C">Footnote 1 Note that client-side OCSP fallback will occur only if the <code class="codeph">ocsp.enable</code> Security Property is set to <code class="codeph">true</code>.
                           </p>
                           <p>Developers have some flexibility in how to handle the responses provided through OCSP stapling. OCSP stapling makes no changes to the current methodologies involved in certificate path checking and revocation checking. This means that it is possible to have both client and server assert the&nbsp;<code class="codeph">status_request</code>&nbsp;extensions, obtain OCSP responses through the <code class="codeph">CertificateStatus</code>&nbsp;message, and provide user flexibility in how to react to revocation information, or the lack thereof.
                           </p>
                           <p>If no&nbsp;<code class="codeph">PKIXBuilderParameters</code>&nbsp;is provided by the caller, then revocation checking is disabled. If the caller creates a&nbsp;<code class="codeph">PKIXBuilderParameters</code>&nbsp;object and uses the&nbsp;<code class="codeph">setRevocationEnabled</code>&nbsp;method to enable revocation checking, then stapled OCSP responses will be evaluated. This is also the case if the&nbsp;<code class="codeph">com.sun.net.ssl.checkRevocation</code>&nbsp;property is set to&nbsp;<code class="codeph">true</code>. 
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-3151D7C3-7CE3-41B6-BF65-295B259C63A6" name="GUID-3151D7C3-7CE3-41B6-BF65-295B259C63A6"></a><h3 id="JSSEC-GUID-3151D7C3-7CE3-41B6-BF65-295B259C63A6" class="sect3">Hardware Acceleration and Smartcard Support</h3>
               <div>
                  <p></p>
                  <div class="section">
                     <p>The Java Cryptography Architecture (JCA) is a set of packages that provides a framework and implementations for encryption, key generation and key agreement, and message authentication code (MAC) algorithms. (See <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-2BCFDD85-D533-4E6C-8CE9-29990DEB0190" title='The Java Cryptography Architecture (JCA) is a major piece of the platform, and contains a "provider" architecture and a set of APIs for digital signatures, message digests (hashes), certificates and certificate validation, encryption (symmetric/asymmetric block/stream ciphers), key generation and management, and secure random number generation, to name a few.'>Java Cryptography Architecture (JCA) Reference Guide</a>.) The SunJSSE provider uses JCA exclusively for all of its cryptographic operations and can automatically take advantage of JCE features and enhancements, including JCA's support for RSA <a href="http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/pkcs-11-cryptographic-token-interface-standard.htm" target="_blank">PKCS#11</a>. This support enables the SunJSSE provider to use hardware cryptographic accelerators for significant performance improvements and to use smartcards as keystores for greater flexibility in key and trust management. .
                     </p>
                     <p>Use of hardware cryptographic accelerators is automatic if JCA has been configured to use the Oracle PKCS#11 provider, which in turn has been configured to use the underlying accelerator hardware. The provider must be configured before any other JCA providers in the provider list. For details on how to configure the Oracle PKCS#11 provider, see <a href="pkcs11-reference-guide1.html#GUID-30E98B63-4910-40A1-A6DD-663EAF466991">PKCS#11 Reference Guide</a>.
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div class="sect3"><a id="GUID-3412BD4D-9B6F-4FF0-A11C-ABA5945B40AE" name="GUID-3412BD4D-9B6F-4FF0-A11C-ABA5945B40AE"></a><h4 id="JSSEC-GUID-3412BD4D-9B6F-4FF0-A11C-ABA5945B40AE" class="sect4">Configuring JSSE to Use Smartcards as Keystores and Truststores</h4>
                  <div>
                     <p></p>
                     <p>Support for PKCS#11 in JCA also enables access to smartcards as a keystore. For details on how to configure the type and location of the keystores to be used by JSSE, see <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9" title="JSSE includes a standard implementation that can be customized by plugging in different implementations or specifying the default keystore, and so on.">Customizing JSSE</a>. To use a smartcard as a keystore or truststore, set the <code class="codeph">javax.net.ssl.keyStoreType</code> and <code class="codeph">javax.net.ssl.trustStoreType</code> system properties, respectively, to <code class="codeph">pkcs11</code>, and set the <code class="codeph">javax.net.ssl.keyStore</code> and <code class="codeph">javax.net.ssl.trustStore</code> system properties, respectively, to <code class="codeph">NONE</code>. To specify the use of a specific provider, use the <code class="codeph">javax.net.ssl.keyStoreProvider</code> and <code class="codeph">javax.net.ssl.trustStoreProvider</code> system properties (for example, set them to <code class="codeph">SunPKCS11-joe</code>). By using these properties, you can configure an application that previously depended on these properties to access a file-based keystore to use a smartcard keystore with no changes to the application.
                     </p>
                     <p>Some applications request the use of keystores programmatically. These applications can continue to use the existing APIs to instantiate a <code class="codeph">Keystore</code> and pass it to its key manager and trust manager. If the <code class="codeph">Keystore</code> instance refers to a PKCS#11 keystore backed by a Smartcard, then the JSSE application will have access to the keys on the smartcard.
                     </p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-C236C41B-54CA-4095-986B-7C62BBC419FB" name="GUID-C236C41B-54CA-4095-986B-7C62BBC419FB"></a><h4 id="JSSEC-GUID-C236C41B-54CA-4095-986B-7C62BBC419FB" class="sect4">Multiple and Dynamic Keystores</h4>
                  <div>
                     <p>Smartcards (and other removable tokens) have additional requirements for an <code class="codeph">X509KeyManager</code>. Different smartcards can be present in a smartcard reader during the lifetime of a Java application, and they can be protected using different passwords.
                     </p>
                     <p>The <a href="https://docs.oracle.com/javase/10/docs/api/java/security/KeyStore.Builder.html" target="_blank"><code class="codeph">KeyStore.Builder</code></a> class abstracts the construction and initialization of a <code class="codeph">KeyStore</code> object. It supports the use of <code class="codeph">CallbackHandler</code> for password prompting, and its subclasses can be used to support additional features as desired by an application. For example, it is possible to implement a <code class="codeph">Builder</code> that allows individual <code class="codeph">KeyStore</code> entries to be protected with different passwords. The <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/KeyStoreBuilderParameters.html" target="_blank"><code class="codeph">KeyStoreBuilderParameters</code></a> class then can be used to initialize a <code class="codeph">KeyManagerFactory</code> using one or more of these <code class="codeph">Builder</code> objects.
                     </p>
                     <p>A <code class="codeph">X509KeyManager</code> implementation in the SunJSSE provider called NewSunX509 supports these parameters. If multiple certificates are available, it attempts to pick a certificate with the appropriate key usage and prefers valid to expired certificates.
                     </p>
                     <p><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-C236C41B-54CA-4095-986B-7C62BBC419FB__IMPORTJAVAX.NET.SSL.IMPORTJAVA.SECU-6B0B77DA">Example 8-17</a> illustrates how to tell JSSE to use both a PKCS#11 keystore (which might in turn use a smartcard) and a PKCS#12 file-based keystore.
                     </p>
                     <div class="example" id="GUID-C236C41B-54CA-4095-986B-7C62BBC419FB__IMPORTJAVAX.NET.SSL.IMPORTJAVA.SECU-6B0B77DA">
                        <p class="titleinexample">Example 8-17 Sample Code to Use PKCS#11 and PKCS#12 File-based Keystore</p><pre class="codeblock"><code>import javax.net.ssl.*;
import java.security.KeyStore.*;
// ...

// Specify keystore builder parameters for PKCS#11 keystores
Builder scBuilder = Builder.newInstance("PKCS11", null,
    new CallbackHandlerProtection(myGuiCallbackHandler));

// Specify keystore builder parameters for a specific PKCS#12 keystore
Builder fsBuilder = Builder.newInstance("PKCS12", null,
    new File(pkcsFileName), new PasswordProtection(pkcsKsPassword));

// Wrap them as key manager parameters
ManagerFactoryParameters ksParams = new KeyStoreBuilderParameters(
    Arrays.asList(new Builder[] { scBuilder, fsBuilder }) );

// Create KeyManagerFactory
KeyManagerFactory factory = KeyManagerFactory.getInstance("NewSunX509");

// Pass builder parameters to factory
factory.init(ksParams);

// Use factory
SSLContext ctx = SSLContext.getInstance("TLS");
ctx.init(factory.getKeyManagers(), null, null);
</code></pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-93EBE6F4-1460-450A-8D9C-AF086C233BDF" name="GUID-93EBE6F4-1460-450A-8D9C-AF086C233BDF"></a><h3 id="JSSEC-GUID-93EBE6F4-1460-450A-8D9C-AF086C233BDF" class="sect3">Additional Keystore Formats (PKCS12)</h3>
               <div>
                  <p></p>
                  <p>The <a href="http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/pkcs12-personal-information-exchange-syntax-standard.htm" target="_blank">PKCS#12 (Personal Information Exchange Syntax Standard)</a> specifies a portable format for storage and/or transport of a user's private keys, certificates, miscellaneous secrets, and other items. The SunJSSE provider supplies a complete implementation of the PKCS12 <code class="codeph">java.security.KeyStore</code> format for reading and writing PKCS12 files. This format is also supported by other toolkits and applications for importing and exporting keys and certificates, such as Mozilla Firefox, Microsoft Internet Explorer, and OpenSSL. For example, these implementations can export client certificates and keys into a file using the .p12 file name extension.
                  </p>
                  <p>With the SunJSSE provider, you can access PKCS12 keys through the <code class="codeph">KeyStore</code> API with a keystore type of PKCS12. In addition, you can list the installed keys and associated certificates by using the <code class="codeph">keytool</code> command with the <code class="codeph">-storetype</code> option set to <code class="codeph">pkcs12</code>. See <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/java/javase/11/security&amp;id=JSWOR-GUID-5990A2E4-78E3-47B7-AE75-6D1826259549" target="_blank">keytool</a> in <span id="GUID-93EBE6F4-1460-450A-8D9C-AF086C233BDF__JSWOR"><cite>Java Platform, Standard Edition Tools Reference</cite></span>.
                  </p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F" name="GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F"></a><h3 id="JSSEC-GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F" class="sect3">Server Name Indication (SNI) Extension</h3>
               <div>
                  <p></p>
                  <p>The SNI extension is a feature that extends the TLS/DTLS protocol to indicate what server name the client is attempting to connect to during handshaking. Servers can use server name indication information to decide if specific <code class="codeph">SSLSocket</code> or <code class="codeph">SSLEngine</code> instances should accept a connection. For example, when multiple virtual or name-based servers are hosted on a single underlying network address, the server application can use SNI information to determine whether this server is the exact server that the client wants to access. Instances of this class can be used by a server to verify the acceptable server names of a particular type, such as host names. See section 3 of <a href="http://www.ietf.org/rfc/rfc6066.txt" target="_blank">TLS Extensions (RFC 6066)</a>.
                  </p>
                  <p>Developers of client applications can explicitly set the server name indication using the <code class="codeph">SSLParameters.setServerNames(List&lt;SNIServerName&gt; serverNames)</code> method. See <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F__GUID-B5160B29-A377-41C0-A60D-4A3E0C89CCAF">Example 8-18</a>.
                  </p>
                  <p>Developers of server applications can use the <code class="codeph">SNIMatcher</code> class to decide how to recognize server name indication. <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F__GUID-6EACE6B2-E1A4-4A8B-82B1-7C122495CF0D">Example 8-19</a> and <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F__GUID-E25CEBA5-2D07-484C-82EB-D280E32F7D08">Example 8-20</a> illustrate this functionality:
                  </p>
                  <div class="example" id="GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F__GUID-B5160B29-A377-41C0-A60D-4A3E0C89CCAF">
                     <p class="titleinexample">Example 8-18 Sample Code to Set the Server Name Indication</p>
                     <p>The following code sample illustrates how to set the server name indication using the method <span class="apiname">SSLParameters.setServerNames(List&lt;SNIServerName&gt; serverNames)</span>:
                     </p><pre class="pre codeblock"><code>SSLSocketFactory factory = ...
SSLSocket sslSocket = factory.createSocket("172.16.10.6", 443);
// SSLEngine sslEngine = sslContext.createSSLEngine("172.16.10.6", 443);

SNIHostName serverName = new SNIHostName("www.example.com");
List&lt;SNIServerName&gt; serverNames = new ArrayList&lt;&gt;(1);
serverNames.add(serverName);

SSLParameters params = sslSocket.getSSLParameters();
params.setServerNames(serverNames);
sslSocket.setSSLParameters(params);
// sslEngine.setSSLParameters(params);</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F__GUID-6EACE6B2-E1A4-4A8B-82B1-7C122495CF0D">
                     <p class="titleinexample">Example 8-19 Sample Code Using SSLSocket Class to Recognize SNI</p>
                     <p>The following code sample illustrates how the server applications can use the <code class="codeph">SNIMatcher</code> class to decide how to recognize server name indication:
                     </p><pre class="codeblock"><code>SSLSocket sslSocket = sslServerSocket.accept();

SNIMatcher matcher = SNIHostName.createSNIMatcher("www\\.example\\.(com|org)");
Collection&lt;SNIMatcher&gt; matchers = new ArrayList&lt;&gt;(1);
matchers.add(matcher);

SSLParameters params = sslSocket.getSSLParameters();
params.setSNIMatchers(matchers);
sslSocket.setSSLParameters(params);
</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F__GUID-E25CEBA5-2D07-484C-82EB-D280E32F7D08">
                     <p class="titleinexample">Example 8-20 Sample Code Using SSLServerSocket Class to Recognize SNI</p>
                     <p>The following code sample illustrates how the server applications can use the <code class="codeph">SNIMatcher</code> class to decide how to recognize server name indication:
                     </p><pre class="codeblock"><code>
 
SSLServerSocket sslServerSocket = ...;

SNIMatcher matcher = SNIHostName.createSNIMatcher("www\\.example\\.(com|org)");
Collection&lt;SNIMatcher&gt; matchers = new ArrayList&lt;&gt;(1);
matchers.add(matcher);

SSLParameters params = sslServerSocket.getSSLParameters();
params.setSNIMatchers(matchers);
sslServerSocket.setSSLParameters(params);

SSLSocket sslSocket = sslServerSocket.accept();
</code></pre></div>
                  <!-- class="example" -->
                  <div class="section">
                     <p>The following list provides examples for the behavior of the <code class="codeph">SNIMatcher</code> when receiving various server name indication requests in the ClientHello message:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li> 
                           <p>Matcher configured to <code class="codeph">www\\.example\\.com</code>:
                           </p> 
                           <ul style="list-style-type: disc;">
                              <li>If the requested host name is <code class="codeph">www.example.com</code>, then it will be accepted and a confirmation will be sent in the ServerHello message.
                              </li>
                              <li>If the requested host name is <code class="codeph">www.example.org</code>, then it will be rejected with an <code class="codeph">unrecognized_name</code> fatal error.
                              </li>
                              <li>If there is no requested host name or it is empty, then the request will be accepted but no confirmation will be sent in the ServerHello message.</li>
                           </ul> 
                        </li>
                        <li> 
                           <p>Matcher configured to <code class="codeph">www\\.invalid\\.com</code>:
                           </p> 
                           <ul style="list-style-type: disc;">
                              <li>If the requested host name is <code class="codeph">www.example.com</code>, then it will be rejected with an <code class="codeph">unrecognized_name</code> fatal error.
                              </li>
                              <li>If the requested host name is <code class="codeph">www.example.org</code>, then it will be accepted and a confirmation will be sent in the ServerHello message.
                              </li>
                              <li>If there is no requested host name or it is empty, then the request will be accepted but no confirmation will be sent in the ServerHello message.</li>
                           </ul> 
                        </li>
                        <li> 
                           <p>Matcher is not configured:</p> 
                           <p>Any requested host name will be accepted but no confirmation will be sent in the ServerHello message.</p> 
                        </li>
                     </ul>
                     <p>For descriptions of new classes that implement the SNI extension, see:</p>
                     <ul style="list-style-type: disc;">
                        <li><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-651B5070-F586-4504-A6CD-8BEB2D928D47" title="The StandardConstants class is used to represent standard constants definitions in JSSE.">StandardConstants Class</a></li>
                        <li><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-ADD484B7-244A-4FBC-AEF0-96873890CD6B">SNIServerName Class</a></li>
                        <li><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-073F0493-3DB8-4388-818B-83E92021EF45">SNIMatcher Class</a></li>
                        <li><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-E10158C4-E808-41B7-9958-A119927743D8">SNIHostName Class</a></li>
                     </ul>
                     <p>For examples, see <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-63945B45-E909-483F-B3A9-E26586737383">Using the Server Name Indication (SNI) Extension</a>.
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-DC583ED6-06AD-435C-BC9C-763F4642B2B3" name="GUID-DC583ED6-06AD-435C-BC9C-763F4642B2B3"></a><h3 id="JSSEC-GUID-DC583ED6-06AD-435C-BC9C-763F4642B2B3" class="sect3">TLS Application Layer Protocol Negotiation</h3>
               <div>
                  <p>Negotiate an application protocol for a TLS connection with Application Layer Protocol Negotiation (ALPN).</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-DC583ED6-06AD-435C-BC9C-763F4642B2B3__GUID-6F20B77E-32EA-427D-8B6F-A9E8165CF339">What is ALPN?</p>
                     <p>Some applications might want or need to negotiate a shared application level value before a TLS handshake has completed. For example, HTTP/2 uses the Application Layer Protocol Negotiation mechanism to help establish which HTTP version ("h2", "spdy/3", "http/1.1") can or will be used on a particular TCP or UDP port. ALPN (<a href="https://www.rfc-editor.org/rfc/rfc7301.txt" target="_blank">RFC 7301</a>) does this without adding network round-trips between the client and the server. In the case of HTTP/2 the protocol must be established before the connection is negotiated, as client and server need to know what version of HTTP to use before they start communicating. Without ALPN it would not be possible to have application protocols HTTP/1 and HTTP/2 on the same port.
                     </p>
                     <p>The client uses the ALPN extension at the beginning of the TLS handshake to send a list of supported application protocols to the server as part of the <code class="codeph">ClientHello</code>. The server reads the list of supported application protocols in the <code class="codeph">ClientHello</code>, and determines which of the supported protocols it prefers. It then sends a <code class="codeph">ServerHello</code> message back to the client with the negotiation result. The message may contain either the name of the protocol that has been chosen or that no protocol has been chosen.
                     </p>
                     <p> The application protocol negotiation can thus be accomplished within the TLS handshake, without adding network round-trips, and allows the server to associate a different certificate with each application protocol, if desired. </p>
                     <p> Unlike many other TLS extensions, this extension does not establish properties of the session, only of the connection. That's why you'll find the negotiated values in the <code class="codeph">SSLSocket</code>/<code class="codeph">SSLEngine</code>, not the <code class="codeph">SSLSession</code>. When session resumption or session tickets are used (see <a href="http://www.rfc-editor.org/rfc/rfc5077.txt" target="_blank">TLS Session Resumption without Server-Side State</a>), the previously negotiated values are irrelevant, and only the values in the new handshake messages are considered.
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div class="sect3"><a id="GUID-CBFA212F-C726-4D58-A520-A4BE147D1290" name="GUID-CBFA212F-C726-4D58-A520-A4BE147D1290"></a><h4 id="JSSEC-GUID-CBFA212F-C726-4D58-A520-A4BE147D1290" class="sect4">Setting up ALPN on the Client</h4>
                  <div>
                     <p>Set the Application Layer Protocol Negotiation (ALPN) values supported by the client. During the handshake with the server, the server will read the client’s list of application protocols and will determine which is most suitable.</p>
                     <div class="section">
                        <p>For the client, use the <code class="codeph">SSLParameters.setApplicationProtocols(String[])</code> method, followed by the <code class="codeph">setSSLParameters</code> method of either <code class="codeph">SSLSocket</code> or <code class="codeph">SSLEngine</code> to set up the application protocols to send to the server.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-CBFA212F-C726-4D58-A520-A4BE147D1290__GUID-B3161CAE-62B4-48EE-A432-163199F08491">
                        <p class="titleinexample">Example 8-21 Sample Code for Setting and Getting ALPN Values in a Java Client </p>
                        <p>For example, here are the steps to set ALPN values of <code class="codeph">"three"</code> and <code class="codeph">"two"</code>, on the client. 
                        </p>
                        <p>To run the code the property <code class="codeph">javax.net.ssl.trustStore</code> must be set to a valid root certificate. (This can be done on the command line).
                        </p><pre class="pre codeblock"><code>import java.io.*; 
import java.util.*;
import javax.net.ssl.*; 
public class SSLClient {
    public static void main(String[] args) throws Exception {

        // Code for creating a client side SSLSocket
        SSLSocketFactory sslsf = (SSLSocketFactory) SSLSocketFactory.getDefault();
        SSLSocket sslSocket = (SSLSocket) sslsf.createSocket("localhost", 9999);

        // Get an SSLParameters object from the SSLSocket
        SSLParameters sslp = sslSocket.getSSLParameters();

        // Populate SSLParameters with the ALPN values
        // On the client side the order doesn't matter as
        // when connecting to a JDK server, the server's list takes priority
        String[] clientAPs = {"three", "two"};
        sslp.setApplicationProtocols(clientAPs);

        // Populate the SSLSocket object with the SSLParameters object
        // containing the ALPN values
        sslSocket.setSSLParameters(sslp);

        sslSocket.startHandshake();

        // After the handshake, get the application protocol that has been negotiated
        String ap = sslSocket.getApplicationProtocol();
        System.out.println("Application Protocol client side: \"" + ap + "\"");

        // Do simple write/read
        InputStream sslIS = sslSocket.getInputStream();
        OutputStream sslOS = sslSocket.getOutputStream();
        sslOS.write(280);
        sslOS.flush();
        sslIS.read();
        sslSocket.close();
    }
}</code></pre><p>When this code is run and sends a <code class="codeph">ClientHello</code> to a Java server that has set the ALPN values <code class="codeph">one</code>, <code class="codeph">two</code>, and <code class="codeph">three</code>, the output will be:
                        </p><pre class="pre codeblock"><code>Application Protocol client side: two</code></pre><p>It is also possible to check the results of the negotiation during handshaking. See <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-BB4A54B3-FBC2-4B32-91CA-A16F91467ED9" title="To determine the ALPN value that has been negotiated during the handshaking, create a custom KeyManager or TrustManager class, and include in this custom class a call to the getHandshakeApplicationProtocol method.">Determining Negotiated ALPN Value during Handshaking</a>.
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-59618539-24AD-431E-84E3-585C4C4BF4E5" name="GUID-59618539-24AD-431E-84E3-585C4C4BF4E5"></a><h4 id="JSSEC-GUID-59618539-24AD-431E-84E3-585C4C4BF4E5" class="sect4">Setting up Default ALPN on the Server</h4>
                  <div>
                     <p>Use the default ALPN mechanism to determine a suitable application protocol by setting ALPN values on the server.</p>
                     <div class="section">To use the default mechanism for ALPN on the server, populate an <code class="codeph">SSLParameters</code> object with the ALPN values you wish to set, and then use this <code class="codeph">SSLParameters</code> object to populate either the <code class="codeph">SSLSocket</code> object or the <code class="codeph">SSLEngine</code> object with these parameters as you have done when you set up ALPN on the client (see the section <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-CBFA212F-C726-4D58-A520-A4BE147D1290" title="Set the Application Layer Protocol Negotiation (ALPN) values supported by the client. During the handshake with the server, the server will read the client’s list of application protocols and will determine which is most suitable.">Setting up ALPN on the Client</a>). The first value of the ALPN values set on the server that matches any of the ALPN values contained in the <code class="codeph">ClientHello</code> will be chosen and returned to the client as part of the <code class="codeph">ServerHello</code>.
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-59618539-24AD-431E-84E3-585C4C4BF4E5__GUID-DE951D27-9578-429C-84F8-DED2C5A91DD3">
                        <p class="titleinexample">Example 8-22 Sample Code for Default ALPN Value Negotiation on the Server</p>
                        <p>Here is the code for a Java server that uses the default approach for protocol negotiation. To run the code the property <code class="codeph">javax.net.ssl.keyStore</code> must be set to a valid keystore. (This can be done on the command line, see <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-3D26386B-BC7A-41BB-AC70-80E6CD147D6F" title="The procedure as to how you can use the keytool utility to create a simple PKCS12 keystore suitable for use with JSSE.">Creating a Keystore to Use with JSSE</a>).
                        </p><pre class="pre codeblock"><code>import java.util.*; 
import javax.net.ssl.*; 
public class SSLServer {
    public static void main(String[] args) throws Exception {

        // Code for creating a server side SSLSocket
        SSLServerSocketFactory sslssf = 
            (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();
        SSLServerSocket sslServerSocket = 
            (SSLServerSocket) sslssf.createServerSocket(9999);
        SSLSocket sslSocket = (SSLSocket) sslServerSocket.accept();

        // Get an SSLParameters object from the SSLSocket
        SSLParameters sslp = sslSocket.getSSLParameters();

        // Populate SSLParameters with the ALPN values
        // As this is server side, put them in order of preference
        String[] serverAPs ={ "one", "two", "three" };
        sslp.setApplicationProtocols(serverAPs);

        // If necessary at any time, get the ALPN values set on the 
        // SSLParameters object with:
        // String serverAPs = sslp.setApplicationProtocols();

        // Populate the SSLSocket object with the ALPN values
        sslSocket.setSSLParameters(sslp);

        sslSocket.startHandshake();

        // After the handshake, get the application protocol that 
        // has been negotiated

        String ap = sslSocket.getApplicationProtocol();
        System.out.println("Application Protocol server side: \"" + ap + "\"");

        // Continue with the work of the server
        InputStream sslIS = sslSocket.getInputStream();
        OutputStream sslOS = sslSocket.getOutputStream();
        sslIS.read();
        sslOS.write(85);
        sslOS.flush();
        sslSocket.close();
    }
}</code></pre><div class="p">When this code is run and a Java client sends a <code class="codeph">ClientHello</code> with ALPN values <code class="codeph">three</code> and <code class="codeph">two</code>, the output is:<pre class="pre codeblock"><code>Application Protocol server side: two</code></pre>It is also possible to check the results of the negotiation during handshaking. See <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-BB4A54B3-FBC2-4B32-91CA-A16F91467ED9" title="To determine the ALPN value that has been negotiated during the handshaking, create a custom KeyManager or TrustManager class, and include in this custom class a call to the getHandshakeApplicationProtocol method.">Determining Negotiated ALPN Value during Handshaking</a>.
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-B17DF013-83BD-4A00-BF91-D9E1E0BE70D8" name="GUID-B17DF013-83BD-4A00-BF91-D9E1E0BE70D8"></a><h4 id="JSSEC-GUID-B17DF013-83BD-4A00-BF91-D9E1E0BE70D8" class="sect4">Setting up Custom ALPN on the Server</h4>
                  <div>
                     <p>Use the custom ALPN mechanism to determine a suitable application protocol by setting up a callback method. </p>
                     <div class="section">
                        <p>If you do not want to use the server’s default negotiation protocol, you can use the <code class="codeph">setHandshakeApplicationProtocolSelector</code> method of <code class="codeph">SSLEngine</code> or <code class="codeph">SSLSocket</code> to register a <code class="codeph">BiFunction</code> (lambda) callback that can examine the handshake state so far, and then make your selection based on the client’s list of application protocols and any other relevant information. For example, you may consider using the cipher suite suggested, or the Server Name Indication (SNI) or any other data you can obtain in making the choice. If custom negotiation is used, the values set by the <code class="codeph">setApplicationProtocols</code> method (default negotiation) will be ignored.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-B17DF013-83BD-4A00-BF91-D9E1E0BE70D8__GUID-DE951D27-9578-429C-84F8-DED2C5A91DD3">
                        <p class="titleinexample">Example 8-23 Sample Code for Custom ALPN Value Negotiation on the Server </p>
                        <p>Here is the code for a Java server that uses the custom mechanism for protocol negotiation. To run the code the property <code class="codeph">javax.net.ssl.keyStore</code> must be set to a valid certificate. (This can be done on the command line, see <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-3D26386B-BC7A-41BB-AC70-80E6CD147D6F" title="The procedure as to how you can use the keytool utility to create a simple PKCS12 keystore suitable for use with JSSE.">Creating a Keystore to Use with JSSE</a>).
                        </p><pre class="pre codeblock"><code>import java.util.*; 
import javax.net.ssl.*; 
public class SSLServer {
    public static void main(String[] args) throws Exception {

        // Code for creating a server side SSLSocket
        SSLServerSocketFactory sslssf =
            (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();
        SSLServerSocket sslServerSocket = 
            (SSLServerSocket) sslssf.createServerSocket(9999);
        SSLSocket sslSocket = (SSLSocket) sslServerSocket.accept();

        // Code to set up a callback function
        // Pass in the current&nbsp;SSLSocket&nbsp;to be inspected and client AP values
        sslSocket.setHandshakeApplicationProtocolSelector(
            (serverSocket, clientProtocols) -&gt; {
                SSLSession handshakeSession = serverSocket.getHandshakeSession();
                // callback function called with current SSLSocket and client AP values
                // plus any other useful information to help determine appropriate
                // application protocol. Here the protocol and ciphersuite are also
                // passed to the callback function.
                return chooseApplicationProtocol(
                    serverSocket,
                    clientProtocols,
                    handshakeSession.getProtocol(),
                    handshakeSession.getCipherSuite());
         }); 

        sslSocket.startHandshake();

        // After the handshake, get the application protocol that has been
        // returned from the callback method.

        String ap = sslSocket.getApplicationProtocol();
        System.out.println("Application Protocol server side: \"" + ap + "\"");

        // Continue with the work of the server
        InputStream sslIS = sslSocket.getInputStream();
        OutputStream sslOS = sslSocket.getOutputStream();
        sslIS.read();
        sslOS.write(85);
        sslOS.flush();
        sslSocket.close();
    }

    // The callback method. Note how the parameters match the call within 
    // the setHandshakeApplicationProtocolSelector method above.
    public static String chooseApplicationProtocol(SSLSocket serverSocket,
            List&lt;String&gt; clientProtocols, String protocol, String cipherSuite ) {
        // For example, check the cipher suite and return an application protocol
        // value based on that.
        if (cipherSuite.equals("&lt;--a_particular_ciphersuite--&gt;")) { 
            return "three";
        } else {
            return "";
        }
    } 
}</code></pre><p>If the cipher suite matches the one you specify in the condition statement when this code is run , then the value <code class="codeph">three</code> will be returned. Otherwise an empty string will be returned.
                        </p>
                        <p>Note that the <code class="codeph">BiFunction</code> object’s return value is a <code class="codeph">String</code>, which will be the application protocol name, or null to indicate that none of the advertised names are acceptable. If the return value is an empty&nbsp;<code class="codeph">String</code>&nbsp;then application protocol indications will not be used. If the return value is null (no value chosen) or is a value that was not advertised by the peer, the underlying protocol will determine what action to take. (For example, the server code will send a "no_application_protocol" alert and terminate the connection.)
                        </p>
                        <p>After handshaking completes on both client and server, you can check the result of the negotiation by calling the <code class="codeph">getApplicationProtocol</code> method on either the <code class="codeph">SSLSocket</code> object or the <code class="codeph">SSLEngine</code> object.
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-BB4A54B3-FBC2-4B32-91CA-A16F91467ED9" name="GUID-BB4A54B3-FBC2-4B32-91CA-A16F91467ED9"></a><h4 id="JSSEC-GUID-BB4A54B3-FBC2-4B32-91CA-A16F91467ED9" class="sect4">Determining Negotiated ALPN Value during Handshaking</h4>
                  <div>
                     <p>To determine the ALPN value that has been negotiated during the handshaking, create a custom <code class="codeph">KeyManager</code> or <code class="codeph">TrustManager</code> class, and include in this custom class a call to the <code class="codeph">getHandshakeApplicationProtocol</code> method.
                     </p>
                     <div class="section">
                        <p>There are some use cases where the selected ALPN and SNI values will affect the choices made by a <code class="codeph">KeyManager</code> or <code class="codeph">TrustManager</code>. For example, an application might want to select different certificate/private key sets depending on the attributes of the server and the chosen ALPN/SNI/ciphersuite values.
                        </p>
                        <p>The sample code given illustrates how to call the <code class="codeph">getHandshakeApplicationProtocol</code> method from within a custom <code class="codeph">X509ExtendedKeyManager</code> that you create and register as the <code class="codeph">KeyManager</code> object.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-BB4A54B3-FBC2-4B32-91CA-A16F91467ED9__GUID-57D815A8-4BF8-4F9F-9735-9240C4E6D718">
                        <p class="titleinexample">Example 8-24 Sample Code for a Custom KeyManager</p>
                        <p>This example shows the entire code for a custom <code class="codeph">KeyManager</code> that extends <code class="codeph">X509ExtendedKeyManager</code>. Most methods simply return the value returned from the <code class="codeph">KeyManager</code> class that is being wrapped by this <code class="codeph">MyX509ExtendedKeyManager</code> class. However the <code class="codeph">chooseServerAlias</code> method calls the <code class="codeph">getHandshakeApplicationProtocol</code> on the <code class="codeph">SSLSocket</code> object and therefore can determine the current negotiated ALPN value.
                        </p><pre class="pre codeblock"><code>

import java.net.Socket;
import java.security.*;
import javax.net.ssl.*;

public class MyX509ExtendedKeyManager extends X509ExtendedKeyManager {

    // X509ExtendedKeyManager is an abstract class so your new class 
    // needs to implement all the abstract methods in this class. 
    // The easiest way to do this is to wrap an existing KeyManager
    // and call its methods for each of the methods you need to implement.   

    X509ExtendedKeyManager akm;
    
    public MyX509ExtendedKeyManager(X509ExtendedKeyManager akm) {
        this.akm = akm;
    }

    @Override
    public String[] getClientAliases(String keyType, Principal[] issuers) {
        return akm.getClientAliases(keyType, issuers);
    }

    @Override
    public String chooseClientAlias(String[] keyType, Principal[] issuers, 
        Socket socket) {
        return akm.chooseClientAlias(keyType, issuers, socket);
    }

    @Override
    public String chooseServerAlias(String keyType, Principal[] issuers, 
        Socket socket) {
        
        // This method has access to a Socket, so it is possible to call the
        // getHandshakeApplicationProtocol method here. Note the cast from 
        // a Socket to an SSLSocket
        String ap = ((SSLSocket) socket).getHandshakeApplicationProtocol();
        System.out.println("In chooseServerAlias, ap is: " + ap);
        return akm.chooseServerAlias(keyType, issuers, socket);
    }

    @Override
    public String[] getServerAliases(String keyType, Principal[] issuers) {
        return akm.getServerAliases(keyType, issuers);
    }

    @Override
    public X509Certificate[] getCertificateChain(String alias) {
        return akm.getCertificateChain(alias);
    }

    @Override
    public PrivateKey getPrivateKey(String alias) {
        return akm.getPrivateKey(alias);
    }
}</code></pre><div class="p">When this code is registered as the <code class="codeph">KeyManager</code> for a Java server and a Java client sends a <code class="codeph">ClientHello</code> with ALPN values, the output will be:<pre class="pre codeblock"><code>    In chooseServerAlias, ap is: &lt;negotiated value&gt;</code></pre></div>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-BB4A54B3-FBC2-4B32-91CA-A16F91467ED9__GUID-264BBD9E-71BA-412C-AA77-EF0EC265D42B">
                        <p class="titleinexample">Example 8-25 Sample Code for Using a Custom KeyManager in a Java Server</p>
                        <p>This example shows a simple Java server that uses the default ALPN negotiation strategy and the custom <code class="codeph">KeyManager</code>, <code class="codeph">MyX509ExtendedKeyManager</code>, shown in the prior code sample.
                        </p><pre class="pre codeblock"><code>import java.io.*;
import java.util.*;
import javax.net.ssl.*;
import java.security.KeyStore;

public class SSLServerHandshake {
    
    public static void main(String[] args) throws Exception {
        SSLContext ctx = SSLContext.getInstance("TLS");

        // You need to explicitly create a create a custom KeyManager

        // Keystores
        KeyStore keyKS = KeyStore.getInstance("PKCS12");
        keyKS.load(new FileInputStream("serverCert.p12"), 
            "password".toCharArray());

        // Generate KeyManager
        KeyManagerFactory kmf = KeyManagerFactory.getInstance("PKIX");
        kmf.init(keyKS, "password".toCharArray());
        KeyManager[] kms = kmf.getKeyManagers();

        // Code to substitute MyX509ExtendedKeyManager
        if (!(kms[0] instanceof X509ExtendedKeyManager)) {
            throw new Exception("kms[0] not X509ExtendedKeyManager");
        }

        // Create a new KeyManager array and set the first index 
        // of the array to an instance of MyX509ExtendedKeyManager.
        // Notice how creating this object is done by passing in the 
        // existing default X509ExtendedKeyManager 
        kms = new KeyManager[] { 
            new MyX509ExtendedKeyManager((X509ExtendedKeyManager) kms[0])};

        // Initialize SSLContext using the new KeyManager
        ctx.init(kms, null, null);

        // Instead of using SSLServerSocketFactory.getDefault(), 
        // get a SSLServerSocketFactory based on the SSLContext
        SSLServerSocketFactory sslssf = ctx.getServerSocketFactory();
        SSLServerSocket sslServerSocket = 
            (SSLServerSocket) sslssf.createServerSocket(9999);
        SSLSocket sslSocket = (SSLSocket) sslServerSocket.accept();
        SSLParameters sslp = sslSocket.getSSLParameters();
        String[] serverAPs ={"one","two","three"};
        sslp.setApplicationProtocols(serverAPs);
        sslSocket.setSSLParameters(sslp);
        sslSocket.startHandshake();

        String ap = sslSocket.getApplicationProtocol();
        System.out.println("Application Protocol server side: \"" + ap + "\"");

        InputStream sslIS = sslSocket.getInputStream();
        OutputStream sslOS = sslSocket.getOutputStream();
        sslIS.read();
        sslOS.write(85);
        sslOS.flush();

        sslSocket.close();
        sslServerSocket.close();
    }
}</code></pre><p>With the custom <code class="codeph">X509ExtendedKeyManager</code> in place, when <code class="codeph">chooseServerAlias</code> is called during handshaking the <code class="codeph">KeyManager</code> has the opportunity to examine the negotiated application protocol value. In the case of the example shown, this value is output to the console.
                        </p>
                        <div class="p">For example, when this code is run and a Java client sends a <code class="codeph">ClientHello</code> with ALPN values <code class="codeph">three</code> and <code class="codeph">two</code>, the output will be:<pre class="pre codeblock"><code>Application Protocol server side: two</code></pre></div>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-6D774DB6-FD5C-4066-B144-C1F10E2DD742" name="GUID-6D774DB6-FD5C-4066-B144-C1F10E2DD742"></a><h4 id="JSSEC-GUID-6D774DB6-FD5C-4066-B144-C1F10E2DD742" class="sect4">ALPN Related Classes and Methods</h4>
                  <div>
                     <p>These classes and methods are used when working with Application Layer Protocol Negotiation (ALPN).</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-6D774DB6-FD5C-4066-B144-C1F10E2DD742__GUID-E9B3FDB8-8A17-4F18-BE6D-827117066FAF">Classes and Methods to Use </p>
                        <p><code class="codeph">SSLEngine</code> and <code class="codeph">SSLSocket</code> contain the same ALPN related methods and they have the same functionality.
                        </p>
                        <div class="tblformalwide" id="GUID-6D774DB6-FD5C-4066-B144-C1F10E2DD742__GUID-FE0C995B-14C9-493B-8716-D66B3FDD990A">
                           <table cellpadding="4" cellspacing="0" class="FormalWide" title summary="These methods enable the setting and getting of ALPN values." width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="20%" id="d112429e7760">Class</th>
                                    <th align="left" valign="bottom" width="40%" id="d112429e7762">Method</th>
                                    <th align="left" valign="bottom" width="40%" id="d112429e7764">Purpose</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d112429e7768" headers="d112429e7760 "><code class="codeph">SSLParameters</code></td>
                                    <td align="left" valign="top" width="40%" headers="d112429e7768 d112429e7762 "><code class="codeph">public String[] getApplicationProtocols();</code></td>
                                    <td align="left" valign="top" width="40%" headers="d112429e7768 d112429e7764 "><span class="bold">Client-side and server-side</span>: use the method to return a <code class="codeph">String</code> array containing each protocol set.
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d112429e7782" headers="d112429e7760 "><code class="codeph">SSLParameters</code></td>
                                    <td align="left" valign="top" width="40%" headers="d112429e7782 d112429e7762 "><code class="codeph">public void setApplicationProtocols([]&nbsp;protocols);</code></td>
                                    <td align="left" valign="top" width="40%" headers="d112429e7782 d112429e7764 ">
                                       <p><span class="bold">Client-side</span>: use the method to set the protocols that can be chosen by the server.
                                       </p>
                                       <p><span class="bold">Server-side</span>: use the method to set the protocols that the server can use. The String array should contain the protocols in order of preference.
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d112429e7798" headers="d112429e7760 "><code class="codeph">SSLEngine</code><p></p><code class="codeph">SSLSocket</code></td>
                                    <td align="left" valign="top" width="40%" headers="d112429e7798 d112429e7762 "><code class="codeph">public String getApplicationProtocol();</code></td>
                                    <td align="left" valign="top" width="40%" headers="d112429e7798 d112429e7764 "><span class="bold">Client-side and server-side</span>: use the method <span class="italic">after</span> TLS protocol negotiation has completed to return a <code class="codeph">String</code> containing the protocol that has been chosen for the connection.
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d112429e7818" headers="d112429e7760 "><code class="codeph">SSLEngine</code><p></p><code class="codeph">SSLSocket</code></td>
                                    <td align="left" valign="top" width="40%" headers="d112429e7818 d112429e7762 "><code class="codeph">public String getHandshakeApplicationProtocol();</code></td>
                                    <td align="left" valign="top" width="40%" headers="d112429e7818 d112429e7764 "><span class="bold">Client-side and server-side</span>: use the method <span class="italic">during</span> handshaking to return a <code class="codeph">String</code> containing the protocol that has been chosen for the connection. If this method is called before or after handshaking, it will return null. See <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-BB4A54B3-FBC2-4B32-91CA-A16F91467ED9" title="To determine the ALPN value that has been negotiated during the handshaking, create a custom KeyManager or TrustManager class, and include in this custom class a call to the getHandshakeApplicationProtocol method.">Determining Negotiated ALPN Value during Handshaking</a> for instructions on how to call this method.
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d112429e7854" headers="d112429e7760 "><code class="codeph">SSLEngine</code><p></p><code class="codeph">SSLSocket</code></td>
                                    <td align="left" valign="top" width="40%" headers="d112429e7854 d112429e7762 "><code class="codeph">public void setHandshakeApplicationProtocolSelector(BiFunction,String&gt; selector)</code></td>
                                    <td align="left" valign="top" width="40%" headers="d112429e7854 d112429e7764 "><span class="bold">Server-side</span>: use the method to register a callback function. The application protocol value can then be set in the callback based on any information available, for example the protocol or cipher suite. See <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-B17DF013-83BD-4A00-BF91-D9E1E0BE70D8" title="Use the custom ALPN mechanism to determine a suitable application protocol by setting up a callback method.">Setting up Custom ALPN on the Server</a> for instructions on how to use this method.
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-D8F6E432-12F2-47B8-9FD0-CE57A4A4F2E1" name="GUID-D8F6E432-12F2-47B8-9FD0-CE57A4A4F2E1"></a><h3 id="JSSEC-GUID-D8F6E432-12F2-47B8-9FD0-CE57A4A4F2E1" class="sect3">Troubleshooting JSSE</h3>
               <div>
                  <p></p>
                  <p>This section contains information for troubleshooting JSSE. First, it provides some common <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-E8E3C6C4-5B7E-466F-B11C-35BF3B9F454D" title="Solutions to some common configuration problems.">Configuration Problems</a> and ways to solve them, and then it describes helpful <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-31B7E142-B874-46E9-8DD0-4E18EC0EB2CF">Debugging Utilities</a>.
                  </p>
               </div>
               <div class="sect3"><a id="GUID-E8E3C6C4-5B7E-466F-B11C-35BF3B9F454D" name="GUID-E8E3C6C4-5B7E-466F-B11C-35BF3B9F454D"></a><h4 id="JSSEC-GUID-E8E3C6C4-5B7E-466F-B11C-35BF3B9F454D" class="sect4">Configuration Problems</h4>
                  <div>
                     <p>Solutions to some common configuration problems.</p>
                  </div>
                  <div class="sect4"><a id="GUID-9872E8EC-DD07-4143-95AF-7C70A60F0521" name="GUID-9872E8EC-DD07-4143-95AF-7C70A60F0521"></a><h5 id="JSSEC-GUID-9872E8EC-DD07-4143-95AF-7C70A60F0521" class="sect5">SSLHandshakeException: No Available Authentication Scheme, Handshake Failure</h5>
                     <div>
                        <p><span class="bold">Problem:</span> The server throws this exception:
                        </p><pre class="pre codeblock"><code>javax.net.ssl.SSLHandshakeException: No available authentication scheme</code></pre><p>The client then receives a fatal alert:</p><pre class="pre codeblock"><code>javax.net.ssl.SSLHandshakeException: Received fatal alert: handshake_failure</code></pre><p><span class="bold">Cause:</span> The server throws this <span class="apiname">SSLHandshakeException</span> if TLSv1.3 is chosen as the protocol version and only DSA certificates are available in the server’s keymanager. Verify this with the keytool command; change <code>testkeys.dsa</code> to the name of your keystore:
                        </p><pre class="pre codeblock"><code><span class="bold">keytool -list -keystore testkeys.dsa -v</span>

Enter keystore password:
Keystore type: PKCS12
Keystore provider: SUN

Your keystore contains 1 entry

Alias name: localhost
Creation date: Sep 19, 2018
Entry type: PrivateKeyEntry
Certificate chain length: 1
Certificate[1]: Owner: CN=localhost, OU=Widget, O=Ficticious, L=Sunnyvale, ST=CA, C=US Issuer: CN=localhost, OU=Widget, O=Ficticious, L=Sunnyvale, ST=CA, C=US

<span class="italic">...deleted...</span>

Signature algorithm name: SHA256withDSA
Subject Public Key Algorithm: 2048-bit DSA key

<span class="italic">...deleted...</span>
</code></pre><p><span class="bold">Solution:</span> Update your certificates so that they contain RSA or EC public keys.
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-E87F514E-A7E8-4E79-90DE-D375FF64A908" name="GUID-E87F514E-A7E8-4E79-90DE-D375FF64A908"></a><h5 id="JSSEC-GUID-E87F514E-A7E8-4E79-90DE-D375FF64A908" class="sect5">CertificateException While Handshaking</h5>
                     <div>
                        <p></p>
                        <p><span class="bold">Problem:</span> When negotiating an TLS/DTLS connection, the client or server throws a <code class="codeph">CertificateException</code>.
                        </p>
                        <p><span class="bold">Cause 1:</span> This is generally caused by the remote side sending a certificate that is unknown to the local side.
                        </p>
                        <p><span class="bold">Solution 1:</span> The best way to debug this type of problem is to turn on debugging (see <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-31B7E142-B874-46E9-8DD0-4E18EC0EB2CF">Debugging Utilities</a>) and watch as certificates are loaded and when certificates are received via the network connection. Most likely, the received certificate is unknown to the trust mechanism because the wrong trust file was loaded.
                        </p>
                        <p>Refer to the following sections:</p>
                        <ul style="list-style-type: disc;">
                           <li><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-B7AB25FA-7F0C-4EFA-A827-813B2CE7FBDC">JSSE Classes and Interfaces</a></li>
                           <li><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-42CA1099-42AD-4772-BC4A-29C2A78E3EC9" title="The primary responsibility of the TrustManager is to determine whether the presented authentication credentials should be trusted. If the credentials are not trusted, then the connection will be terminated. To authenticate the remote identity of a secure socket peer, you must initialize an SSLContext object with one or more TrustManager objects. You must pass one TrustManager for each authentication mechanism that is supported. If null is passed into the SSLContext initialization, then a trust manager will be created for you. Typically, a single trust manager supports authentication based on X.509 public key certificates (for example, X509TrustManager). Some secure socket implementations may also support authentication based on shared secret keys, Kerberos, or other mechanisms.">TrustManager Interface</a></li>
                           <li><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-997AB098-DDD7-40E2-9FD0-5AA3C83E1702">KeyManager Interface</a></li>
                        </ul>
                        <p><span class="bold">Cause 2:</span> The system clock is not set correctly. In this case, the perceived time may be outside the validity period on one of the certificates, and unless the certificate can be replaced with a valid one from a truststore, the system must assume that the certificate is invalid, and therefore throw the exception.
                        </p>
                        <p><span class="bold">Solution 2:</span> Correct the system clock time.
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-48170215-4EF1-4653-B58F-81572E9FE23F" name="GUID-48170215-4EF1-4653-B58F-81572E9FE23F"></a><h5 id="JSSEC-GUID-48170215-4EF1-4653-B58F-81572E9FE23F" class="sect5">Runtime Exception: SSL Service Not Available</h5>
                     <div>
                        <p></p>
                        <div class="section">
                           <p><span class="bold">Problem:</span> When running a program that uses JSSE, an exception occurs indicating that an SSL service is not available. For example, an exception similar to one of the following is thrown:
                           </p><pre class="codeblock"><code>    Exception in thread "main" java.net.SocketException:
        no SSL Server Sockets
    
    Exception in thread "main":
        SSL implementation not available
</code></pre><p><span class="bold">Cause:</span> There was a problem with <code class="codeph">SSLContext</code> initialization, for example, due to an incorrect password on a keystore or a corrupted keystore (a JDK vendor once shipped a keystore in an unknown format, and that caused this type of error).
                           </p>
                           <p><span class="bold">Solution:</span> Check initialization parameters. Ensure that any keystores specified are valid and that the passwords specified are correct. One way that you can check this is by trying to use <code class="codeph">keytool</code> to examine the keystores and the relevant contents. See <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/java/javase/11/security&amp;id=JSWOR-GUID-5990A2E4-78E3-47B7-AE75-6D1826259549" target="_blank">keytool</a> in <span id="GUID-48170215-4EF1-4653-B58F-81572E9FE23F__JSWOR"><cite>Java Platform, Standard Edition Tools Reference</cite></span>.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-92715704-80F4-431A-BF99-D583EE61C4AB" name="GUID-92715704-80F4-431A-BF99-D583EE61C4AB"></a><h5 id="JSSEC-GUID-92715704-80F4-431A-BF99-D583EE61C4AB" class="sect5">Runtime Exception: "No available certificate corresponding to the SSL cipher suites which are enabled"</h5>
                     <div>
                        <p></p>
                        <div class="section">
                           <p><span class="bold">Problem:</span> When trying to run a simple SSL server program, the following exception is thrown:
                           </p><pre class="codeblock"><code>    Exception in thread "main" javax.net.ssl.SSLException:
        No available certificate corresponding to the SSL cipher suites which are enabled...
</code></pre><p><span class="bold">Cause:</span> Various cipher suites require certain types of key material. For example, if an RSA cipher suite is enabled, then an RSA <code class="codeph">keyEntry</code> must be available in the keystore. If no such key is available, then this cipher suite cannot be used. This exception is thrown if there are no available key entries for all of the cipher suites enabled.
                           </p>
                           <p><span class="bold">Solution:</span> Create key entries for the various cipher suite types, or use an anonymous suite. Anonymous cipher suites are inherently dangerous because they are vulnerable to MITM (man-in-the-middle) attacks. See <a href="https://tools.ietf.org/html/rfc5246" target="_blank">RFC 5246: The Transport Layer Security (TLS) Protocol, Version 1.2</a>.
                           </p>
                           <p>Refer to the following sections to learn how to pass the correct keystore and certificates:</p>
                           <ul style="list-style-type: disc;">
                              <li><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-B7AB25FA-7F0C-4EFA-A827-813B2CE7FBDC">JSSE Classes and Interfaces</a></li>
                              <li><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150">Customizing the Default Keystores and Truststores, Store Types, and Store Passwords</a></li>
                              <li><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-93EBE6F4-1460-450A-8D9C-AF086C233BDF">Additional Keystore Formats (PKCS12)</a></li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-1409C7FD-0E15-4367-93F5-EB327099D8B5" name="GUID-1409C7FD-0E15-4367-93F5-EB327099D8B5"></a><h5 id="JSSEC-GUID-1409C7FD-0E15-4367-93F5-EB327099D8B5" class="sect5">Runtime Exception: No Cipher Suites in Common</h5>
                     <div>
                        <p></p>
                        <div class="section">
                           <p><span class="bold">Problem 1:</span> When handshaking, the client and/or server throw this exception.
                           </p>
                           <p><span class="bold">Cause 1:</span> Both sides of a TLS connection must agree on a common cipher suite. If the intersection of the client's cipher suite set with the server's cipher suite set is empty, then you will see this exception.
                           </p>
                           <p><span class="bold">Solution 1:</span> Configure the enabled cipher suites to include common cipher suites, and be sure to provide an appropriate <code class="codeph">keyEntry</code> for asymmetric cipher suites. Also see <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-92715704-80F4-431A-BF99-D583EE61C4AB">Runtime Exception: "No available certificate corresponding to the SSL cipher suites which are enabled"</a> in this section.)
                           </p>
                           <p><span class="bold">Problem 2:</span> When using Mozilla Firefox or Microsoft Internet Explorer to access files on a server that only has DSA-based certificates, a runtime exception occurs indicating that there are no cipher suites in common.
                           </p>
                           <p><span class="bold">Cause 2:</span> By default, <code class="codeph">keyEntries</code> created with <code class="codeph">keytool</code> use DSA public keys. If only DSA <code class="codeph">keyEntries</code> exist in the keystore, then only DSA-based cipher suites can be used. By default, Firefox and Internet Explorer send only RSA-based cipher suites. Because the intersection of client and server cipher suite sets is empty, this exception is thrown.
                           </p>
                           <p><span class="bold">Solution 2:</span> To interact with Firefox or Internet Explorer, you should create certificates that use RSA-based keys. To do this, specify the <code class="codeph">-keyalg</code> RSA option when using keytool. For example:
                           </p><pre class="codeblock"><code>keytool -genkeypair -alias duke -keystore testkeys -keyalg rsa
</code></pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-B20D551B-9558-43C5-94D8-BF5464C8F2B7" name="GUID-B20D551B-9558-43C5-94D8-BF5464C8F2B7"></a><h5 id="JSSEC-GUID-B20D551B-9558-43C5-94D8-BF5464C8F2B7" class="sect5">Socket Disconnected After Sending ClientHello Message</h5>
                     <div>
                        <p></p>
                        <div class="section">
                           <p><span class="bold">Problem:</span> A socket attempts to connect, sends a ClientHello message, and is immediately disconnected.
                           </p>
                           <p><span class="bold">Cause:</span> Some TLS servers will disconnect if a ClientHello message is received in a format they do not understand or with a protocol version number that they do not support.
                           </p>
                           <p><span class="bold">Solution</span>: Try adjusting the enabled protocols on the client side. This involves modifying or invoking some of the following system properties and methods:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>System property <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9__HTTPS.PROTOCOLS_PROPERTY"><code class="codeph">https.protocols</code></a> for the <code class="codeph"><a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/HttpsURLConnection.html" target="_blank"><code class="codeph">HttpsURLConnection</code></a></code> class
                              </li>
                              <li>System property <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9__JDK.TLS.CLIENT.PROTOCOLS_PROPERTY"><span class="apiname">jdk.tls.client.protocols</span></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLContext.html#getInstance-java.lang.String-" target="_blank"><code class="codeph">SSLContext.getInstance</code></a> method
                              </li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLEngine.html#setEnabledProtocols-java.lang.String:A-" target="_blank"><code class="codeph">SSLEngine.setEnabledProtocols</code></a> method
                              </li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLSocket.html#setEnabledProtocols-java.lang.String:A-" target="_blank"><code class="codeph">SSLSocket.setEnabledProtocols</code></a> method
                              </li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLParameters.html#setProtocols-java.lang.String:A-" target="_blank"><code class="codeph">SSLParameters.setProtocols</code></a> and <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLEngine.html#setProtocols-java.lang.String:A-" target="_blank"><code class="codeph">SSLEngine.setSSLParameters</code></a> methods
                              </li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLParameters.html#setProtocols-java.lang.String:A-" target="_blank"><code class="codeph">SSLParameters.setProtocols</code></a> and <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLSocket.html#setProtocols-java.lang.String:A-" target="_blank"><code class="codeph">SSLSocket.setSSLParameters</code></a> methods
                              </li>
                           </ul>
                           <p>For backwards compatibility, some TLS implementations (such as SunJSSE) can send TLS ClientHello messages encapsulated in the SSLv2 ClientHello format. The SunJSSE provider supports this feature. If you want to use this feature, add the "SSLv2Hello" protocol to the enabled protocol list, if necessary. (See Protocols in the <a href="oracle-providers.html#GUID-FE2D2E28-C991-4EF9-9DBE-2A4982726313" title="This document contains the technical details of the providers that are included in the JDK. It is assumed that readers have a strong understanding of the Java Cryptography Architecture and Provider Architecture.">JDK Providers</a>, which lists the protocols that are enabled by default for the SunJSSE provider.) 
                           </p>
                           <p>The TLS RFC standards require that implementations negotiate to the latest version both sides speak, but some non-conforming implementation simply hang up if presented with a version they don't understand. For example, some older server implementations that speak only SSLv3 will shutdown if TLSv1.2 is requested. In this situation, consider using a TLS version fallback scheme:</p>
                           <ol>
                              <li>Fall back from TLSv1.2 to TLSv1.1 if the server does not understand TLSv1.2.</li>
                              <li>Fall back from TLSv1.1 to TLSv1.0 if the previous step does not work.</li>
                           </ol>
                           <p>For example, if the enabled protocol list on the client is TLSv1, TLSv1.1, and TLSv1.2, a typical TLS version fallback scheme may look like:</p>
                           <ol>
                              <li>Try to connect to server. If server rejects the TLS connection request immediately, go to step 2.</li>
                              <li>Try the version fallback scheme by removing the highest protocol version (for example, TLSv1.2 for the first failure) in the enabled protocol list.</li>
                              <li>Try to connect to the server again. If server rejects the connection, go to step 2 unless there is no version to which the server can fall back.</li>
                              <li>If the connection fails and SSLv2Hello is not on the enabled protocol list, restore the enable protocol list and enable SSLv2Hello. (For example, the enable protocol list should be SSLv2Hello, TLSv1, TLSv1.1, and TLSv1.2.) Start again from step 1.</li>
                           </ol>
                           <div class="p">
                              <div class="infoboxnote" id="GUID-B20D551B-9558-43C5-94D8-BF5464C8F2B7__GUID-879D0C74-6202-47A4-A56F-1A971ABD230D">
                                 <p class="notep1">Note:</p>A fallback to a previous version normally means security strength downgrading to a weaker protocol. It is not suggested to use a fallback scheme unless it is really necessary, and you clearly know that the server does not support a higher protocol version.
                              </div>
                           </div>
                           <div class="infoboxnote" id="GUID-B20D551B-9558-43C5-94D8-BF5464C8F2B7__GUID-FF293B29-F33E-41EF-909A-6350B9D35E23">
                              <p class="notep1">Note:</p>As part of disabling SSLv3, some servers have also disabled SSLv2Hello, which means communications with SSLv2Hello-active clients (JDK 6u95) will fail. Starting with JDK 7, SSLv2Hello default to disabled on clients, enabled on servers.
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-85667451-803E-4E07-B366-00E19790595B" name="GUID-85667451-803E-4E07-B366-00E19790595B"></a><h5 id="JSSEC-GUID-85667451-803E-4E07-B366-00E19790595B" class="sect5">SunJSSE Cannot Find a JCA Provider That Supports a Required Algorithm and Causes a NoSuchAlgorithmException</h5>
                     <div>
                        <p></p>
                        <div class="section">
                           <p><span class="bold">Problem:</span> A handshake is attempted and fails when it cannot find a required algorithm. Examples might include:
                           </p><pre class="codeblock"><code>Exception in thread ...deleted...
    ...deleted...
    Caused by java.security.NoSuchAlgorithmException: Cannot find any
        provider supporting RSA/ECB/PKCS1Padding
</code></pre><p> or </p><pre class="codeblock"><code>Caused by java.security.NoSuchAlgorithmException: Cannot find any
    provider supporting AES/CBC/NoPadding
</code></pre><p><span class="bold">Cause:</span> SunJSSE uses JCE for all its cryptographic algorithms. If the SunJCE provider has been deregistered from the <code class="codeph">Provider</code> mechanism and an alternative implementation from JCE is not available, then this exception will be thrown.
                           </p>
                           <p><span class="bold">Solution:</span> Ensure that the SunJCE is available by checking that the provider is registered with the <code class="codeph">Provider</code> interface. Try to run the following code in the context of your SSL connection:
                           </p><pre class="codeblock"><code>import javax.crypto.*;

System.out.println("=====Where did you get AES=====");
Cipher c = Cipher.getInstance("AES/CBC/NoPadding");
System.out.println(c.getProvider());
</code></pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-BEA0A351-848D-4E0E-9B96-48B27FDED1BA" name="GUID-BEA0A351-848D-4E0E-9B96-48B27FDED1BA"></a><h5 id="JSSEC-GUID-BEA0A351-848D-4E0E-9B96-48B27FDED1BA" class="sect5">Exception Thrown When Obtaining Application Resources from a Virtual Host Web Server that Requires an SNI Extension</h5>
                     <div>
                        <p></p>
                        <div class="section">
                           <p><span class="bold">Problem:</span> If you receive an <code class="codeph">Exception</code> when trying to obtain application resources from your web server over TLS, and your web server is implemented as a virtual host that requires a valid Server Name Indication (SNI) extension (such as Apache HTTP Server) to distinguish the virtual host, then the web server might not be configured correctly.
                           </p>
                           <p><span class="bold">Cause:</span> Because Java SE supports the SNI extension in the JSSE client, the requested host name of the virtual server is included in the first message sent from the client to the server during the TLS handshake. The server may deny the client's request for a connection if the requested host name (the server name indication) does not match the expected server name, which should be specified in the virtual host's configuration. This triggers an TLS handshake unrecognized name alert, which results in an <code class="codeph">Exception</code> being thrown.
                           </p>
                           <p><span class="bold">Solution:</span> If the cause of the problem is <code class="codeph">javax.net.ssl.SSLProtocolException: handshake alert: unrecognized_name</code>, it is likely that the virtual host configuration for SNI is incorrect. If you are using Apache HTTP Server, see <a href="https://httpd.apache.org/docs/trunk/vhosts/name-based.html" target="_blank">Name-based Virtual Host Support</a> about configuring virtual hosts. In particular, ensure that the <code class="codeph">ServerName</code> directive is configured properly in a <code class="codeph">&lt;VirtualHost&gt;</code> block.
                           </p>
                           <p>See the following:</p>
                           <ul style="list-style-type: disc;">
                              <li><a href="https://wiki.apache.org/httpd/NameBasedSSLVHostsWithSNI" target="_blank">SSL with Virtual Hosts Using SNI</a> from <a href="https://wiki.apache.org/httpd/FrontPage" target="_blank">Apache HTTP Server Wiki</a></li>
                              <li><a href="https://httpd.apache.org/docs/trunk/ssl/ssl_faq.html" target="_blank">SSL/TLS Strong Encryption: FAQ</a> from <a href="https://httpd.apache.org/docs/" target="_blank">Apache HTTP Server Documentation</a></li>
                              <li><a href="https://www.ietf.org/rfc/rfc3546.txt" target="_blank">RFC 3546, Transport Layer Security (TLS) Extensions</a></li>
                              <li><a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=7194590" target="_blank">Bug 7194590: SSL handshaking error caused by virtual server misconfiguration</a></li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-001B7524-87A4-4085-B8EF-929E0503DBEC" name="GUID-001B7524-87A4-4085-B8EF-929E0503DBEC"></a><h5 id="JSSEC-GUID-001B7524-87A4-4085-B8EF-929E0503DBEC" class="sect5">IllegalArgumentException When RC4 Cipher Suites are Configured for DTLS</h5>
                     <div>
                        <p></p>
                        <div class="section">
                           <p><span class="bold">Problem: </span> An <code class="codeph">IllegalArgumentException</code> exception is thrown when RC4 cipher suite algorithm is specified in <code class="codeph">SSLEngine.setEnabledCipherSuites(String[] suites)</code> method and the <span class="apiname">SSLEngine</span> is a DTLS engine.
                           </p><pre class="codeblock"><code>sslContext = SSLContext.getInstance("DTLS");

// Create the engine
SSLEngine engine = sslContext.createSSLengine(hostname, port);

String enabledSuites[] = { "SSL_RSA_WITH_RC4_128_SHA" };
engine.setEnabledCipherSuites(enabledSuites);</code></pre><p><span class="bold">Cause:</span> According to <a href="http://tools.ietf.org/html/rfc4347" target="_blank">DTLS Version 1.0</a> and <a href="http://tools.ietf.org/html/rfc6347" target="_blank">DTLS Version 1.2</a>, RC4 cipher suites must not be used with DTLS.
                           </p>
                           <p><span class="bold">Solution:</span> Do not use RC4 based cipher suites for DTLS connections. See <span class="q">"JSSE Cipher Suite Names"</span> in <a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html" target="_blank">Java Security Standard Algorithm Names</a>.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-31B7E142-B874-46E9-8DD0-4E18EC0EB2CF" name="GUID-31B7E142-B874-46E9-8DD0-4E18EC0EB2CF"></a><h4 id="JSSEC-GUID-31B7E142-B874-46E9-8DD0-4E18EC0EB2CF" class="sect4">Debugging Utilities</h4>
                  <div>
                     <p></p>
                     <div class="section">
                        <p>The SunJSSE provider supports dynamic debug tracing. This is similar to the mechanism that debugs security library issues. The generic Java dynamic debug tracing support is accessed with the <code class="codeph">java.security.debug</code> system property, whereas the JSSE-specific dynamic debug tracing support is accessed with the <code class="codeph">javax.net.debug</code> system property.
                        </p>
                        <div class="p">
                           <div class="infoboxnote" id="GUID-31B7E142-B874-46E9-8DD0-4E18EC0EB2CF__GUID-0889B6AB-3EA2-4B6B-844D-652AFF24B968">
                              <p class="notep1">Note:</p>Currently, the SunJSSE provider uses the debug utility. There is no guarantee that other providers use the debug utility. If other providers support the debug utility, then the implementation and output may be different.&nbsp;There is no guarantee the debug utility will continue to exist or be the same (for example, have the same options or output format) in future releases.
                           </div>
                        </div>
                        <p>To view the options of the JSSE dynamic debug utility, use the following command-line option on the <code class="codeph">java</code> command, where <code class="codeph">MyApp</code> is an existing Java application: 
                        </p><pre class="codeblock"><code>java -Djavax.net.debug=help MyApp
</code></pre><div class="infoboxnote" id="GUID-31B7E142-B874-46E9-8DD0-4E18EC0EB2CF__GUID-E45A25FE-5D18-4728-9014-F977BD07BE7D">
                           <p class="notep1">Note:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>The <code class="codeph">MyApp</code> application will not run after the debug help information is printed, as the help code causes the application to exit.
                                 </p>
                              </li>
                              <li>
                                 <p>If you specify the value <code class="codeph">help</code> with either dynamic debug utility when running a program that does not use any classes that the utility was designed to debug, you will not get the debugging options.
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <p>The current options are:</p>
                        <ul style="list-style-type: disc;">
                           <li><code class="codeph">all</code>: Turn on all debugging
                           </li>
                           <li><code class="codeph">ssl</code>: Turn on SSL debugging
                           </li>
                        </ul>
                        <p>The following can be used with the <code class="codeph">ssl</code> option to select what type of debug information to print:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li><code class="codeph">defaultctx</code>: Print default SSL initialization
                           </li>
                           <li><code class="codeph">handshake</code>: Print each handshake message
                           </li>
                           <li><code class="codeph">keygen</code>: Print key generation data
                           </li>
                           <li><code class="codeph">keymanager</code>: Print key manager tracing
                           </li>
                           <li><code class="codeph">pluggability</code>: Print pluggability tracing
                           </li>
                           <li><code class="codeph">record</code>: Enable per-record tracing
                           </li>
                           <li><code class="codeph">respmgr</code>: Print status response manager tracing
                           </li>
                           <li><code class="codeph">session</code>: Print session activity
                           </li>
                           <li><code class="codeph">sessioncache</code>: Print session cache tracing
                           </li>
                           <li><code class="codeph">sslctx</code>: Print <code class="codeph">SSLContext</code> tracing
                           </li>
                           <li><code class="codeph">trustmanager</code>: Print trust manager tracing
                           </li>
                        </ul>
                        <p>Messages generated from the <code class="codeph">handshake</code> option can be widened with these options:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li><code class="codeph">data</code>: Hex dump of each handshake message
                           </li>
                           <li><code class="codeph">verbose</code>: Verbose handshake message printing
                           </li>
                        </ul>
                        <p>Messages generated from the <code class="codeph">record</code> option can be widened with these options:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li><code class="codeph">plaintext</code>: Hex dump of record plaintext
                           </li>
                           <li><code class="codeph">packet</code>: Print raw SSL/TLS packets
                           </li>
                        </ul>
                        <p>To enable JSSE-specific dynamic debug tracing, set the value of the <code class="codeph">javax.net.debug</code> system property (see <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-38CC6235-823B-49D7-A566-4BEA1B64C9C6">How to Specify a java.security.Security Property</a>) to either <code class="codeph">all</code> or <code class="codeph">ssl</code>. For the <code class="codeph">ssl</code> option, to specify additional options, specify them after the <code class="codeph">ssl</code> option. You do <span class="variable" translate="no">not</span> have to have a separator between options, although a separator such as a colon (<code class="codeph">:</code>) or a comma (<code class="codeph">,</code>) helps readability. It does not matter what separators you use, and the ordering of the option keywords is also not important.
                        </p>
                        <p>For an introduction to reading this debug information, see <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6">Debugging TLS Connections</a>.
                        </p>
                        <p>The following are examples of using the <code class="codeph">javax.net.debug</code> system property:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li> 
                              <p>To view all debugging messages:</p> <pre class="codeblock"><code>java -Djavax.net.debug=all MyApp        </code></pre></li>
                           <li> 
                              <p>To view the hexadecimal dumps of each handshake message (the colons are optional):</p> <pre class="codeblock"><code>java -Djavax.net.debug=ssl:handshake:data MyApp
</code></pre></li>
                           <li> 
                              <p>To view the hexadecimal dumps of each handshake message, and to print trust manager tracing (the commas are optional):</p> <pre class="codeblock"><code>java -Djavax.net.debug=ssl,handshake,data,trustmanager MyApp
</code></pre></li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div class="sect4"><a id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6" name="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6"></a><h5 id="JSSEC-GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6" class="sect5">Debugging TLS Connections</h5>
                     <div>
                        <p></p>
                        <div class="section">
                           <p>Understanding TLS connection problems can sometimes be difficult, especially when it is not clear what messages are actually being sent and received. JSSE has a built-in debug facility and is activated by the system property <code class="codeph">javax.net.debug</code>. To know more about <code class="codeph">javax.net.debug</code> System property, see <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-31B7E142-B874-46E9-8DD0-4E18EC0EB2CF">Debugging Utilities</a>.
                           </p>
                           <p>This section gives a brief overview of the debug output of the basic TLS 1.3 handshake.  To know more about the TLS protocol, see <a href="https://tools.ietf.org/html/rfc8446" target="_blank">RFC 8446: The Transport Layer Security (TLS) Protocol Version 1.3</a>.
                           </p>
                           <div class="infoboxnote" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-0F5C19B6-234B-4908-8E1D-C89FD8099480">
                              <p class="notep1">Note:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>Debug output information about all possible TLS handshake combinations and protocols is beyond the scope of this guide. Instead, refer to the relevant RFC for more detailed information about a particular version of TLS. See <a href="java-security-overview1.html#GUID-FCF419A7-B856-46DD-A36F-C6F88F9AF37F">TLS and DTLS Protocols</a> for a list of supported SSL/TLS/DTLS protocols and links to their respective RFCs.
                                    </p>
                                 </li>
                                 <li>
                                    <p>The output is non-standard and may change from release to release.</p>
                                 </li>
                              </ul>
                           </div>
                           <p>This example uses the default JSSE X509KeyManager and X509TrustManager, which also prints debug information about the keys and trusted certificates used during a connection. It uses the <code class="codeph">ClassFileServer</code> and <code class="codeph">SSLSocketClientWithClientAuth</code> sample applications from <span><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/samples/index.html" target="_blank">JSSE Sample Code</a> in the JDK 8 documentation</span>. <code class="codeph">ClassFileServer</code> is a simple HTTPS server that can require client authentication. <code class="codeph">SSLSocketClientWithClientAuth</code> demonstrates how to use the <span class="apiname">SSLSocket</span> class as a client to send an HTTP request and get a response from an HTTPS server. To make things simpler, both <code class="codeph">ClassFileServer</code> and <code class="codeph">SSLSocketClientWithClientAuth</code> are run from the same host.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-3E32411C-8496-4158-9E1B-CEEA96196C8D">Run ClassFileServer on localhost</p>
                           <p>The following command runs the <code class="codeph">ClassFileServer</code> application on <code class="codeph">localhost</code>, port 2002:
                           </p><pre class="pre codeblock"><code>java \
  -Djavax.net.ssl.trustStore=/<span class="variable" translate="no">my_home_directory</span>/jssesamples/samples/samplecacerts \
  -Djavax.net.ssl.trustStorePassword=changeit \
  ClassFileServer 2002 \
  /<span class="variable" translate="no">my_home_directory</span>/jssesamples/samples/ \
  TLS true</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-49CC4971-EF28-4B9D-B85D-22E60900BEB8">Run SSLSocketClientWithClientAuth on locahost</p>
                           <p>The following command runs the <code class="codeph">SSLSocketClientWithClientAuth</code> application on <code class="codeph">localhost</code>, port 2002. The application connects to the HTTPS server that you started with the previous command. It sends an HTTPS request to the server and receives the reply. Note that the command sets the value of the system property <code class="codeph">javax.net.debug</code> to <code class="codeph">all</code>, which turns on all debugging.
                           </p><pre class="pre codeblock"><code>java <span class="bold">-Djavax.net.debug=all</span> -Djavax.net.ssl.trustStore=/<span class="variable" translate="no">my_home_directory</span>/jssesamples/samples/samplecacerts SSLSocketClientWithClientAuth localhost 2002 /index.html</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-B00BF1DC-DF9C-456E-A3D1-A5BD823CDF50">Debug Output Format</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>Each line of the debug output contains the following information; each field is separated by a vertical bar (<code class="codeph">|</code>):
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>Logger name (<code class="codeph">System.getLogger("javax.net.ssl")</code>)
                              </li>
                              <li>Debug level (<code class="codeph">System.Logger.Level</code>)
                              </li>
                              <li>Thread ID (<code class="codeph">Thread.currentThread().getId()</code>)
                              </li>
                              <li>Thread name (<code class="codeph">Thread.currentThread().getName()</code>)
                              </li>
                              <li>Date and time</li>
                              <li>Caller (location of the logging call)</li>
                              <li>Message</li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-906070E2-CCDF-4918-B087-BC0C4B53E63E">Determine Client-Side and Server-Side Enabled Cipher Suites</p>
                           <p>The values of the system properties <code class="codeph">jdk.tls.client.cipherSuites</code> and <code class="codeph">jdk.tls.server.cipherSuites</code> are checked to determine the default enabled cipher suites; see <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-D61663E8-2405-4B2D-A1F1-B8C7EA2688DB" title="You can specify the default enabled cipher suites in your application or with the system properties jdk.tls.client.cipherSuites and jdk.tls.server.cipherSuites.">Specifying Default Enabled Cipher Suites</a> for more information about these system properties.
                           </p><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:46.990 EDT|SSLContextImpl.java:427|System property jdk.tls.client.cipherSuites is set to 'null'
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.026 EDT|SSLContextImpl.java:427|System property jdk.tls.server.cipherSuites is set to 'null'
...</code></pre><p>The values of these system properties are null, so the default enabled cipher suites are those that the SunJSSE provider enables by default; see <a href="oracle-providers.html#GUID-7093246A-31A3-4304-AC5F-5FB6400405E2">The SunJSSE Provider</a> in <a href="oracle-providers.html#GUID-FE2D2E28-C991-4EF9-9DBE-2A4982726313" title="This document contains the technical details of the providers that are included in the JDK. It is assumed that readers have a strong understanding of the Java Cryptography Architecture and Provider Architecture.">JDK Providers Documentation</a>.
                           </p>
                           <p>The value of <code class="codeph">jdk.tls.keyLimits</code> is checked to determine the limit of the amount of data an algorithm may encrypt with a specific set of keys; see <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-B970ADD6-1E9F-4C18-A26E-0679B50CC946" title="You can specify a limit on the amount of data an algorithm may encrypt with a specific set of keys with the jdk.tls.keyLimits Security Property. Once this limit is reached, a KeyUpdate post-handshake message is sent, which requests that the current set of keys be updated. This Security Property is only for symmetrical ciphers with TLS 1.3.">Limiting Amount of Data Algorithms May Encrypt with a Set of Keys</a>.
                           </p><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.124 EDT|SSLCipher.java:436|jdk.net.keyLimits:  entry = AES/GCM/NoPadding KeyUpdate 2^37. AES/GCM/NOPADDING:KEYUPDATE = 137438953472
...</code></pre><p>The debug output lists unsupported and disabled cipher suites:</p><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.150 EDT|SSLContextImpl.java:401|Ignore disabled cipher suite: TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA
javax.net.ssl|ALL|01|main|2018-08-18 01:04:47.150 EDT|SSLContextImpl.java:410|Ignore unsupported cipher suite: TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.152 EDT|SSLContextImpl.java:401|Ignore disabled cipher suite: TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA
...</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-092A8241-A891-4245-851C-8E947EFBDA7F">Initialize X509KeyManager</p>
                           <p>The X509KeyManager is initialized. It discovers that there is one keyEntry in the supplied KeyStore for a subject called "duke". If this application wants to authenticate itself, then the X509KeyManager searches its list of keyEntries for an appropriate credential.</p><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.224 EDT|SunX509KeyManagerImpl.java:164|found key for : duke (
  "certificate" : {
    "version"            : "v1",
    "serial number"      : "3B 0A FA 66",
    "signature algorithm": "MD5withRSA",
    "issuer"             : "CN=Duke, OU=Java Software, O="Sun Microsystems, Inc.", L=Cupertino, ST=CA, C=US",
    "not before"         : "2001-05-22 19:46:46.000 EDT",
    "not  after"         : "2011-05-22 19:46:46.000 EDT",
    "subject"            : "CN=Duke, OU=Java Software, O="Sun Microsystems, Inc.", L=Cupertino, ST=CA, C=US",
    "subject public key" : "RSA"}
)
...</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-5FC24518-15E0-4D7B-9A87-EE8A6CE6A5C8">Initialize a TrustManager</p>
                           <p>A TrustManager is initialized and it finds in the truststore several certificates from various Certificate Authorities (CAs). It also finds a self-signed certificate with a distinguished name “localhost”. A server that presents valid credentials (certificates) that chain back to a trusted certificate in the truststore will itself be trusted.</p><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.229 EDT|TrustStoreManager.java:112|trustStore is: /<span class="variable" translate="no">my_home_directory</span>/jssesamples/samples/samplecacerts
trustStore type is: pkcs12
trustStore provider is: 
the last modified time is: Tue Dec 11 06:43:38 EST 2012
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.229 EDT|TrustStoreManager.java:311|Reload the trust store
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.264 EDT|TrustStoreManager.java:318|Reload trust certs
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.266 EDT|TrustStoreManager.java:323|Reloaded 32 trust certs
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.322 EDT|X509TrustManagerImpl.java:79|adding as trusted certificates (
  "certificate" : {
    "version"            : "v1",
    "serial number"      : "00 9B 7E 06 49 A3 3E 62 B9 D5 EE 90 48 71 29 EF 57",
    "signature algorithm": "SHA1withRSA",
    "issuer"             : "CN=VeriSign Class 3 Public Primary Certification Authority - G3, OU="(c) 1999 VeriSign, Inc. - For authorized use only", OU=VeriSign Trust Network, O="VeriSign, Inc.", C=US",
    "not before"         : "1999-09-30 20:00:00.000 EDT",
    "not  after"         : "2036-07-16 19:59:59.000 EDT",
    "subject"            : "CN=VeriSign Class 3 Public Primary Certification Authority - G3, OU="(c) 1999 VeriSign, Inc. - For authorized use only", OU=VeriSign Trust Network, O="VeriSign, Inc.", C=US",
    "subject public key" : "RSA"},
  "certificate" : {
    "version"            : "v1",
    "serial number"      : "61 70 CB 49 8C 5F 98 45 29 E7 B0 A6 D9 50 5B 7A",
    "signature algorithm": "SHA1withRSA",
    "issuer"             : "CN=VeriSign Class 2 Public Primary Certification Authority - G3, OU="(c) 1999 VeriSign, Inc. - For authorized use only", OU=VeriSign Trust Network, O="VeriSign, Inc.", C=US",
    "not before"         : "1999-09-30 20:00:00.000 EDT",
    "not  after"         : "2036-07-16 19:59:59.000 EDT",
    "subject"            : "CN=VeriSign Class 2 Public Primary Certification Authority - G3, OU="(c) 1999 VeriSign, Inc. - For authorized use only", OU=VeriSign Trust Network, O="VeriSign, Inc.", C=US",
    "subject public key" : "RSA"},
...
  "certificate" : {
    "version"            : "v1",
    "serial number"      : "41 00 44 46",
    "signature algorithm": "MD5withRSA",
    "issuer"             : "CN=localhost, OU=Widget Development Group, O="Ficticious Widgets, Inc.", L=Sunnyvale, ST=CA, C=US",
    "not before"         : "2004-07-22 18:48:38.000 EDT",
    "not  after"         : "2011-05-22 18:48:38.000 EDT",
    "subject"            : "CN=localhost, OU=Widget Development Group, O="Ficticious Widgets, Inc.", L=Sunnyvale, ST=CA, C=US",
    "subject public key" : "RSA"},
...</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-07A51431-1E42-48E3-A511-21A0F97DA4EB">Perform Additional Initialization</p>
                           <p>The example performs additional initialization code, then connects to the server.</p><pre class="pre codeblock"><code>javax.net.ssl|ALL|01|main|2018-08-18 01:04:47.326 EDT|SSLContextImpl.java:115|trigger seeding of SecureRandom
javax.net.ssl|ALL|01|main|2018-08-18 01:04:47.524 EDT|SSLContextImpl.java:119|done seeding of SecureRandom
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.562 EDT|HandshakeContext.java:291|Ignore unsupported cipher suite: TLS_AES_128_GCM_SHA256 for TLS12
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.563 EDT|HandshakeContext.java:291|Ignore unsupported cipher suite: TLS_AES_256_GCM_SHA384 for TLS12
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.577 EDT|HandshakeContext.java:291|Ignore unsupported cipher suite: TLS_AES_128_GCM_SHA256 for TLS11
...</code></pre><p>The debug output also notifies you of disabled, unsupported, or unavailable extensions and signature algorithms:</p><pre class="pre codeblock"><code>javax.net.ssl|WARNING|01|main|2018-08-18 01:04:47.695 EDT|ServerNameExtension.java:255|Unable to indicate server name
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.695 EDT|SSLExtensions.java:235|Ignore, context unavailable extension: server_name
javax.net.ssl|WARNING|01|main|2018-08-18 01:04:47.703 EDT|SignatureScheme.java:282|Signature algorithm, ed25519, is not supported by the underlying providers
javax.net.ssl|WARNING|01|main|2018-08-18 01:04:47.704 EDT|SignatureScheme.java:282|Signature algorithm, ed448, is not supported by the underlying providers
javax.net.ssl|ALL|01|main|2018-08-18 01:04:47.724 EDT|SignatureScheme.java:358|Ignore disabled signature sheme: rsa_md5
javax.net.ssl|INFO|01|main|2018-08-18 01:04:47.724 EDT|AlpnExtension.java:161|No available application protocols
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.724 EDT|SSLExtensions.java:235|Ignore, context unavailable extension: application_layer_protocol_negotiation
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.725 EDT|SSLExtensions.java:235|Ignore, context unavailable extension: cookie
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.763 EDT|SSLExtensions.java:235|Ignore, context unavailable extension: renegotiation_info
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.763 EDT|PreSharedKeyExtension.java:606|No session to resume.
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.763 EDT|SSLExtensions.java:235|Ignore, context unavailable extension: pre_shared_key
...
</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-7DFE92F5-286D-4D9E-B5AD-BC0B3C978B38">Send ClientHello Message</p>
                           <p>The client sends a ClientHello message to the server. This message specifies the following:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Client version: For TLS 1.3, this has a fixed value, TLSv1.2; TLS 1.3 uses the extension supported_versions and not this field to negotiate protocol version</p>
                              </li>
                              <li>
                                 <p>Random: A random value used to initialize the cryptographic algorithms</p>
                              </li>
                              <li>
                                 <p>Session ID: Previous versions of TLS use this ID to support a session resumption feature</p>
                              </li>
                              <li>
                                 <p>Cipher Suites: The list of cipher suites that the client requests; depending on the enabled cipher suites, there may be a broad mix of cipher suite names, some of which are only for TLSv1.3 while others are for TLSv1.2 and earlier</p>
                              </li>
                              <li>
                                 <p>Compression methods: For TLS 1.3, this must have the value 0</p>
                              </li>
                              <li>
                                 <p>Extensions:</p>
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p>status_request: The client requests OCSP; see <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-E1A3A7C3-309A-4415-903B-B31C96F68C86" title="Use the Online Certificate Status Protocol (OCSP) to determine the X.509 certificate revocation status during the Transport Layer Security (TLS) handshake.">Client-Driven OCSP and OCSP Stapling</a></p>
                                    </li>
                                    <li>
                                       <p>supported_groups: Lists the named groups that the client supports for key exchange. These named groups include elliptic curve groups (ECDHE) and finite field groups (DHE). The ClientHello message must include this message if it’s using ECDHE or DHE key exchange. </p>
                                    </li>
                                    <li>
                                       <p>ec_point_formats: Lists the elliptical curve point formats that the client can parse; in this example, the client can parse uncompressed point formats only. Other formats include compressed and ansiX962_compressed_prime.</p>
                                    </li>
                                    <li>
                                       <p>signature algorithms: Lists which signature algorithms may be used in CertificateVerify messages</p>
                                    </li>
                                    <li>
                                       <p>signature_algorithms_cert: Lists which signature algorithms may be used in digital signatures</p>
                                    </li>
                                    <li>
                                       <p>status_request_v2: Enables clients to specify and support several certificate status methods. Note that this extension is deprecated for TLS 1.3.</p>
                                    </li>
                                    <li>
                                       <p>extended_master_secret: In TLS 1.2 and earlier, this extension requests that both sides digest larger parts of the handshake transcript into the master secret than the original version of the protocol did; see <a href="https://tools.ietf.org/html/rfc7627" target="_blank">RFC 7627</a>. The extension is included in TLS 1.3 handshakes in case a TLS 1.2 handshake is negotiated.
                                       </p>
                                    </li>
                                    <li>
                                       <p>supported_versions: Lists which versions of TLS the client supports. In particular, if the client requests TLS 1.3, then the client version field has the value TLSv1.2 and this extension contains the value TLSv1.3; if the client requests TLS 1.2, then the client version field has the value TLSv1.2 and this extension either doesn’t exist or contains the value TLSv1.2 but not the value TLSv1.3.</p>
                                    </li>
                                    <li>
                                       <p>psk_key_exchange_modes: Lists which key exchange modes that may be used with pre-shared keys (PSKs); in this example, the client supports PSK with (EC)DHE key establishment (psk_dhe_ke). In this mode, the client and server must supply values for the key_share extension.</p>
                                    </li>
                                    <li>
                                       <p>key_share: Lists cryptographic parameters for key exchange. It contains a field named client_shares that contains this list. Each item of this list contains two fields: group and key_exchange. This example contains key exchange information for the elliptical curve secp256r1.</p>
                                    </li>
                                 </ul>
                              </li>
                           </ul><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.769 EDT|ClientHello.java:633|Produced ClientHello handshake message (
"ClientHello": {
  "client version"      : "TLSv1.2",
  "random"              : "64 CF 68 A1 CF AB B1 6F 43 F6 DE 1B 49 49 DE 5A 42 9A 71 DD CB 9A E3 9F 32 00 E8 87 7A 00 DA C6",
  "session id"          : "02 0D BE 1B A4 5F F2 E8 B6 31 9D A4 EF F3 22 84 C3 58 0B 5C C0 57 0F A5 6D 8A 83 EB DC DA B1 B6",
  "cipher suites"       : "[TLS_AES_128_GCM_SHA256(0x1301), TLS_AES_256_GCM_SHA384(0x1302), TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384(0xC02C), TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256(0xC02B), TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384(0xC030), TLS_RSA_WITH_AES_256_GCM_SHA384(0x009D), TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384(0xC02E), TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384(0xC032), TLS_DHE_RSA_WITH_AES_256_GCM_SHA384(0x009F), TLS_DHE_DSS_WITH_AES_256_GCM_SHA384(0x00A3), TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256(0xC02F), TLS_RSA_WITH_AES_128_GCM_SHA256(0x009C), TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256(0xC02D), TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256(0xC031), TLS_DHE_RSA_WITH_AES_128_GCM_SHA256(0x009E), TLS_DHE_DSS_WITH_AES_128_GCM_SHA256(0x00A2), TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384(0xC024), TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384(0xC028), TLS_RSA_WITH_AES_256_CBC_SHA256(0x003D), TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384(0xC026), TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384(0xC02A), TLS_DHE_RSA_WITH_AES_256_CBC_SHA256(0x006B), TLS_DHE_DSS_WITH_AES_256_CBC_SHA256(0x006A), TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA(0xC00A), TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA(0xC014), TLS_RSA_WITH_AES_256_CBC_SHA(0x0035), TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA(0xC005), TLS_ECDH_RSA_WITH_AES_256_CBC_SHA(0xC00F), TLS_DHE_RSA_WITH_AES_256_CBC_SHA(0x0039), TLS_DHE_DSS_WITH_AES_256_CBC_SHA(0x0038), TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256(0xC023), TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256(0xC027), TLS_RSA_WITH_AES_128_CBC_SHA256(0x003C), TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256(0xC025), TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256(0xC029), TLS_DHE_RSA_WITH_AES_128_CBC_SHA256(0x0067), TLS_DHE_DSS_WITH_AES_128_CBC_SHA256(0x0040), TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA(0xC009), TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA(0xC013), TLS_RSA_WITH_AES_128_CBC_SHA(0x002F), TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA(0xC004), TLS_ECDH_RSA_WITH_AES_128_CBC_SHA(0xC00E), TLS_DHE_RSA_WITH_AES_128_CBC_SHA(0x0033), TLS_DHE_DSS_WITH_AES_128_CBC_SHA(0x0032), TLS_EMPTY_RENEGOTIATION_INFO_SCSV(0x00FF)]",
  "compression methods" : "00",
  "extensions"          : [
    "status_request (5)": {
      "certificate status type": ocsp
      "OCSP status request": {
        "responder_id": &lt;empty&gt;
        "request extensions": {
          &lt;empty&gt;
        }
      }
    },
    "supported_groups (10)": {
      "versions": [secp256r1, secp384r1, secp521r1, sect283k1, sect283r1, sect409k1, sect409r1, sect571k1, sect571r1, secp256k1, ffdhe2048, ffdhe3072, ffdhe4096, ffdhe6144, ffdhe8192]
    },
    "ec_point_formats (11)": {
      "formats": [uncompressed]
    },
    "signature_algorithms (13)": {
      "signature schemes": [ecdsa_secp256r1_sha256, ecdsa_secp384r1_sha384, ecdsa_secp512r1_sha512, rsa_pss_rsae_sha256, rsa_pss_rsae_sha384, rsa_pss_rsae_sha512, rsa_pss_pss_sha256, rsa_pss_pss_sha384, rsa_pss_pss_sha512, rsa_pkcs1_sha256, rsa_pkcs1_sha384, rsa_pkcs1_sha512, dsa_sha256, ecdsa_sha1, rsa_pkcs1_sha1, dsa_sha1]
    },
    "signature_algorithms_cert (50)": {
      "signature schemes": [ecdsa_secp256r1_sha256, ecdsa_secp384r1_sha384, ecdsa_secp512r1_sha512, rsa_pss_rsae_sha256, rsa_pss_rsae_sha384, rsa_pss_rsae_sha512, rsa_pss_pss_sha256, rsa_pss_pss_sha384, rsa_pss_pss_sha512, rsa_pkcs1_sha256, rsa_pkcs1_sha384, rsa_pkcs1_sha512, dsa_sha256, ecdsa_sha1, rsa_pkcs1_sha1, dsa_sha1]
    },
    "status_request_v2 (17)": {
      "cert status request": {
        "certificate status type": ocsp_multi
        "OCSP status request": {
          "responder_id": &lt;empty&gt;
          "request extensions": {
            &lt;empty&gt;
          }
        }
      }
    },
    "extended_master_secret (23)": {
      &lt;empty&gt;
    },
    "supported_versions (43)": {
      "versions": [TLSv1.3, TLSv1.2, TLSv1.1, TLSv1]
    },
    "psk_key_exchange_modes (45)": {
      "ke_modes": [psk_dhe_ke]
    },
    "key_share (51)": {
      "client_shares": [  
        {
          "named group": secp256r1
          "key_exchange": {
            0000: 04 1F 80 50 D9 C6 03 45   7B 59 0F A7 B6 9E AE 39  ...P...E.Y.....9
            0010: 37 BE B0 5B 09 D8 91 37   72 5D 2B 8E 01 0A 84 56  7..[...7r]+....V
            0020: 99 0D 37 49 8F 92 61 A9   D6 54 E1 3B EE D1 E8 D2  ..7I..a..T.;....
            0030: 92 22 F9 17 CE A7 F8 51   47 C9 1E 5C D6 59 0F 4F  .".....QG..\.Y.O
            0040: 55 
          }
        },
      ]
    }
  ]
}
)
...</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-4E2DAA95-0E80-4319-ADD6-49614E4CE119">Show Actual Data Sent and Read</p>
                           <p>The debug output shows the actual data sent to the raw output object (in this case, an OutputStream):</p><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.770 EDT|SSLSocketOutputRecord.java:217|WRITE: TLS13 handshake, length = 405
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.774 EDT|SSLSocketOutputRecord.java:231|Raw write (
  0000: 16 03 03 01 95 01 00 01   91 03 03 64 CF 68 A1 CF  ...........d.h..
  0010: AB B1 6F 43 F6 DE 1B 49   49 DE 5A 42 9A 71 DD CB  ..oC...II.ZB.q..
  0020: 9A E3 9F 32 00 E8 87 7A   00 DA C6 20 02 0D BE 1B  ...2...z... ....
...
</code></pre><p>Then, the debug output shows the raw data read from the input device (InputStream) before any processing has been performed:</p><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.862 EDT|SSLSocketInputRecord.java:215|READ: TLSv1.2 handshake, length = 155
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.863 EDT|SSLSocketInputRecord.java:474|Raw read (
  0000: 02 00 00 97 03 03 66 24   0F F6 6D 4A 0C 5A A1 23  ......f$..mJ.Z.#
  0010: F6 5D 4B 87 B1 6E AC 13   BB 4D C1 A4 0F F0 2C EF  .]K..n...M....,.
  0020: D7 4F 03 11 19 B1 20 02   0D BE 1B A4 5F F2 E8 B6  .O.... ....._...
...</code></pre><p>Whenever the client sends or reads a message, the debug output shows the raw data sent or read and how any messages (and their extensions) have been processed. The following sections omit these parts of the debug output.</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-70D10BBA-9A0A-45C5-A49F-4AC26CA9E5CC">Read ServerHello Message</p>
                           <p>At this point, TLS 1.3 has been negotiated. The server selects the TLS version and replies using a combination of the server version and the supported_versions extension. In this case, a TLSv1.3 protocol was indicated.</p>
                           <p>The ServerHello message specifies the following:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Server version: For TLS 1.3, this must have the value TLSv1.2; TLS 1.3 uses the extension supported_versions and not this field to indicate the negotiated protocol version</p>
                              </li>
                              <li>
                                 <p>Random: Also used to initialize the cryptographic algorithms</p>
                              </li>
                              <li>
                                 <p>Session ID: For TLS 1.3, this has the same value as the corresponding field of the ClientHello message</p>
                              </li>
                              <li>
                                 <p>Cipher suite: The selected cipher suite; in this example, it is TLS_AES_128_GCM_SHA256</p>
                              </li>
                              <li>
                                 <p>Compression methods: For TLS 1.3, this must have the value 0</p>
                              </li>
                              <li>
                                 <p>Extensions</p>
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p>supported_versions: Specifies which TLS version the server uses. Note that for TLS 1.3, the server must use the value of the ClientHello message’s supported_versions extension for version negotiation instead of the value of the client version field.</p>
                                    </li>
                                    <li>
                                       <p>key_share: The named group and key values for a ECDHE key exchange</p>
                                    </li>
                                 </ul>
                              </li>
                           </ul><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.863 EDT|SSLSocketInputRecord.java:251|READ: TLSv1.2 handshake, length = 155
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.867 EDT|ServerHello.java:862|Consuming ServerHello handshake message (
"ServerHello": {
  "server version"      : "TLSv1.2",
  "random"              : "66 24 0F F6 6D 4A 0C 5A A1 23 F6 5D 4B 87 B1 6E AC 13 BB 4D C1 A4 0F F0 2C EF D7 4F 03 11 19 B1",
  "session id"          : "02 0D BE 1B A4 5F F2 E8 B6 31 9D A4 EF F3 22 84 C3 58 0B 5C C0 57 0F A5 6D 8A 83 EB DC DA B1 B6",
  "cipher suite"        : "TLS_AES_128_GCM_SHA256(0x1301)",
  "compression methods" : "00",
  "extensions"          : [
    "supported_versions (43)": {
      "selected version": [TLSv1.3]
    },
    "key_share (51)": {
      "server_share": {
        "named group": secp256r1
        "key_exchange": {
          0000: 04 DE 5B 20 0E FD EB 6E   DA 70 C2 D0 FA 0D 4C 53  ..[ ...n.p....LS
          0010: 6D E1 9E 67 77 65 36 AF   B5 EB E6 D2 88 92 9B EE  m..gwe6.........
          0020: E4 97 A3 B3 C1 FB D8 29   3B 92 87 D2 B3 9E 3D AA  .......);.....=.
          0030: 14 99 1E 84 8F C2 E9 E3   E1 AC 9A 12 95 F0 26 B5  ..............&amp;.
          0040: 88 
        }
      },
    }
  ]
}
)
...</code></pre><p>The session is initialized:</p><pre class="pre codeblock"><code>javax.net.ssl|ALL|01|main|2018-08-18 01:04:47.873 EDT|SSLSessionImpl.java:203|Session initialized:  Session(1534568687873|TLS_AES_128_GCM_SHA256)
...</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-F3574858-FC6F-4225-800F-630FC0B2F338">Read EncryptedExtensions Message</p>
                           <p>At this point in the handshake, enough cryptographic information has been exchanged, and the remainder of the handshake will be performed encrypted.</p>
                           <p>The EncryptedExtensions message contains responses to ClientHello extensions that are not required to determine the cryptographic parameters, other than those that are specific to individual certificates; in this example, it returns the list of named groups that the client supports for key exchange.</p><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.942 EDT|EncryptedExtensions.java:171|Consuming EncryptedExtensions handshake message (
"EncryptedExtensions": [
  "supported_groups (10)": {
    "versions": [secp256r1, secp384r1, secp521r1, sect283k1, sect283r1, sect409k1, sect409r1, sect571k1, sect571r1, secp256k1, ffdhe2048, ffdhe3072, ffdhe4096, ffdhe6144, ffdhe8192]
  }
]
)
...</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-2164FC41-F6C2-480B-BCFD-A2260B92588E">Read Server’s CertificateRequest Message</p>
                           <p>The server sends the CertificateRequest message if certificate-based client authentication is desired. This message contains the desired parameters for that certificate. It specifies the following:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>certificate_request_context: A string that identifies the certificate request; the value of this field is of zero length unless it’s being used for post-handshake authentication</p>
                              </li>
                              <li>
                                 <p>Extensions: The following two extensions indicate which signature algorithms may be used in digital signatures:</p>
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p>signature_algorithms: Originally appearing in TLS 1.2, applies to signatures in CertificateVerify messages</p>
                                    </li>
                                    <li>
                                       <p>signature_algorithms_cert: Applies to signatures in certificates</p>
                                    </li>
                                 </ul>
                              </li>
                           </ul><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.947 EDT|CertificateRequest.java:864|Consuming CertificateRequest handshake message (
"CertificateRequest": {
  "certificate_request_context": "",
  "extensions": [
    "signature_algorithms (13)": {
      "signature schemes": [ecdsa_secp256r1_sha256, ecdsa_secp384r1_sha384, ecdsa_secp512r1_sha512, rsa_pss_rsae_sha256, rsa_pss_rsae_sha384, rsa_pss_rsae_sha512, rsa_pss_pss_sha256, rsa_pss_pss_sha384, rsa_pss_pss_sha512, rsa_pkcs1_sha256, rsa_pkcs1_sha384, rsa_pkcs1_sha512, dsa_sha256, ecdsa_sha1, rsa_pkcs1_sha1, dsa_sha1]
    },
    "signature_algorithms_cert (50)": {
      "signature schemes": [ecdsa_secp256r1_sha256, ecdsa_secp384r1_sha384, ecdsa_secp512r1_sha512, rsa_pss_rsae_sha256, rsa_pss_rsae_sha384, rsa_pss_rsae_sha512, rsa_pss_pss_sha256, rsa_pss_pss_sha384, rsa_pss_pss_sha512, rsa_pkcs1_sha256, rsa_pkcs1_sha384, rsa_pkcs1_sha512, dsa_sha256, ecdsa_sha1, rsa_pkcs1_sha1, dsa_sha1]
    }
  ]
}
)
...</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-3FE3E95C-CD56-4170-ABA4-502151FF69D3">Read Server’s Certificate Message</p>
                           <p>The Certificate message contains the authentication certificate and any other supporting certificates in the certificate chain. It specifies the following:</p>
                           <ul style="list-style-type: disc;">
                              <li>certificate_request_context: For server authentication, this field is empty</li>
                              <li>certificate_list: Contains a certificate chain signed by a signature algorithm advertised by the client. However, in this example, a self-signed certificate (a certificate whose subject and issue name are identical) was received. This same self-signed certificate was discovered earlier during initialization, so it will be trusted when the TrustManager is actually called to verify the received certificate.</li>
                           </ul>
                           <p>There are many different ways of establishing trust, so if the default X509TrustManager is not doing the types of trust management you need, you can supply your own X509TrustManager to SSLContext.</p><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:47.964 EDT|CertificateMessage.java:1148|Consuming server Certificate handshake message (
"Certificate": {
  "certificate_request_context": "",
  "certificate_list": [  
  {
    "certificate" : {
      "version"            : "v1",
      "serial number"      : "41 00 44 46",
      "signature algorithm": "MD5withRSA",
      "issuer"             : "CN=localhost, OU=Widget Development Group, O="Ficticious Widgets, Inc.", L=Sunnyvale, ST=CA, C=US",
      "not before"         : "2004-07-22 18:48:38.000 EDT",
      "not  after"         : "2011-05-22 18:48:38.000 EDT",
      "subject"            : "CN=localhost, OU=Widget Development Group, O="Ficticious Widgets, Inc.", L=Sunnyvale, ST=CA, C=US",
      "subject public key" : "RSA"}
    "extensions": {
      &lt;no extension&gt;
    }
  },
]
}
)
...</code></pre><p>The client recognizes this certificate and can trust it.</p><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:48.165 EDT|X509TrustManagerImpl.java:242|Found trusted certificate (
  "certificate" : {
    "version"            : "v1",
    "serial number"      : "41 00 44 46",
    "signature algorithm": "MD5withRSA",
    "issuer"             : "CN=localhost, OU=Widget Development Group, O="Ficticious Widgets, Inc.", L=Sunnyvale, ST=CA, C=US",
    "not before"         : "2004-07-22 18:48:38.000 EDT",
    "not  after"         : "2011-05-22 18:48:38.000 EDT",
    "subject"            : "CN=localhost, OU=Widget Development Group, O="Ficticious Widgets, Inc.", L=Sunnyvale, ST=CA, C=US",
    "subject public key" : "RSA"}
)
...</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-AB70F624-B04D-4D2F-9DAB-76A8E19B33AC">Read Server’s CertificateVerify Message</p>
                           <p>The certificate sent by the server is verified by the CertificateVerify message. The message is used to provide explicit proof that the server has the private key corresponding to its certificate. This message specifies the following:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Signature algorithm: The signature algorithm used; in this example, it is rsa_pss_rsae_sha256.</p>
                              </li>
                              <li>
                                 <p>Signature: The signature over the entire handshake using the private key corresponding to the public key in the Certificate message</p>
                              </li>
                           </ul><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:48.194 EDT|CertificateVerify.java:1128|Consuming CertificateVerify handshake message (
"CertificateVerify": {
  "signature algorithm": rsa_pss_rsae_sha256
  "signature": {
    0000: 0F 25 DD 62 03 6B 8C 8F   22 C7 8D 46 A2 A6 45 39  .%.b.k.."..F..E9
    0010: 08 8D 51 1E 48 52 66 A4   F8 28 D3 FD 18 93 70 C6  ..Q.HRf..(....p.
    0020: 32 74 C1 CC 0A C4 60 41   50 AF 7C DA 0C DB 92 F9  2t....`AP.......
    0030: 14 CB EF 15 7F 3E 52 16   F7 CC 8A 7C C9 1F 42 CA  .....&gt;R.......B.
    0040: 90 8D FA B7 F2 3A 46 7E   F7 9F 43 CE C6 AA 15 59  .....:F...C....Y
    0050: EE AD 34 10 FF B7 BC FD   A2 F7 F3 1A FA 7F 26 61  ..4...........&amp;a
    0060: 80 2B 50 3A 8A 9E 5C 0E   4C A6 24 DA E6 3D 71 FA  .+P:..\.L.$..=q.
    0070: AE 78 79 D2 DA 36 DE C1   A6 BC 18 46 04 CE 03 4E  .xy..6.....F...N
  }
}
)
...</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-586988CB-FCBF-495C-9651-DBCA787589AE">Read Server’s Finished Message</p>
                           <p>The server sends a Finished message. This message contains a Message Authentication Code (MAC) over the entire handshake.</p><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-17 01:56:26.764 EDT|Finished.java:860|Consuming server Finished handshake message (
"Finished": {
  "verify data": {
    0000: CA 7B 74 A6 79 36 ED 62   A7 0E 14 9D 9F D0 4A 0F  ..t.y6.b......J.
    0010: 02 4C 78 BB E2 89 A2 C6   E8 BD 28 CA E7 D9 DB 68  .Lx.......(....h
  }'}
)
...
</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-9BD61A81-99B4-46CB-97D7-8410C5830206">Send Certificate Message</p>
                           <p>The client sends a Certificate message because the server requested client authentication through a CertificateRequest message. The certificate message specifies similar information as the server’s Certificate message. The client needs to send credentials back to the sever, so its X509KeyManager is consulted. The client looks for a match between the list of accepted issuers and the certificates that are in the KeyStore. In this case, there is a match: the client has the credentials for "duke". It's now up to the server's X509TrustManager to decide whether to accept these credentials.</p><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:48.222 EDT|CertificateMessage.java:1116|Produced client Certificate message (
"Certificate": {
  "certificate_request_context": "",
  "certificate_list": [  
  {
    "certificate" : {
      "version"            : "v1",
      "serial number"      : "3B 0A FA 66",
      "signature algorithm": "MD5withRSA",
      "issuer"             : "CN=Duke, OU=Java Software, O="Sun Microsystems, Inc.", L=Cupertino, ST=CA, C=US",
      "not before"         : "2001-05-22 19:46:46.000 EDT",
      "not  after"         : "2011-05-22 19:46:46.000 EDT",
      "subject"            : "CN=Duke, OU=Java Software, O="Sun Microsystems, Inc.", L=Cupertino, ST=CA, C=US",
      "subject public key" : "RSA"}
    "extensions": {
      &lt;no extension&gt;
    }
  },
]
}
)
...</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-AC376873-60BB-4C61-9F37-9936860ED312">Send CertificateVerify Message</p>
                           <p>As with the CertificateVerify message sent by the server, the certificate sent by the client is verified by the CertificateVerify message. The message is used to provide explicit proof that the client has the private key corresponding to its certificate.</p><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:48.268 EDT|CertificateVerify.java:1097|Produced client CertificateVerify handshake message (
"CertificateVerify": {
  "signature algorithm": rsa_pss_rsae_sha256
  "signature": {
    0000: 91 C2 F7 5D 8D 90 B4 82   E4 BA C6 23 08 E2 B4 DD  ...].......#....
    0010: 8D 95 8F 9F 31 4F 26 F3   97 3B FB 5B 10 4D AE F6  ....1O&amp;..;.[.M..
    0020: 71 78 FB 7B 3A 4F F6 1B   BF D2 E3 FB BE 53 F6 70  qx..:O.......S.p
    0030: 7E 73 83 F4 9A 5E 08 19   63 C1 97 4C 10 B1 C7 3F  .s...^..c..L...?
    0040: 4A 7D EF 4A 30 44 15 9F   D0 F2 8B C4 D1 45 69 B1  J..J0D.......Ei.
    0050: D9 DB 45 83 C4 11 91 B3   81 5E 69 F4 5C 2A CF 69  ..E......^i.\*.i
    0060: D3 A6 7E 75 B4 C9 30 FB   5B AC BA 9F A3 C5 0C FD  ...u..0.[.......
    0070: 9A 62 A4 DA 5A 80 6B 72   CD F5 A5 53 AD 14 74 1C  .b..Z.kr...S..t.
  }
}
)</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-23D15A1E-731F-46BD-A55E-80BBBF815B89">Send Finished Message</p>
                           <p>The client then sends its Finished message to the sever:</p><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:48.271 EDT|Finished.java:658|Produced client Finished handshake message (
"Finished": {
  "verify data": {
    0000: 93 04 B5 23 8F 48 3A CF   4A 85 35 9E 5F E0 1D 4C  ...#.H:.J.5._..L
    0010: 9C 65 06 D4 E8 B4 ED 8F   01 6B 1E A2 DD 18 BD 78  .e.......k.....x
  }'}
)
...</code></pre><p>The client and server have verified the Finished messages that they have received from their peers. Both sides may now send and receive application data over the connection.</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-D712952D-0008-420C-B12D-5F8581E4FA11">Exchange Application Data, Client Sends GET Command</p>
                           <p>The server and client are ready to exchange application data. The client sends a "GET /index.html HTTP1.0" command.</p><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:48.375 EDT|SSLCipher.java:2019|Plaintext before ENCRYPTION (
  0000: 47 45 54 20 2F 69 6E 64   65 78 2E 68 74 6D 6C 20  GET /index.html 
  0010: 48 54 54 50 2F 31 2E 30   0D 0A 0D 0A 17 00 00 00  HTTP/1.0........
  0020: 00 00 00 00 00 00 00 00   00 00 00 00 00           .............
)
...</code></pre><p>Note that data over the wire is encrypted:</p><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:48.385 EDT|SSLSocketOutputRecord.java:295|Raw write (
  0000: 17 03 03 00 3D 90 BF D1   81 E6 A3 E7 DA 50 A9 8B  ....=........P..
  0010: 18 F5 4B 30 AE 59 41 81   25 C4 9E 3E 70 29 5D C6  ..K0.YA.%..&gt;p)].
  0020: 64 49 0B 4A 0E 93 E3 8F   DC 42 BA B5 21 42 38 88  dI.J.....B..!B8.
  0030: 62 4D 0C 86 FE 9A 8C B9   95 EF 89 93 61 3C 13 69  bM..........a&lt;.i
  0040: 6C 45                                              lE
)
...</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-4F657491-E51C-4C8B-8D19-6A23D7B4F3A3">Read NewSessionTicket Message</p>
                           <p>After the server receives the client’s Finished message, it can send a NewSessionTicket message anytime, which contains a PSK ticket that the client can use for speeding up future handshakes.</p><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:48.517 EDT|NewSessionTicket.java:330|Consuming NewSessionTicket message (
"NewSessionTicket": {
  "ticket_lifetime"      : "86,400",
  "ticket_age_add"       : "&lt;omitted&gt;",
  "ticket_nonce"         : "01",
  "ticket"               : "A5 30 8C B6 AD 95 79 E8 2A D1 95 C0 F0 2F 6F AA 9E 97 58 AA 3D 19 82 2D 2C 47 C0 ED BF 64 48 AB",
  "extensions"           : [
    &lt;no extension&gt;
  ]
}
)
</code></pre><p>A duplicate SSLSession is created with the newly generated PSK information attached.</p><pre class="pre codeblock"><code>javax.net.ssl|ALL|01|main|2018-08-18 01:04:48.517 EDT|SSLSessionImpl.java:203|Session initialized:  Session(1534568687873|TLS_AES_128_GCM_SHA256)
...</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-B52EE7D3-C65E-4961-9807-94DF4D51E2B6">Exchange Application Data, Server Sends HTTPS Header and Data</p>
                           <p>The client receives application data from the server, first the HTTPS header, then the actual data.</p><pre class="pre codeblock"><code>javax.net.ssl|ALL|01|main|2018-08-18 01:04:48.517 EDT|SSLSessionImpl.java:203|Session initialized:  Session(1534568687873|TLS_AES_128_GCM_SHA256)
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:48.617 EDT|SSLSocketInputRecord.java:474|Raw read (
  0000: 17 03 03 00 63                                     ....c
)
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:48.618 EDT|SSLSocketInputRecord.java:215|READ: TLSv1.2 application_data, length = 99
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:48.618 EDT|SSLSocketInputRecord.java:474|Raw read (
  0000: 65 87 0E 1E 78 F7 AC C4   F7 C6 4D 55 91 6F 72 CC  e...x.....MU.or.
  0010: 18 2D 74 C3 B6 7B 2A F9   EB 2B F4 A8 C7 FD 09 FA  .-t...*..+......
  0020: 7E 36 9D F7 88 E7 44 DD   60 AF EB B0 F8 CF E1 64  .6....D.`......d
  0030: 0D 9B F4 B0 24 C2 BC B1   BF F7 F2 B6 CB E4 2E 39  ....$..........9
  0040: 78 B8 73 09 91 65 7A 0F   4C 49 DE 9A 7F 7B 42 86  x.s..ez.LI....B.
  0050: CA 33 87 DB 0D B2 E5 61   3C 70 6F F9 6A 15 A9 74  .3.....a&lt;po.j..t
  0060: 64 E0 B0                                           d..
)
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:48.619 EDT|SSLSocketInputRecord.java:251|READ: TLSv1.2 application_data, length = 99
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:48.621 EDT|SSLCipher.java:1914|Plaintext after DECRYPTION (
  0000: 48 54 54 50 2F 31 2E 30   20 32 30 30 20 4F 4B 0D  HTTP/1.0 200 OK.
  0010: 0A 43 6F 6E 74 65 6E 74   2D 4C 65 6E 67 74 68 3A  .Content-Length:
  0020: 20 32 35 37 37 0D 0A 43   6F 6E 74 65 6E 74 2D 54   2577..Content-T
  0030: 79 70 65 3A 20 74 65 78   74 2F 68 74 6D 6C 0D 0A  ype: text/html..
  0040: 0D 0A                                              ..
)
...
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:48.626 EDT|SSLSocketInputRecord.java:215|READ: TLSv1.2 application_data, length = 2610
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:48.628 EDT|SSLSocketInputRecord.java:474|Raw read (
  0000: 69 8D F9 A3 E9 25 09 87   F0 E0 A1 63 12 9D 81 DF  i....%.....c....
  0010: 42 FC FA 7A 03 74 FD D5   ED 47 6C 5F 61 F2 BB 39  B..z.t...Gl_a..9
  0020: CF 64 0B B2 10 14 24 99   A3 66 8B D2 13 C9 66 FD  .d....$..f....f.
...
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:48.642 EDT|SSLSocketInputRecord.java:251|READ: TLSv1.2 application_data, length = 2610
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:48.647 EDT|SSLCipher.java:1914|Plaintext after DECRYPTION (
  0000: 3C 21 44 4F 43 54 59 50   45 20 68 74 6D 6C 20 50  &lt;!DOCTYPE html P
  0010: 55 42 4C 49 43 20 22 2D   2F 2F 57 33 43 2F 2F 44  UBLIC "-//W3C//D
  0020: 54 44 20 58 48 54 4D 4C   20 31 2E 30 20 54 72 61  TD XHTML 1.0 Tra
  0030: 6E 73 69 74 69 6F 6E 61   6C 2F 2F 45 4E 22 0A 20  nsitional//EN". 
...</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-95CFC30C-569C-45DD-8659-8C3ADA3C77B2">Read Server’s Alert Message</p>
                           <p>The server sends a close_notify alert, which notifies the client that it won’t send anymore messages on this connection.</p><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:48.658 EDT|Alert.java:232|Received alert message (
"Alert": {
  "level"      : "warning",
  "description": "close_notify"
}
)</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6__GUID-487D7D13-FF82-4D6A-895F-817C485E0DAE">Close the Connection</p>
                           <p>The server closes the socket and then the TLS connection.</p><pre class="pre codeblock"><code>javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:48.661 EDT|SSLSocketImpl.java:1161|close the underlying socket
javax.net.ssl|DEBUG|01|main|2018-08-18 01:04:48.661 EDT|SSLSocketImpl.java:921|close the ssl connection (passive)
javax.net.ssl|ALL|01|main|2018-08-18 01:04:48.661 EDT|SSLSocketImpl.java:658|Closing input stream
javax.net.ssl|ALL|01|main|2018-08-18 01:04:48.661 EDT|SSLSocketImpl.java:728|Closing output stream</code></pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-2F836CEC-9BB4-41EA-8C4F-DC3E9510EFC4" name="GUID-2F836CEC-9BB4-41EA-8C4F-DC3E9510EFC4"></a><h3 id="JSSEC-GUID-2F836CEC-9BB4-41EA-8C4F-DC3E9510EFC4" class="sect3">Compatibility Risks and Known Issues</h3>
               <div>
                  <p>Enhancements to JSSE may introduce compatibility problems and other known issues, which are described in this section.</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-2F836CEC-9BB4-41EA-8C4F-DC3E9510EFC4__GUID-833724A2-7992-4418-BE39-885C8DC6A93A">TLS 1.3 Not Directly Compatible with Previous Versions</p>
                     <p>TLS 1.3 is not directly compatible with previous versions. Although TLS 1.3 can be implemented with a backward-compatibility mode, there are still several compatibility risks to consider when upgrading to TLS 1.3:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>TLS 1.3 uses a half-close policy, while TLS 1.2 and earlier use a duplex-close policy. For applications that depend on the duplex-close policy, there may be compatibility issues when upgrading to TLS 1.3.</p>
                        </li>
                        <li>
                           <p>The signature_algorithms_cert extension requires that pre-defined signature algorithms are used for certificate authentication. In practice, however, an application may use unsupported signature algorithms.</p>
                        </li>
                        <li>
                           <p>The DSA signature algorithm is not supported in TLS 1.3. If a server is configured to only use DSA certificates, it cannot negotiate a TLS 1.3 connection.</p>
                        </li>
                        <li>
                           <p>The supported cipher suites for TLS 1.3 are not the same as TLS 1.2 and earlier. If an application hardcodes cipher suites that are no longer supported, it may not be able to use TLS 1.3 without modifications to its code, for example TLS_AES_128_GCM_SHA256 (1.3 and later) versus TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA (1.2 and earlier).</p>
                        </li>
                        <li>
                           <p>The TLS 1.3 session resumption and key update behaviors are different from TLS 1.2 and earlier. The compatibility impact should be minimal, but it could be a risk if an application depends on the handshake details of the TLS protocols.</p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-0573BCE4-05C4-429C-8ECC-3D3D8CA807F4" name="GUID-0573BCE4-05C4-429C-8ECC-3D3D8CA807F4"></a><h3 id="JSSEC-GUID-0573BCE4-05C4-429C-8ECC-3D3D8CA807F4" class="sect3">Code Examples</h3>
               <div>
                  <p>The following code examples are included in this section:</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-0573BCE4-05C4-429C-8ECC-3D3D8CA807F4__GUID-2FFB20C7-211D-4A60-8C79-400C589E83EF">Topics</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-AB802E5F-07CE-468D-AC7C-7EBCAAE119AD" title="Code examples that illustrate how to use JSSE to convert an unsecure socket connection to a secure socket connection. The code samples are excerpted from the book Java SE 6 Network Security by Marco Pistoia, et. al.">Converting an Unsecure Socket to a Secure Socket</a></p>
                        </li>
                        <li>
                           <p><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA" title="The JSSE sample programs illustrate how to use JSSE.">Running the JSSE Sample Code</a></p>
                        </li>
                        <li>
                           <p><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-3D26386B-BC7A-41BB-AC70-80E6CD147D6F" title="The procedure as to how you can use the keytool utility to create a simple PKCS12 keystore suitable for use with JSSE.">Creating a Keystore to Use with JSSE</a></p>
                        </li>
                        <li>
                           <p><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-63945B45-E909-483F-B3A9-E26586737383">Using the Server Name Indication (SNI) Extension</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div>
               <div class="sect3"><a id="GUID-AB802E5F-07CE-468D-AC7C-7EBCAAE119AD" name="GUID-AB802E5F-07CE-468D-AC7C-7EBCAAE119AD"></a><h4 id="JSSEC-GUID-AB802E5F-07CE-468D-AC7C-7EBCAAE119AD" class="sect4">Converting an Unsecure Socket to a Secure Socket</h4>
                  <div>
                     <p>Code examples that illustrate how to use JSSE to convert an unsecure socket connection to a secure socket connection. The code samples are excerpted from the book Java SE 6 Network Security by Marco Pistoia, et. al.</p>
                     <p><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-AB802E5F-07CE-468D-AC7C-7EBCAAE119AD__SOCKETEXAMPLEWITHOUTSSL-6B1057A9">Example 8-26</a> shows sample code that can be used to set up communication between a client and a server using unsecure sockets. This code is then modified in <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-AB802E5F-07CE-468D-AC7C-7EBCAAE119AD__SOCKETEXAMPLEWITHSSL-6B10547E">Example 8-27</a> to use JSSE to set up secure socket communication.
                     </p>
                     <div class="example" id="GUID-AB802E5F-07CE-468D-AC7C-7EBCAAE119AD__SOCKETEXAMPLEWITHOUTSSL-6B1057A9">
                        <p class="titleinexample">Example 8-26 Socket Example Without SSL</p>
                        <p>The following examples demonstrates server-side and client-side code for setting up an unsecure socket connection.</p>
                        <p>In a Java program that acts as a server and communicates with a client using sockets, the socket communication is set up with code similar to the following:</p><pre class="codeblock"><code>
    import java.io.*;
    import java.net.*;
    
    . . .
    
    int port = availablePortNumber;
    
    ServerSocket s;
    
    try {
        s = new ServerSocket(port);
        Socket c = s.accept();
    
        OutputStream out = c.getOutputStream();
        InputStream in = c.getInputStream();
    
        // Send messages to the client through
        // the OutputStream
        // Receive messages from the client
        // through the InputStream
    } catch (IOException e) { }
</code></pre><p>The client code to set up communication with a server using sockets is similar to the following:</p><pre class="codeblock"><code>
    import java.io.*;
    import java.net.*;
    
    . . .
    
    int port = availablePortNumber;
    String host = "hostname";
    
    try {
        s = new Socket(host, port);
    
        OutputStream out = s.getOutputStream();
        InputStream in = s.getInputStream();
    
        // Send messages to the server through
        // the OutputStream
        // Receive messages from the server
        // through the InputStream
    } catch (IOException e) { }
</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-AB802E5F-07CE-468D-AC7C-7EBCAAE119AD__SOCKETEXAMPLEWITHSSL-6B10547E">
                        <p class="titleinexample">Example 8-27 Socket Example with SSL</p>
                        <p>The following examples demonstrate server-side and client-side code for setting up a secure socket connection.</p>
                        <p>In a Java program that acts as a server and communicates with a client using secure sockets, the socket communication is set up with code similar to the following. Differences between this program and the one for communication using unsecure sockets are highlighted in bold.</p><pre class="codeblock"><code>
    import java.io.*;
    import <span class="bold">javax.net.ssl.*</span>;
    
    . . .
    
    int port = availablePortNumber;
    
    <span class="bold">SSLServerSocket</span> s;
    
    try {
        <span class="bold">SSLServerSocketFactory sslSrvFact =
            (SSLServerSocketFactory)SSLServerSocketFactory.getDefault();
        s = (SSLServerSocket)sslSrvFact.createServerSocket(port);</span>
    
        <span class="bold">SSLSocket</span> c = <span class="bold">(SSLSocket)</span>s.accept();
    
        OutputStream out = c.getOutputStream();
        InputStream in = c.getInputStream();
    
        // Send messages to the client through
        // the OutputStream
        // Receive messages from the client
        // through the InputStream
    }
    
    catch (IOException e) {
    }
</code></pre><p>The client code to set up communication with a server using secure sockets is similar to the following, where differences with the unsecure version are highlighted in bold:</p><pre class="codeblock"><code>
    import java.io.*;
    import <span class="bold">javax.net.ssl.*</span>;
    
    . . .
    
    int port = availablePortNumber;
    String host = "hostname";
    
    try {
        <span class="bold">SSLSocketFactory sslFact =
            (SSLSocketFactory)SSLSocketFactory.getDefault();
        SSLSocket s = (SSLSocket)sslFact.createSocket(host, port);</span>
    
        OutputStream out = s.getOutputStream();
        InputStream in = s.getInputStream();
    
        // Send messages to the server through
        // the OutputStream
        // Receive messages from the server
        // through the InputStream
    }
    
    catch (IOException e) {
    }
</code></pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA" name="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA"></a><h4 id="JSSEC-GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA" class="sect4">Running the JSSE Sample Code</h4>
                  <div>
                     <p>The JSSE sample programs illustrate how to use JSSE.</p>
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__SAMPLECODEILLUSTRATINGASECURESOCKET-82CE8421">Sample Code Illustrating a Secure Socket Connection Between a Client and a Server</a></li>
                           <li><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__SAMPLECODEILLUSTRATINGHTTPSCONNECTI-7D238310">Sample Code Illustrating HTTPS Connections</a></li>
                           <li><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__SAMPLECODEILLUSTRATINGASECURERMICON-F9A2C933">Sample Code Illustrating a Secure RMI Connection</a></li>
                           <li><a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__SAMPLECODEILLUSTRATINGTHEUSEOFANSSL-7D23A601">Sample Code Illustrating the Use of an SSLEngine</a></li>
                        </ul>
                        <p>When you use the sample code, be aware that the sample programs are designed to illustrate how to use JSSE. They are not designed to be robust applications.</p>
                        <div class="p"> 
                           <div class="infoboxnote" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-D989BF26-8A0F-46AD-A2E6-83C41C9642B3">
                              <p class="notep1">Note:</p>Setting up secure communications involves complex algorithms. The sample programs provide no feedback during the setup process. When you run the programs, be patient: you may not see any output for a while. If you run the programs with the <code class="codeph">javax.net.debug</code> system property set to <code class="codeph">all</code>, you will see more feedback. For an introduction to reading this debug information, see <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6">Debugging TLS Connections</a>.
                           </div>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-D24E673C-F5E8-41E1-9DA5-3B642EA482E3">Where to Find the Sample Code</p>
                        <p><span><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/samples/index.html" target="_blank">JSSE Sample Code</a> in the JDK 8 documentation</span> lists all the sample code files and text files. That page also provides a link to a ZIP file that you can download to obtain all the sample code files.
                        </p>
                        <p>The following sections describe the samples.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__SAMPLECODEILLUSTRATINGASECURESOCKET-82CE8421">
                        <p class="subhead3" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-EB08FD38-4235-478D-952E-543CA50F69A4">Sample Code Illustrating a Secure Socket Connection Between a Client and a Server</p>
                        <p>The sample programs in the <code class="codeph">samples/sockets</code> directory illustrate how to set up a secure socket connection between a client and a server.
                        </p>
                        <p>When running the sample client programs, you can communicate with an existing server, such as a web server, or you can communicate with the sample server program, <code class="codeph">ClassFileServer</code>. You can run the sample client and the sample server programs on different machines connected to the same network, or you can run them both on one machine but from different terminal windows.
                        </p>
                        <p>All the sample <code class="codeph">SSLSocketClient*</code> programs in the samples/sockets/client directory (and <code class="codeph">URLReader*</code> programs described in <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__SAMPLECODEILLUSTRATINGHTTPSCONNECTI-7D238310">Sample Code Illustrating HTTPS Connections</a>) can be run with the <code class="codeph">ClassFileServer</code> sample server program. An example of how to do this is shown in <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__RUNNINGSSLSOCKETCLIENTWITHCLIENTAUT-7D23BC0C">Running SSLSocketClientWithClientAuth with ClassFileServer</a>. You can make similar changes to run <code class="codeph">URLReader</code>, <code class="codeph">SSLSocketClient</code>, or <code class="codeph">SSLSocketClientWithTunneling</code> with <code class="codeph">ClassFileServer</code>.
                        </p>
                        <p>If an authentication error occurs during communication between the client and the server (whether using a web server or <code class="codeph">ClassFileServer</code>), it is most likely because the necessary keys are not in the truststore (trust key database). See <a href="terms-and-definitions.html" title="The following are commonly used cryptography terms and their definitions.">Terms and Definitions</a>. For example, the <code class="codeph">ClassFileServer</code> uses a keystore called <code class="codeph">testkeys</code> containing the private key for <code class="codeph">localhost</code> as needed during the SSL handshake. The <code class="codeph">testkeys</code> keystore is included in the same samples/sockets/server directory as the <code class="codeph">ClassFileServer</code> source. If the client cannot find a certificate for the corresponding public key of <code class="codeph">localhost</code> in the truststore it consults, then an authentication error will occur. Be sure to use the <code class="codeph">samplecacerts</code> truststore (which contains the public key and certificate of the <code class="codeph">localhost</code>), as described in the next section. 
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__CONFIGURATIONREQUIREMENTS-82CE87BD">
                        <p class="subhead3" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-E82A76FE-0D76-4C9C-8850-998385DBC5FC">Configuration Requirements</p>
                        <p>When running the sample programs that create a secure socket connection between a client and a server, you will need to make the appropriate certificates file (truststore) available. For both the client and the server programs, you should use the certificates file <code class="codeph">samplecacerts</code> from the <code class="codeph">samples</code> directory. Using this certificates file will allow the client to authenticate the server. The file contains all the common Certificate Authority (CA) certificates shipped with the JDK (in the cacerts file), plus a certificate for <code class="codeph">localhost</code> needed by the client to authenticate <code class="codeph">localhost</code> when communicating with the sample server <code class="codeph">ClassFileServer</code>. The <code class="codeph">ClassFileServer</code> uses a keystore containing the private key for <code class="codeph">localhost</code> that corresponds to the public key in <code class="codeph">samplecacerts</code>.
                        </p>
                        <p>To make the <code class="codeph">samplecacerts</code> file available to both the client and the server, you can either copy it to the file <code>java-home/lib/security/jssecacerts</code>, rename it to cacerts, and use it to replace the <code>java-home/lib/security/cacerts</code> file, or add the following option to the command line when running the <code class="codeph">java</code> command for both the client and the server:
                        </p><pre class="codeblock"><code>-Djavax.net.ssl.trustStore=<span class="variable" translate="no">path_to_samplecacerts_file</span>
</code></pre><p>To know more about <span class="variable" translate="no">java-home</span>, see <a href="terms-and-definitions.html" title="The following are commonly used cryptography terms and their definitions.">Terms and Definitions</a>.
                        </p>
                        <p>The password for the <code class="codeph">samplecacerts</code> truststore is <code class="codeph">changeit</code>. You can substitute your own certificates in the samples by using the <code class="codeph">keytool</code> utility.
                        </p>
                        <p>If you use a browser, such as Mozilla Firefox or Microsoft Internet Explorer, to access the sample SSL server provided in the <code class="codeph">ClassFileServer</code> example, then a dialog box may pop up with the message that it does not recognize the certificate. This is normal because the certificate used with the sample programs is self-signed and is for testing only. You can accept the certificate for the current session. After testing the SSL server, you should exit the browser, which deletes the test certificate from the browser's namespace.
                        </p>
                        <p>For client authentication, a separate <code class="codeph">duke</code> certificate is available in the appropriate directories. The public key and certificate is also stored in the <code class="codeph">samplecacerts</code> file.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__RUNNINGSSLSOCKETCLIENT-82CE8C59">
                        <p class="subhead3" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-602AB8D6-E941-45E3-87B2-2D94C8E57124">Running SSLSocketClient</p>
                        <p>The <code class="codeph">SSLSocketClient.java</code> program in <span><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/samples/index.html" target="_blank">JSSE Sample Code</a> in the JDK 8 documentation</span> demonstrates how to create a client that uses an <code class="codeph">SSLSocket</code> to send an HTTP request and to get a response from an HTTPS server. The output of this program is the HTML source for <code class="codeph">https://www.verisign.com/index.html</code>.
                        </p>
                        <p>You must not be behind a firewall to run this program as provided. If you run it from behind a firewall, you will get an <code class="codeph">UnknownHostException</code> because JSSE cannot find a path through your firewall to <code class="codeph">www.verisign.com</code>. To create an equivalent client that can run from behind a firewall, set up proxy tunneling as illustrated in the sample program <code class="codeph">SSLSocketClientWithTunneling</code>.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__RUNNINGSSLSOCKETCLIENTWITHTUNNELING-82CE8F98">
                        <p class="subhead3" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-64521705-A715-4BC0-B52F-ED2CC2283E3B">Running SSLSocketClientWithTunneling</p>
                        <p>The <code class="codeph">SSLSocketClientWithTunneling.java</code> program in <span><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/samples/index.html" target="_blank">JSSE Sample Code</a> in the JDK 8 documentation</span> illustrates how to do proxy tunneling to access a secure web server from behind a firewall. To run this program, you must set the following Java system properties to the appropriate values:
                        </p><pre class="codeblock"><code>java -Dhttps.proxyHost=<span class="variable" translate="no">webproxy</span>
-Dhttps.proxyPort=<span class="variable" translate="no">ProxyPortNumber</span>
SSLSocketClientWithTunneling
</code></pre><div class="p">
                           <div class="infoboxnote" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-12EDAEC4-5DE4-4BD8-A68C-E096E92AE49B">
                              <p class="notep1">Note:</p>Proxy specifications with the <code class="codeph">-D</code> options are optional. Replace <span class="variable" translate="no">webproxy</span> with the name of your proxy host and <span class="variable" translate="no">ProxyPortNumber</span> with the appropriate port number.
                           </div> 
                        </div>
                        <p>The program will return the HTML source file from <code class="codeph">https://www.verisign.com/index.html</code>.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__RUNNINGSSLSOCKETCLIENTWITHCLIENTAUT-7D23C25E">
                        <p class="subhead3" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-AC110522-A3EE-479E-BD16-7946F66F9CD2">Running SSLSocketClientWithClientAuth</p>
                        <p>The <code>SSLSocketClientWithClientAuth.java</code> program in <span><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/samples/index.html" target="_blank">JSSE Sample Code</a> in the JDK 8 documentation</span> shows how to set up a key manager to do client authentication if required by a server. This program also assumes that the client is not outside a firewall. You can modify the program to connect from inside a firewall by following the example in <code class="codeph">SSLSocketClientWithTunneling</code>.
                        </p>
                        <p>To run this program, you must specify three parameters: host, port, and requested file path. To mirror the previous examples, you can run this program without client authentication by setting the host to <code class="codeph">www.verisign.com</code>, the port to <code class="codeph">443</code>, and the requested file path to <code class="codeph">https://www.verisign.com/</code>. The output when using these parameters is the HTML for the website <code class="codeph">https://www.verisign.com/</code>.
                        </p>
                        <p>To run <code class="codeph">SSLSocketClientWithClientAuth</code> to do client authentication, you must access a server that requests client authentication. You can use the sample program <code class="codeph">ClassFileServer</code> as this server. This is described in the following sections.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__RUNNINGCLASSFILESERVER-7D23BEFC">
                        <p class="subhead3" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-7411C2BE-80B1-43A0-A501-CAE5D9A93E86">Running ClassFileServer</p>
                        <p>The program referred to herein as <code class="codeph">ClassFileServer</code> is made up of two files: <code>ClassFileServer.java</code> and <code>ClassServer.java</code> in <span><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/samples/index.html" target="_blank">JSSE Sample Code</a> in the JDK 8 documentation</span>.
                        </p>
                        <p>To execute them, run <code class="codeph">ClassFileServer.class</code>, which requires the following parameters:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li><code class="codeph">port</code> can be any available unused port number, for example, you can use the number <code class="codeph">2001</code>.
                           </li>
                           <li><code class="codeph">docroot</code> indicates the directory on the server that contains the file you want to retrieve. For example, on Solaris, you can use /home/<span class="variable" translate="no">userid</span>/ (where <span class="variable" translate="no">userid</span> refers to your particular UID), whereas on Microsoft Windows systems, you can use c:\.
                           </li>
                           <li><code class="codeph">TLS</code> is an optional parameter that indicates that the server is to use SSL or TLS.
                           </li>
                           <li><code class="codeph">true</code> is an optional parameter that indicates that client authentication is required. This parameter is only consulted if the TLS parameter is set.
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-4635E921-C2B5-4FD5-9480-6478D6C33FC0">
                           <p class="notep1">Note:</p>The <code class="codeph">TLS</code> and <code class="codeph">true</code> parameters are optional. If you omit them, indicating that an ordinary (not TLS) file server should be used, without authentication, then nothing happens. This is because one side (the client) is trying to negotiate with TLS, while the other (the server) is not, so they cannot communicate.
                        </div> 
                        <div class="infoboxnote" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-F17E9E88-69BB-4873-AC14-BA2B42917D05">
                           <p class="notep1">Note:</p>The server expects GET requests in the form <code class="codeph">GET /<span class="variable" translate="no">path_to_file</span></code>.
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__RUNNINGSSLSOCKETCLIENTWITHCLIENTAUT-7D23BC0C">
                        <p class="subhead3" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-E305855C-9AE0-44F8-A077-6BF06A3C4C4F">Running SSLSocketClientWithClientAuth with ClassFileServer</p>
                        <p>You can use the sample programs <code>SSLSocketClientWithClientAuth.java</code> and <code class="codeph">ClassFileServer</code> in <span><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/samples/index.html" target="_blank">JSSE Sample Code</a> in the JDK 8 documentation</span> to set up authenticated communication, where the client and server are authenticated to each other. You can run both sample programs on different machines connected to the same network, or you can run them both on one machine but from different terminal windows or command prompt windows. To set up both the client and the server, do the following:
                        </p>
                        <ol>
                           <li>Run the program <code class="codeph">ClassFileServer</code> from one machine or terminal window. 
                              <p>See <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__RUNNINGCLASSFILESERVER-7D23BEFC">Running ClassFileServer</a>.
                              </p>
                           </li>
                           <li>Run the program <code class="codeph">SSLSocketClientWithClientAuth</code> on another machine or terminal window. <code class="codeph">SSLSocketClientWithClientAuth</code> requires the following parameters: 
                              <ul style="list-style-type: disc;">
                                 <li><code class="codeph">host</code> is the host name of the machine that you are using to run <code class="codeph">ClassFileServer</code>.
                                 </li>
                                 <li><code class="codeph">port</code> is the same port that you specified for <code class="codeph">ClassFileServer</code>.
                                 </li>
                                 <li> 
                                    <p><code class="codeph">requestedfilepath</code> indicates the path to the file that you want to retrieve from the server. You must give this parameter as <code class="codeph">/filepath</code>. Forward slashes are required in the file path because it is used as part of a GET statement, which requires forward slashes regardless of what type of operating system you are running. The statement is formed as follows:
                                    </p> <pre class="codeblock"><code>"GET " + requestedfilepath + " HTTP/1.0"
</code></pre></li>
                              </ul> 
                           </li>
                        </ol> 
                        <div class="infoboxnote" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-80571B4D-FD52-412D-80AF-BB6FF98147C3">
                           <p class="notep1">Note:</p>You can modify the other <code class="codeph">SSLClient*</code> applications' <code class="codeph">GET</code> commands to connect to a local machine running <code class="codeph">ClassFileServer</code>.
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__SAMPLECODEILLUSTRATINGHTTPSCONNECTI-7D238310">
                        <p class="subhead3" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-9CB1D70B-E67B-48AC-A21B-F09E66E24C41">Sample Code Illustrating HTTPS Connections</p>
                        <p>There are two primary APIs for accessing secure communications through JSSE. One way is through a socket-level API that can be used for arbitrary secure communications, as illustrated by the <code class="codeph">SSLSocketClient</code>, <code class="codeph">SSLSocketClientWithTunneling</code>, and <code class="codeph">SSLSocketClientWithClientAuth</code> (with and without <code class="codeph">ClassFileServer</code>) sample programs.
                        </p>
                        <p>A second, and often simpler, way is through the standard Java URL API. You can communicate securely with an SSL-enabled web server by using the HTTPS URL protocol or scheme using the <code class="codeph">java.net.URL</code> class.
                        </p>
                        <p>Support for HTTPS URL schemes is implemented in many of the common browsers, which allows access to secured communications without requiring the socket-level API provided with JSSE.</p>
                        <p>An example URL is <code class="codeph">https://www.verisign.com</code>.
                        </p>
                        <p>The trust and key management for the HTTPS URL implementation is environment-specific. The JSSE implementation provides an HTTPS URL implementation. To use a different HTTPS protocol implementation, set the <code class="codeph">java.protocol.handler.pkgs</code>. See <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-460C3E5A-A373-4742-9E84-EB42A7A3C363">How to Specify a java.lang.System Property</a> to the package name. See the <code class="codeph">java.net.URL</code> class documentation for details.
                        </p>
                        <p>The samples that you can download with JSSE include two sample programs that illustrate how to create an HTTPS connection. Both of these sample programs (<code>URLReader.java</code> and <code>URLReaderWithOptions.java</code> ) are in the <code class="codeph">samples/urls</code> directory.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__RUNNINGURLREADER-7D238A63">
                        <p class="subhead3" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-C78194C9-255C-4127-B5DA-6E81FC37BF4F">Running URLReader</p>
                        <p>The <code>URLReader.java</code> program in <span><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/samples/index.html" target="_blank">JSSE Sample Code</a> in the JDK 8 documentation</span> illustrates using the URL class to access a secure site. The output of this program is the HTML source for <code class="codeph">https://www.verisign.com/</code>. By default, the HTTPS protocol implementation included with JSSE is used. To use a different implementation, set the system property <code class="codeph">java.protocol.handler.pkgs</code> value to be the name of the package containing the implementation.
                        </p>
                        <p>If you are running the sample code behind a firewall, then you must set the <code class="codeph">https.proxyHost</code> and <code class="codeph">https.proxyPort</code> system properties. For example, to use the proxy host "webproxy" on port 8080, you can use the following options for the <code class="codeph">java</code> command:
                        </p><pre class="codeblock"><code>-Dhttps.proxyHost=webproxy
-Dhttps.proxyPort=8080
</code></pre><p>Alternatively, you can set the system properties within the source code with the <code class="codeph">java.lang.System</code> method <code class="codeph">setProperty()</code>. For example, instead of using the command-line options, you can include the following lines in your program:
                        </p><pre class="codeblock"><code>System.setProperty("java.protocol.handler.pkgs", "com.ABC.myhttpsprotocol");
System.setProperty("https.proxyHost", "webproxy");
System.setProperty("https.proxyPort", "8080");
</code></pre></div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__RUNNINGURLREADERWITHOPTIONS-7D238F45">
                        <p class="subhead3" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-C9D64F26-3785-4D0E-9730-C6F742121933">Running URLReaderWithOptions</p>
                        <p>The <code>URLReaderWithOptions.java</code> program in <span><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/samples/index.html" target="_blank">JSSE Sample Code</a> in the JDK 8 documentation</span> is essentially the same as the <code class="codeph">URLReader.java</code> program, except that it allows you to optionally input any or all of the following system properties as arguments to the program when you run it:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li><code class="codeph">java.protocol.handler.pkgs</code></li>
                           <li><code class="codeph">https.proxyHost</code></li>
                           <li><code class="codeph">https.proxyPort</code></li>
                           <li><code class="codeph">https.cipherSuites</code></li>
                        </ul>
                        <p>To run <code class="codeph">URLReaderWithOptions</code>, enter the following command:
                        </p><pre class="codeblock"><code>java URLReaderWithOptions [-h <span class="variable" translate="no">proxyhost</span> -p <span class="variable" translate="no">proxyport</span>] [-k <span class="variable" translate="no">protocolhandlerpkgs</span>] [-c <span class="variable" translate="no">ciphersarray</span>]
</code></pre><div class="infoboxnote" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-91B04C04-7256-438A-8976-CFF5EC570A16">
                           <p class="notep1">Note:</p>Multiple protocol handlers can be included in the <code class="codeph">protocolhandlerpkgs</code> argument as a list with items separated by vertical bars. Multiple SSL cipher suite names can be included in the <code class="codeph">ciphersarray</code> argument as a list with items separated by commas. The possible cipher suite names are the same as those returned by the <code class="codeph">SSLSocket.getSupportedCipherSuites()</code> method. The suite names are taken from the SSL and TLS protocol specifications.
                        </div>
                        <p>You need a <code class="codeph">protocolhandlerpkgs</code> argument only if you want to use an HTTPS protocol handler implementation other than the default one provided by Oracle.
                        </p>
                        <p>If you are running the sample code behind a firewall, then you must include arguments for the proxy host and the proxy port. Additionally, you can include a list of cipher suites to enable.</p>
                        <p>Here is an example of running <code class="codeph">URLReaderWithOptions</code> and specifying the proxy host "webproxy" on port 8080:
                        </p><pre class="codeblock"><code>java URLReaderWithOptions -h webproxy -p 8080
</code></pre></div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__SAMPLECODEILLUSTRATINGASECURERMICON-F9A2C933">
                        <p class="subhead3" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-95DD1C8D-09FB-425E-8211-4262B2C00CC2">Sample Code Illustrating a Secure RMI Connection</p>
                        <p>The sample code in the <code>samples/rmi</code> directory illustrates how to create a secure Java Remote Method Invocation (RMI) connection. The sample code is basically a "Hello World" example modified to install and use a custom RMI socket factory.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__SAMPLECODEILLUSTRATINGTHEUSEOFANSSL-7D23A601">
                        <p class="subhead3" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-57A08D48-9BA5-4E30-B6F0-676464818ABC">Sample Code Illustrating the Use of an SSLEngine</p>
                        <p><code class="codeph">SSLEngine</code> gives application developers flexibility when choosing I/O and compute strategies. Rather than tie the SSL/TLS implementation to a specific I/O abstraction (such as single-threaded <code class="codeph">SSLSockets</code>), <code class="codeph">SSLEngine</code> removes the I/O and compute constraints from the SSL/TLS implementation.
                        </p>
                        <p>As mentioned earlier, <code class="codeph">SSLEngine</code> is an advanced API, and is not appropriate for casual use. Some introductory sample code is provided here that helps illustrate its use. The first demo removes most of the I/O and threading issues, and focuses on many of the SSLEngine methods. The second demo is a more realistic example showing how <code class="codeph">SSLEngine</code> might be combined with Java NIO to create a rudimentary HTTP/HTTPS server.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__RUNNINGSSLENGINESIMPLEDEMO-7D240794">
                        <p class="subhead3" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-BD9FAB8A-1461-4DC5-B996-8221998F58A9">Running SSLEngineSimpleDemo</p>
                        <p>The <code>SSLEngineSimpleDemo.java</code> program in <span><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/samples/index.html" target="_blank">JSSE Sample Code</a> in the JDK 8 documentation</span> is a very simple application that focuses on the operation of the <code class="codeph">SSLEngine</code> while simplifying the I/O and threading issues. This application creates two <code class="codeph">SSLEngine</code> objects that exchange SSL/TLS messages via common <code class="codeph">ByteBuffer</code> objects. A single loop serially performs all of the engine operations and demonstrates how a secure connection is established (handshaking), how application data is transferred, and how the engine is closed.
                        </p>
                        <p>The <code class="codeph">SSLEngineResult</code> provides a great deal of information about the current state of the <code class="codeph">SSLEngine</code>. This example does not examine all of the states. It simplifies the I/O and threading issues to the point that this is not a good example for a production environment; nonetheless, it is useful to demonstrate the overall function of the <code class="codeph">SSLEngine</code>.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__RUNNINGTHENIO-BASEDSERVER-7D23AE05">
                        <p class="subhead3" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-D6C1E956-4F4B-4EF3-AEAA-74A7F64862E6">Running the NIO-Based Server</p>
                        <p>To fully exploit the flexibility provided by <code class="codeph">SSLEngine</code>, you must first understand complementary APIs, such as I/O and threading models.
                        </p>
                        <p>An I/O model that large-scale application developers find of use is the NIO <code class="codeph">SocketChannel</code>. NIO was introduced in part to solve some of the scaling problem inherent in the <code class="codeph">java.net.Socket</code> API. <code class="codeph">SocketChannel</code> has many different modes of operation including:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>Blocking</li>
                           <li>Nonblocking</li>
                           <li>Nonblocking with selectors</li>
                        </ul>
                        <p>Sample code for a basic HTTP server is provided that not only demonstrates many of the new NIO APIs, but also shows how <code class="codeph">SSLEngine</code> can be employed to create a secure HTTPS server. The server is not production quality, but does show many of these new APIs in action.
                        </p>
                        <p>Inside the samples directory is a <code>README.txt</code> file that introduces the server, explains how to build and configure the server, and provides a brief overview of the code layout. The files of most interest for <code class="codeph">SSLEngine</code> users are <code>ChannelIO.java</code> and <code>ChannelIOSecure.java</code>.
                        </p>
                        <div class="infoboxnote" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-EE5A58AA-A4BC-44CE-8ED0-63D0F3B86E0A">
                           <p class="notep1">Note:</p>The server example discussed in this section is included in the JDK. You can find the code bundled in the <code class="codeph"><span class="variable" translate="no">jdk-home</span>/samples/nio/server</code> directory.
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-3D26386B-BC7A-41BB-AC70-80E6CD147D6F" name="GUID-3D26386B-BC7A-41BB-AC70-80E6CD147D6F"></a><h4 id="JSSEC-GUID-3D26386B-BC7A-41BB-AC70-80E6CD147D6F" class="sect4">Creating a Keystore to Use with JSSE</h4>
                  <div>
                     <p>The procedure as to how you can use the <code class="codeph">keytool</code> utility to create a simple PKCS12 keystore suitable for use with JSSE.
                     </p>
                     <div class="section">
                        <p>First you make a <code class="codeph">keyEntry</code> (with public and private keys) in the keystore, and then you make a corresponding <code class="codeph">trustedCertEntry</code> (public keys only) in a truststore. For client authentication, you follow a similar process for the client's certificates.
                        </p>
                        <div class="p">
                           <div class="infoboxnote" id="GUID-3D26386B-BC7A-41BB-AC70-80E6CD147D6F__GUID-9D016F06-C132-4185-83B2-B1EB279D05F0">
                              <p class="notep1">Note:</p>Storing trust anchors and secret keys in PKCS12 is supported since JDK 8.
                           </div>
                        </div>
                        <div class="p">
                           <div class="infoboxnote" id="GUID-3D26386B-BC7A-41BB-AC70-80E6CD147D6F__GUID-5FE9AE11-8CB4-4B6C-8BA9-D17AB01633BC">
                              <p class="notep1">Note:</p>It is beyond the scope of this example to explain each step in detail. See <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/java/javase/11/security&amp;id=JSWOR-GUID-5990A2E4-78E3-47B7-AE75-6D1826259549" target="_blank">keytool</a>.
                           </div> 
                        </div>
                        <p>User input is shown in bold.</p>
                        <ol>
                           <li> 
                              <p>Create a new keystore and self-signed certificate with corresponding public and private keys.</p> <pre class="codeblock"><code>
    % <span class="bold">keytool -genkeypair -alias duke -keyalg RSA -validity 7 -keystore keystore </span>
    
    Enter keystore password:  <span class="variable" translate="no">&lt;password&gt;</span>
    What is your first and last name?
    [Unknown]:  <span class="bold">Duke</span>
    What is the name of your organizational unit?
    [Unknown]:  <span class="bold">Java Software</span>
    What is the name of your organization?
    [Unknown]:  <span class="bold">Oracle, Inc.</span>
    What is the name of your City or Locality?
    [Unknown]:  <span class="bold">Palo Alto</span>
    What is the name of your State or Province?
    [Unknown]:  <span class="bold">CA</span>
    What is the two-letter country code for this unit?
    [Unknown]:  <span class="bold">US</span>
    Is CN=Duke, OU=Java Software, O="Oracle, Inc.",
    L=Palo Alto, ST=CA, C=US correct?
    [no]:  <span class="bold">yes</span>
</code></pre></li>
                           <li> 
                              <p>Examine the keystore. Notice that the entry type is <code class="codeph">PrivatekeyEntry</code>, which means that this entry has a private key associated with it).
                              </p> <pre class="codeblock"><code>
    % <span class="bold">keytool -list -v -keystore keystore</span>
    
    Enter keystore password:  <span class="variable" translate="no">&lt;password&gt;</span>
    
    Keystore type: PKCS12
    Keystore provider: SUN

    Your keystore contains 1 entry

    Alias name: duke
    Creation date: Jul 25, 2016
    Entry type: PrivateKeyEntry
    Certificate chain length: 1
    Certificate[1]:
    Owner: CN=Duke, OU=Java Software, O="Oracle, Inc.", L=Palo Alto, ST=CA, C=US
    Issuer: CN=Duke, OU=Java Software, O="Oracle, Inc.", L=Palo Alto, ST=CA, C=US
    Serial number: 210cccfc
    Valid from: Mon Jul 25 10:33:27 IST 2016 until: Mon Aug 01 10:33:27 IST 2016
    Certificate fingerprints:
         SHA1: 80:E5:8A:47:7E:4F:5A:70:83:97:DD:F4:DA:29:3D:15:6B:2A:45:1F
         SHA256: ED:3C:70:68:4E:86:35:9C:63:CC:B9:59:35:58:94:1F:7E:B8:B0:EE:D2:
    4B:9D:80:31:67:8A:D4:B4:7A:B5:12
    Signature algorithm name: SHA256withRSA
    Subject Public Key Algorithm: RSA (2048)
    Version: 3

    Extensions:

   #1: ObjectId: 2.5.29.14 Criticality=false
   SubjectKeyIdentifier [
   KeyIdentifier [
   0000: 7F C9 95 48 42 8D 68 91   BA 1E E6 5C 2C 6B FF 75  ...HB.h....\,k.u
   0010: 5F 19 78 43                                        _.xC
   ]
   ]</code></pre></li>
                           <li> 
                              <p>Export and examine the self-signed certificate.</p> <pre class="codeblock"><code>
    % <span class="bold">keytool -export -alias duke -keystore keystore -rfc -file duke.cer</span>
    Enter keystore password:  <span class="variable" translate="no">&lt;password&gt;</span>
    Certificate stored in file &lt;duke.cer&gt;
    % <span class="bold">cat duke.cer</span>
    -----BEGIN CERTIFICATE-----
    MIIDdzCCAl+gAwIBAgIEIQzM/DANBgkqhkiG9w0BAQsFADBsMQswCQYDVQQGEwJV
    UzELMAkGA1UECBMCQ0ExEjAQBgNVBAcTCVBhbG8gQWx0bzEVMBMGA1UEChMMT3Jh
    Y2xlLCBJbmMuMRYwFAYDVQQLEw1KYXZhIFNvZnR3YXJlMQ0wCwYDVQQDEwREdWtl
    MB4XDTE2MDcyNTA1MDMyN1oXDTE2MDgwMTA1MDMyN1owbDELMAkGA1UEBhMCVVMx
    CzAJBgNVBAgTAkNBMRIwEAYDVQQHEwlQYWxvIEFsdG8xFTATBgNVBAoTDE9yYWNs
    ZSwgSW5jLjEWMBQGA1UECxMNSmF2YSBTb2Z0d2FyZTENMAsGA1UEAxMERHVrZTCC
    ASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAJ7+Yeu6HDZgWwkGlG4iKH9w
    vGKrxXVR57FaFyheMevrgj1ovVnQVFhfdMvjPkjWmpqLg6rfTqU4bKbtoMWV6+Rn
    uQrCw2w9xNC93hX9PxRa20UKrSRDKnUSvi1wjlaxfj0KUKuMwbbY9S8x/naYGeTL
    lwbHiiMvkoFkP2kzhVgeqHjIwSz4HRN8vWHCwgIDFWX/ZlS+LbvB4TSZkS0ZcQUV
    vJWTocOd8RB90W3bkibWkWq166XYGE1Nq1L4WIhrVJwbav6ual69yJsEpVcshVkx
    E1WKzJg7dGb03to4agbReb6+aoCUwb2vNUudNWasSrxoEFArVFGD/ZkPT0esfqEC
    AwEAAaMhMB8wHQYDVR0OBBYEFH/JlUhCjWiRuh7mXCxr/3VfGXhDMA0GCSqGSIb3
    DQEBCwUAA4IBAQAmcTm2ahsIJLayajsvm8yPzQsHA7kIwWfPPHCoHmNbynG67oHB
    fleaNvrgm/raTT3TrqQkg0525qI6Cqaoyy8JA2fAp3i+hmyoGHaIlo14bKazaiPS
    RCCqk0J8vwY3CY9nVal1XlHJMEcYV7X1sxKbuAKFoAJ29E/p6ie0JdHtQe31M7X9
    FNLYzt8EpJYUtWo13B9Oufz/Guuex9PQ7aC93rbO32MxtnnCGMxQHlaHLLPygc/x
    cffGz5Xe5s+NEm78CY7thgN+drI7icBYmv4navsnr2OQaD3AfnJ4WYSQyyUUCPxN
    zuk+B0fbLn7PCCcQspmqfgzIpgbEM9M1/yav
    -----END CERTIFICATE-----    
</code></pre> <p>Alternatively, you could generate a Certificate Signing Request (CSR) with <code class="codeph">-certreq</code> and send that to a Certificate Authority (CA) for signing, but that is beyond the scope of this example.
                              </p> 
                           </li>
                           <li> 
                              <p>Import the certificate into a new truststore.</p> <pre class="codeblock"><code>
    % <span class="bold">keytool -import -alias dukecert -file duke.cer -keystore truststore</span>
    Enter keystore password:  <span class="variable" translate="no">&lt;password&gt;</span>
    Re-enter new password:
    Owner: CN=Duke, OU=Java Software, O="Oracle, Inc.", L=Palo Alto, ST=CA, C=US
    Issuer: CN=Duke, OU=Java Software, O="Oracle, Inc.", L=Palo Alto, ST=CA, C=US
    Serial number: 210cccfc
    Valid from: Mon Jul 25 10:33:27 IST 2016 until: Mon Aug 01 10:33:27 IST 2016
    Certificate fingerprints:
         SHA1: 80:E5:8A:47:7E:4F:5A:70:83:97:DD:F4:DA:29:3D:15:6B:2A:45:1F
         SHA256: ED:3C:70:68:4E:86:35:9C:63:CC:B9:59:35:58:94:1F:7E:B8:B0:EE:D2:
    4B:9D:80:31:67:8A:D4:B4:7A:B5:12
    Signature algorithm name: SHA256withRSA
    Subject Public Key Algorithm: RSA (2048)
    Version: 3

    Extensions:

    #1: ObjectId: 2.5.29.14 Criticality=false
    SubjectKeyIdentifier [
    KeyIdentifier [
    0000: 7F C9 95 48 42 8D 68 91   BA 1E E6 5C 2C 6B FF 75  ...HB.h....\,k.u
    0010: 5F 19 78 43                                        _.xC
    ]
    ]

    Trust this certificate? [no]:  yes
    Certificate was added to keystore

    
</code></pre></li>
                           <li> 
                              <p>Examine the truststore. Note that the entry type is <code class="codeph">trustedCertEntry</code>, which means that a private key is not available for this entry. It also means that this file is not suitable as a keystore of the <code class="codeph">KeyManager</code>.
                              </p> <pre class="codeblock"><code>
    % <span class="bold">keytool -list -v -keystore truststore</span>
    Enter keystore password:  <span class="variable" translate="no">&lt;password&gt;</span>
    
    Keystore type: PKCS12
    Keystore provider: SUN
    
    Your keystore contains 1 entry

    Alias name: dukecert
    Creation date: Jul 25, 2016
    Entry type: trustedCertEntry

    Owner: CN=Duke, OU=Java Software, O="Oracle, Inc.", L=Palo Alto, ST=CA, C=US
    Issuer: CN=Duke, OU=Java Software, O="Oracle, Inc.", L=Palo Alto, ST=CA, C=US
    Serial number: 210cccfc
    Valid from: Mon Jul 25 10:33:27 IST 2016 until: Mon Aug 01 10:33:27 IST 2016
    Certificate fingerprints:
         SHA1: 80:E5:8A:47:7E:4F:5A:70:83:97:DD:F4:DA:29:3D:15:6B:2A:45:1F
         SHA256: ED:3C:70:68:4E:86:35:9C:63:CC:B9:59:35:58:94:1F:7E:B8:B0:EE:D2:
    4B:9D:80:31:67:8A:D4:B4:7A:B5:12
    Signature algorithm name: SHA256withRSA
    Subject Public Key Algorithm: RSA (2048)
    Version: 3

    Extensions:

    #1: ObjectId: 2.5.29.14 Criticality=false
    SubjectKeyIdentifier [
    KeyIdentifier [
    0000: 7F C9 95 48 42 8D 68 91   BA 1E E6 5C 2C 6B FF 75  ...HB.h....\,k.u
    0010: 5F 19 78 43                                        _.xC
    ]
    ]



    *******************************************
    *******************************************
</code></pre></li>
                           <li> 
                              <p>Now run your applications with the appropriate keystores. Because this example assumes that the default <code class="codeph">X509KeyManager</code> and <code class="codeph">X509TrustManager</code> are used, you select the keystores using the system properties described in <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9" title="JSSE includes a standard implementation that can be customized by plugging in different implementations or specifying the default keystore, and so on.">Customizing JSSE</a>.
                              </p> <pre class="codeblock"><code>
    % java -Djavax.net.ssl.keyStore=keystore -Djavax.net.ssl.keyStorePassword=password Server
    
    % java -Djavax.net.ssl.trustStore=truststore -Djavax.net.ssl.trustStorePassword=trustword Client
    
</code></pre></li>
                        </ol>
                        <div class="p"> 
                           <div class="infoboxnote" id="GUID-3D26386B-BC7A-41BB-AC70-80E6CD147D6F__GUID-3E0172AD-F4CF-44DD-BEFF-4EFE7006F0E5">
                              <p class="notep1">Note:</p>This example authenticated the server only. For client authentication, provide a similar keystore for the client's keys and an appropriate truststore for the server.
                           </div>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-63945B45-E909-483F-B3A9-E26586737383" name="GUID-63945B45-E909-483F-B3A9-E26586737383"></a><h4 id="JSSEC-GUID-63945B45-E909-483F-B3A9-E26586737383" class="sect4">Using the Server Name Indication (SNI) Extension</h4>
                  <div>
                     <p></p>
                     <div class="section">
                        <p>These examples illustrate how you can use the <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F">Server Name Indication (SNI) Extension</a> for client-side and server-side applications, and how it can be applied to a virtual infrastructure.
                        </p>
                        <p>For all examples in this section, to apply the parameters after you set them, call the <code class="codeph">setSSLParameters(SSLParameters)</code> method on the corresponding <code class="codeph">SSLSocket</code>, <code class="codeph">SSLEngine</code>, or <code class="codeph">SSLServerSocket</code> object.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div class="sect4"><a id="GUID-BCCE0D1F-08D8-4608-8A5A-5BFA54FED2C0" name="GUID-BCCE0D1F-08D8-4608-8A5A-5BFA54FED2C0"></a><h5 id="JSSEC-GUID-BCCE0D1F-08D8-4608-8A5A-5BFA54FED2C0" class="sect5">Typical Client-Side Usage Examples</h5>
                     <div>
                        <p></p>
                        <p>The following is a list of use cases that require understanding of the SNI extension for developing a client application:</p>
                        <ul style="list-style-type: disc;">
                           <li> 
                              <p>Case 1. The client wants to access <code class="codeph">www.example.com</code>.
                              </p> 
                              <p>Set the host name explicitly:</p> <pre class="codeblock"><code>    SNIHostName serverName = new SNIHostName("www.example.com");
    sslParameters.setServerNames(Collections.singletonList(serverName)); </code></pre> <p>The client should always specify the host name explicitly.</p> 
                           </li>
                           <li> 
                              <p>Case 2. The client does not want to use SNI because the server does not support it.</p> 
                              <p>Disable SNI with an empty server name list:</p> <pre class="codeblock"><code>    sslParameters.setServerNames(Collections.emptyList());        
</code></pre></li>
                           <li> 
                              <p>Case 3. The client wants to access URL <code class="codeph">https://www.example.com</code>.
                              </p> 
                              <p>Oracle providers will set the host name in the SNI extension by default, but third-party providers may not support the default server name indication. To keep your application provider-independent, always set the host name explicitly.</p> 
                           </li>
                           <li> 
                              <p>Case 4. The client wants to switch a socket from server mode to client mode.</p> 
                              <p>First switch the mode with the following method: <code class="codeph">sslSocket.setUseClientMode(true)</code>. Then reset the server name indication parameters on the socket.
                              </p> 
                           </li>
                        </ul>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-FA9C8332-B6D9-48E6-AF66-700E00B829D2" name="GUID-FA9C8332-B6D9-48E6-AF66-700E00B829D2"></a><h5 id="JSSEC-GUID-FA9C8332-B6D9-48E6-AF66-700E00B829D2" class="sect5">Typical Server-Side Usage Examples</h5>
                     <div>
                        <p></p>
                        <p>The following is a list of use cases that require understanding of the SNI extension for developing a server application:</p>
                        <ul style="list-style-type: disc;">
                           <li> 
                              <p>Case 1. The server wants to accept all server name indication types.</p> 
                              <p>If you do not have any code dealing with the SNI extension, then the server ignores all server name indication types.</p> 
                           </li>
                           <li> 
                              <p>Case 2. The server wants to deny all server name indications of type <code class="codeph">host_name</code>.
                              </p> 
                              <p>Set an invalid server name pattern for <code class="codeph">host_name</code>:
                              </p> <pre class="codeblock"><code>    SNIMatcher matcher = SNIHostName.createSNIMatcher("");
    Collection&lt;SNIMatcher&gt; matchers = new ArrayList&lt;&gt;(1);
    matchers.add(matcher);
    sslParameters.setSNIMatchers(matchers);        
</code></pre> <p>Another way is to create an <code class="codeph">SNIMatcher</code> subclass with a <code class="codeph">matches()</code> method that always returns <code class="codeph">false</code>:
                              </p> <pre class="codeblock"><code>    class DenialSNIMatcher extends SNIMatcher {
        DenialSNIMatcher() {
            super(StandardConstants.SNI_HOST_NAME);
        }
    
        @Override
        public boolean matches(SNIServerName serverName) {
            return false;
        }
    }
    
    SNIMatcher matcher = new DenialSNIMatcher();
    Collection&lt;SNIMatcher&gt; matchers = new ArrayList&lt;&gt;(1);
    matchers.add(matcher);
    sslParameters.setSNIMatchers(matchers);        
</code></pre></li>
                           <li> 
                              <p>Case 3. The server wants to accept connections to any host names in the <code class="codeph">example.com</code> domain.
                              </p> 
                              <p>Set the recognizable server name for <code class="codeph">host_name</code> as a pattern that includes all <code class="codeph">*.example.com</code> addresses:
                              </p> <pre class="codeblock"><code>    SNIMatcher matcher = SNIHostName.createSNIMatcher("(.*\\.)*example\\.com");
    Collection&lt;SNIMatcher&gt; matchers = new ArrayList&lt;&gt;(1);
    matchers.add(matcher);
    sslParameters.setSNIMatchers(matchers);
</code></pre></li>
                           <li> 
                              <p>Case 4. The server wants to switch a socket from client mode to server mode.</p> 
                              <p>First switch the mode with the following method: <code class="codeph">sslSocket.setUseClientMode(false)</code>. Then reset the server name indication parameters on the socket.
                              </p> 
                           </li>
                        </ul>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-0D1E93B9-F63F-46E6-B8A9-0E3AF3207445" name="GUID-0D1E93B9-F63F-46E6-B8A9-0E3AF3207445"></a><h5 id="JSSEC-GUID-0D1E93B9-F63F-46E6-B8A9-0E3AF3207445" class="sect5">Working with Virtual Infrastructures</h5>
                     <div>
                        <p>This section describes how to use the Server Name Indication (SNI) extension from within a virtual infrastructure. It illustrates how to create a parser for ClientHello messages from a socket, provides examples of virtual server dispatchers using <code class="codeph">SSLSocket</code> and <code class="codeph">SSLEngine</code>, describes what happens when the SNI extension is not available, and demonstrates how to create a failover <code class="codeph">SSLContext</code>.
                        </p>
                        <div class="section">
                           <p class="subhead3" id="GUID-0D1E93B9-F63F-46E6-B8A9-0E3AF3207445__GUID-12355A88-3E49-484D-B8BB-2F9EBA57595F">Preparing the ClientHello Parser</p>
                           <p>Applications must implement an API to parse the ClientHello messages from a socket. The following examples illustrate the <code class="codeph">SSLCapabilities</code> and <code class="codeph">SSLExplorer</code> classes that can perform these functions.
                           </p>
                           <p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/samples/sockets/client/SSLSocketClient.java" target="_blank">SSLSocketClient.java</a> encapsulates the TLS/DTLS security capabilities during handshaking (that is, the list of cipher suites to be accepted in an TLS/DTLS handshake, the record version, the hello version, and the server name indication). It can be retrieved by exploring the network data of an TLS/DTLS connection via the <code class="codeph">SSLExplorer.explore()</code> method.
                           </p>
                           <p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/samples/sni/SSLExplorer.java" target="_blank">SSLExplorer.java</a> explores the initial ClientHello message from a TLS client, but it does not initiate handshaking or consume network data. The <code class="codeph">SSLExplorer.explore()</code> method parses the ClientHello message, and retrieves the security parameters into <code class="codeph">SSLCapabilities</code>. The method must be called before handshaking occurs on any TLS connections.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-0D1E93B9-F63F-46E6-B8A9-0E3AF3207445__GUID-7F9C795B-475B-4440-A58B-06C192DBD244">Virtual Server Dispatcher Based on SSLSocket</p>
                           <p>This section describes the procedure for using a virtual server dispatcher based on <code class="codeph">SSLSocket</code>.
                           </p>
                           <ol>
                              <li> 
                                 <p><span class="bold">Register the server name handler.</span></p> 
                                 <p>At this step, the application may create different <code class="codeph">SSLContext</code> objects for different server name indications, or link a certain server name indication to a specified virtual machine or distributed system.
                                 </p> 
                                 <p>For example, if the server name is <code class="codeph">www.example.org</code>, then the registered server name handler may be for a local virtual hosting web service. The local virtual hosting web service will use the specified <code class="codeph">SSLContext</code>. If the server name is <code class="codeph">www.example.com</code>, then the registered server name handler may be for a virtual machine hosting on <code class="codeph">10.0.0.36</code>. The handler may map this connection to the virtual machine.
                                 </p> 
                              </li>
                              <li> 
                                 <p><span class="bold">Create a <code class="codeph">ServerSocket</code> and accept the new connection.</span></p> <pre class="codeblock"><code>ServerSocket serverSocket = new ServerSocket(serverPort);
Socket socket = serverSocket.accept();
</code></pre></li>
                              <li> 
                                 <p><span class="bold">Read and buffer bytes from the socket input stream, and then explore the buffered bytes.</span></p> <pre class="codeblock"><code>InputStream ins = socket.getInputStream();
byte[] buffer = new byte[0xFF];
int position = 0;
SSLCapabilities capabilities = null;
    
// Read the header of TLS record
while (position &lt; SSLExplorer.RECORD_HEADER_SIZE) {
    int count = SSLExplorer.RECORD_HEADER_SIZE - position;
    int n = ins.read(buffer, position, count);
    if (n &lt; 0) {
        throw new Exception("unexpected end of stream!");
    }
    position += n;
}
    
// Get the required size to explore the SSL capabilities
int recordLength = SSLExplorer.getRequiredSize(buffer, 0, position);
if (buffer.length &lt; recordLength) {
    buffer = Arrays.copyOf(buffer, recordLength);
}
    
while (position &lt; recordLength) {
    int count = recordLength - position;
    int n = ins.read(buffer, position, count);
    if (n &lt; 0) {
        throw new Exception("unexpected end of stream!");
    }
    position += n;
}
    
// Explore
capabilities = SSLExplorer.explore(buffer, 0, recordLength);
if (capabilities != null) {
    System.out.println("Record version: " + capabilities.getRecordVersion());
    System.out.println("Hello version: " + capabilities.getHelloVersion());
}</code></pre></li>
                              <li> 
                                 <p><span class="bold">Get the requested server name from the explored capabilities.</span></p> <pre class="codeblock"><code>List&lt;SNIServerName&gt; serverNames = capabilities.getServerNames();
</code></pre></li>
                              <li> 
                                 <p><span class="bold">Look for the registered server name handler for this server name indication.</span></p> 
                                 <p>If the service of the host name is resident in a virtual machine or another distributed system, then the application must forward the connection to the destination. The application will need to read and write the raw internet data, rather then the SSL application from the socket stream.</p> <pre class="codeblock"><code>Socket destinationSocket = new Socket(serverName, 443);
// Forward buffered bytes and network data from the current socket to the destinationSocket.
</code></pre> <p>If the service of the host name is resident in the same process, and the host name service can use the <code class="codeph">SSLSocket</code> directly, then the application will need to set the <code class="codeph">SSLSocket</code> instance to the server:
                                 </p> <pre class="codeblock"><code>// Get service context from registered handler
// or create the context
SSLContext serviceContext = ...

SSLSocketFactory serviceSocketFac = serviceContext.getSSLSocketFactory();

// wrap the buffered bytes
ByteArrayInputStream bais = new ByteArrayInputStream(buffer, 0, position);
SSLSocket serviceSocket = (SSLSocket)serviceSocketFac.createSocket(socket, bais, true);

// Now the service can use serviceSocket as usual.
</code></pre></li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-0D1E93B9-F63F-46E6-B8A9-0E3AF3207445__GUID-40651F18-8498-4BF4-83A6-E6CE93452E0E">Virtual Server Dispatcher Based on SSLEngine</p>
                           <p>This section describes the procedure for using a virtual server dispatcher based on <code class="codeph">SSLEngine</code>.
                           </p>
                           <ol>
                              <li> 
                                 <p><span class="bold">Register the server name handler.</span></p> 
                                 <p>At this step, the application may create different <code class="codeph">SSLContext</code> objects for different server name indications, or link a certain server name indication to a specified virtual machine or distributed system.
                                 </p> 
                                 <p>For example, if the server name is <code class="codeph">www.example.org</code>, then the registered server name handler may be for a local virtual hosting web service. The local virtual hosting web service will use the specified <code class="codeph">SSLContext</code>. If the server name is <code class="codeph">www.example.com</code>, then the registered server name handler may be for a virtual machine hosting on <code class="codeph">10.0.0.36</code>. The handler may map this connection to the virtual machine.
                                 </p> 
                              </li>
                              <li> 
                                 <p><span class="bold">Create a <code class="codeph">ServerSocket</code> or <code class="codeph">ServerSocketChannel</code> and accept the new connection.</span></p> <pre class="codeblock"><code>ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
serverSocketChannel.bind(...);
...
SocketChannel socketChannel = serverSocketChannel.accept();
</code></pre></li>
                              <li> 
                                 <p><span class="bold">Read and buffer bytes from the socket input stream, and then explore the buffered bytes.</span></p> <pre class="codeblock"><code>ByteBuffer buffer = ByteBuffer.allocate(0xFF);
SSLCapabilities capabilities = null;
while (true) {
    // ensure the capacity
    if (buffer.remaining() == 0) {
        ByteBuffer oldBuffer = buffer;
        buffer = ByteBuffer.allocate(buffer.capacity() + 0xFF);
        buffer.put(oldBuffer);
    }

    int n = sc.read(buffer);
    if (n &lt; 0) {
        throw new Exception("unexpected end of stream!");
    }

    int position = buffer.position();
    buffer.flip();
    capabilities = explorer.explore(buffer);
    buffer.rewind();
    buffer.position(position);
    buffer.limit(buffer.capacity());
    if (capabilities != null) {
        System.out.println("Record version: " +
            capabilities.getRecordVersion());
        System.out.println("Hello version: " +
            capabilities.getHelloVersion());
        break;
    }
}

buffer.flip();  // reset the buffer position and limitation </code></pre></li>
                              <li> 
                                 <p><span class="bold">Get the requested server name from the explored capabilities.</span></p> <pre class="codeblock"><code>List&lt;SNIServerName&gt; serverNames = capabilities.getServerNames();
</code></pre></li>
                              <li> 
                                 <p><span class="bold">Look for the registered server name handler for this server name indication.</span></p> 
                                 <p>If the service of the host name is resident in a virtual machine or another distributed system, then the application must forward the connection to the destination. The application will need to read and write the raw internet data, rather then the SSL application from the socket stream.</p> <pre class="codeblock"><code>Socket destinationSocket = new Socket(serverName, 443);
// Forward buffered bytes and network data from the current socket to the destinationSocket.
</code></pre> <p>If the service of the host name is resident in the same process, and the host name service can use the <code class="codeph">SSLEngine</code> directly, then the application will simply feed the net data to the <code class="codeph">SSLEngine</code> instance:
                                 </p> <pre class="codeblock"><code>// Get service context from registered handler
// or create the context
SSLContext serviceContext = ...
    
SSLEngine serviceEngine = serviceContext.createSSLEngine();
// Now the service can use the buffered bytes and other byte buffer as usual.
</code></pre></li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-0D1E93B9-F63F-46E6-B8A9-0E3AF3207445__GUID-6D6971CD-E025-46F1-A5A3-E21875996EB4">No SNI Extension Available</p>
                           <p>If there is no server name indication in a ClientHello message, then there is no way to select the proper service according to SNI. For such cases, the application may need to specify a default service, so that the connection can be delegated to it if there is no server name indication.</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-0D1E93B9-F63F-46E6-B8A9-0E3AF3207445__GUID-D66A3C38-9FB2-4292-BAF3-AB9B7F6434E0">Failover SSLContext</p>
                           <p>The <code class="codeph">SSLExplorer.explore()</code> method does not check the validity of TLS/DTLS contents. If the record format does not comply with TLS/DTLS specification, or the <code class="codeph">explore()</code> method is invoked after handshaking has started, then the method may throw an <code class="codeph">IOException</code> and be unable to produce network data. In such cases, handle the exception thrown by <code class="codeph">SSLExplorer.explore()</code> by using a failover <code class="codeph">SSLContext</code>, which is not used to negotiate a TLS/DTLS connection, but to close the connection with the proper alert message. The following example illustrates a failover <code class="codeph">SSLContext</code>. You can find an example of the <code class="codeph">DenialSNIMatcher</code> class in Case 2 in <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-FA9C8332-B6D9-48E6-AF66-700E00B829D2">Typical Server-Side Usage Examples</a>.
                           </p><pre class="codeblock"><code>byte[] buffer = ...       // buffered network data
boolean failed = true;    // SSLExplorer.explore() throws an exception

SSLContext context = SSLContext.getInstance("TLS");
// the failover SSLContext
    
context.init(null, null, null);
SSLSocketFactory sslsf = context.getSocketFactory();
ByteArrayInputStream bais = new ByteArrayInputStream(buffer, 0, position);
SSLSocket sslSocket = (SSLSocket)sslsf.createSocket(socket, bais, true);

SNIMatcher matcher = new DenialSNIMatcher();
Collection&lt;SNIMatcher&gt; matchers = new ArrayList&lt;&gt;(1);
matchers.add(matcher);
SSLParameters params = sslSocket.getSSLParameters();
params.setSNIMatchers(matchers);    // no recognizable server name
sslSocket.setSSLParameters(params);

try {
    InputStream sslIS = sslSocket.getInputStream();
    sslIS.read();
} catch (Exception e) {
    System.out.println("Server exception " + e);
} finally {
    sslSocket.close();
}
</code></pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-847CA40C-F439-4A31-A7FA-C37B4DEC2190" name="GUID-847CA40C-F439-4A31-A7FA-C37B4DEC2190"></a><h3 id="JSSEC-GUID-847CA40C-F439-4A31-A7FA-C37B4DEC2190" class="sect3">Standard Names</h3>
               <div>
                  <p></p>
                  <div class="section">The JDK Security API requires and uses a set of standard names for algorithms, certificates and keystore types. See the <a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html" target="_blank">Java Security Standard Algorithm Names</a> specification. Find specific provider information in <a href="oracle-providers.html#GUID-FE2D2E28-C991-4EF9-9DBE-2A4982726313" title="This document contains the technical details of the providers that are included in the JDK. It is assumed that readers have a strong understanding of the Java Cryptography Architecture and Provider Architecture.">JDK Providers Documentation</a>.
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-08173142-567C-495C-A48F-32D0FCED466B" name="GUID-08173142-567C-495C-A48F-32D0FCED466B"></a><h3 id="JSSEC-GUID-08173142-567C-495C-A48F-32D0FCED466B" class="sect3">Provider Pluggability</h3>
               <div>
                  <p>JSSE is fully pluggable and does not restrict the use of third-party JSSE providers in any way.</p>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>
