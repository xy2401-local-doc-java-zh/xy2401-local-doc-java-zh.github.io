<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content>
      <meta name="description" content>
      <title>Source Code for JAAS and Java GSS-API Tutorials</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Security Developer’s Guide">
      <meta property="og:description" content>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Security Developer’s Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="security-developer-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2018-09-21T08:42:26-07:00">
      
      <meta name="dcterms.dateCopyrighted" content="1993, 2018">
      <meta name="dcterms.category" content="java">
      <meta name="dcterms.identifier" content="E94828-01">
      
      <meta name="dcterms.product" content="en/java/javase/11">
      <meta name="dcterms.release" content="11">
      <link rel="prev" href="troubleshooting.html" title="Previous" type="text/html">
      <link rel="next" href="related-documentation1.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"java","element_name":"Java","display_in_url":true},"suite":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product_group":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product":{"short_name":"javase","element_name":"Java SE","display_in_url":true},"release":{"short_name":"11","element_name":"11","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Security Developer Guide">
    <meta name="dcterms.isVersionOf" content="SECURITY">
  
                    <script>var w=window;if(w.performance||w.mozPerformance||w.msPerformance||w.webkitPerformance){var d=document;AKSB=w.AKSB||{},AKSB.q=AKSB.q||[],AKSB.mark=AKSB.mark||function(e,_){AKSB.q.push(["mark",e,_||(new Date).getTime()])},AKSB.measure=AKSB.measure||function(e,_,t){AKSB.q.push(["measure",e,_,t||(new Date).getTime()])},AKSB.done=AKSB.done||function(e){AKSB.q.push(["done",e])},AKSB.mark("firstbyte",(new Date).getTime()),AKSB.prof={custid:"322179",ustr:"",originlat:"0",clientrtt:"1",ghostip:"23.212.3.15",ipv6:false,pct:"10",clientip:"45.78.37.67",requestid:"29eff11d",region:"32996",protocol:"",blver:14,akM:"dsca",akN:"ae",akTT:"O",akTX:"1",akTI:"29eff11d",ai:"206465",ra:"false",pmgn:"",pmgi:"",pmp:"",qc:""},function(e){var _=d.createElement("script");_.async="async",_.src=e;var t=d.getElementsByTagName("script"),t=t[t.length-1];t.parentNode.insertBefore(_,t)}(("https:"===d.location.protocol?"https:":"http:")+"//ds-aksb-a.akamaihd.net/aksb.min.js")}</script>
                    <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="troubleshooting.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="related-documentation1.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Security Developer’s Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="java-generic-security-services-java-gss-api1.html" property="item" typeof="WebPage"><span property="name">Java Generic Security Services (Java GSS-API)</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="introduction-jaas-and-java-gss-api-tutorials1.html" property="item" typeof="WebPage"><span property="name">Introduction to JAAS and Java GSS-API Tutorials</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Source Code for JAAS and Java GSS-API Tutorials</li>
            </ol>
            <a id="GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8" name="GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8"></a>
            
            <h2 id="JSSEC-GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8" class="sect2">Source Code for JAAS and Java GSS-API Tutorials</h2>
         </header>
         <div class="ind">
            <div>
               <p></p>
               <div class="section" id="GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__SAMPLESERVER.JAVA-33891DED">
                  <p class="subhead1" id="GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__GUID-D1731C26-5F50-4052-AF58-D505498CD5C7">SampleServer.java</p><pre class="pre codeblock"><code>import org.ietf.jgss.*;
import java.io.*;
import java.net.Socket;
import java.net.ServerSocket;

/**
 * A sample server application that uses JGSS to do mutual authentication
 * with a client using Kerberos as the underlying mechanism. It then
 * exchanges data securely with the client.
 *
 * Every message exchanged with the client includes a 4-byte application-
 * level header that contains the big-endian integer value for the number
 * of bytes that will follow as part of the JGSS token.
 *
 * The protocol is:
 *    1.  Context establishment loop:
 *         a. client sends init sec context token to server
 *         b. server sends accept sec context token to client
 *         ....
 *    2. client sends a wrap token to the server.
 *    3. server sends a mic token to the client for the application
 *       message that was contained in the wrap token.
 */

public class SampleServer  {

    public static void main(String[] args)
        throws IOException, GSSException {

        // Obtain the command-line arguments and parse the port number

        if (args.length != 1) {
            System.err.println("Usage: java &lt;options&gt; Login SampleServer &lt;localPort&gt;");
            System.exit(-1);
        }

        int localPort = Integer.parseInt(args[0]);

        ServerSocket ss = new ServerSocket(localPort);

        GSSManager manager = GSSManager.getInstance();

        while (true) {

            System.out.println("Waiting for incoming connection...");

            Socket socket = ss.accept();
            DataInputStream inStream =
                new DataInputStream(socket.getInputStream());
            DataOutputStream outStream =
                new DataOutputStream(socket.getOutputStream());

            System.out.println("Got connection from client "
                               + socket.getInetAddress());

            /*
             * Create a GSSContext to receive the incoming request
             * from the client. Use null for the server credentials
             * passed in. This tells the underlying mechanism
             * to use whatever credentials it has available that
             * can be used to accept this connection.
             */
            GSSContext context = manager.createContext((GSSCredential)null);

            // Do the context eastablishment loop

            byte[] token = null;

            while (!context.isEstablished()) {

                token = new byte[inStream.readInt()];
                System.out.println("Will read input token of size "
                                   + token.length
                                   + " for processing by acceptSecContext");
                inStream.readFully(token);

                token = context.acceptSecContext(token, 0, token.length);

                // Send a token to the peer if one was generated by
                // acceptSecContext
                if (token != null) {
                    System.out.println("Will send token of size "
                                       + token.length
                                       + " from acceptSecContext.");
                    outStream.writeInt(token.length);
                    outStream.write(token);
                    outStream.flush();
                }
            }

            System.out.print("Context Established! ");
            System.out.println("Client is " + context.getSrcName());
            System.out.println("Server is " + context.getTargName());
            /*
             * If mutual authentication did not take place, then
             * only the client was authenticated to the
             * server. Otherwise, both client and server were
             * authenticated to each other.
             */
            if (context.getMutualAuthState())
                System.out.println("Mutual authentication took place!");

            /*
             * Create a MessageProp which unwrap will use to return
             * information such as the Quality-of-Protection that was
             * applied to the wrapped token, whether or not it was
             * encrypted, etc. Since the initial MessageProp values
             * are ignored, just set them to the defaults of 0 and false.
             */
            MessageProp prop = new MessageProp(0, false);

            /*
             * Read the token. This uses the same token byte array
             * as that used during context establishment.
             */
            token = new byte[inStream.readInt()];
            System.out.println("Will read token of size "
                               + token.length);
            inStream.readFully(token);

            byte[] bytes = context.unwrap(token, 0, token.length, prop);
            String str = new String(bytes);
            System.out.println("Received data \""
                               + str + "\" of length " + str.length());

            System.out.println("Confidentiality applied: "
                               + prop.getPrivacy());

            /*
             * Now generate a MIC and send it to the client. This is
             * just for illustration purposes. The integrity of the
             * incoming wrapped message is guaranteed irrespective of
             * the confidentiality (encryption) that was used.
             */

            /*
             * First reset the QOP of the MessageProp to 0
             * to ensure the default Quality-of-Protection
             * is applied.
             */
            prop.setQOP(0);

            token = context.getMIC(bytes, 0, bytes.length, prop);

            System.out.println("Will send MIC token of size "
                               + token.length);
            outStream.writeInt(token.length);
            outStream.write(token);
            outStream.flush();

            System.out.println("Closing connection with client "
                               + socket.getInetAddress());
            context.dispose();
            socket.close();
        }
    }
}</code></pre></div>
               <!-- class="section" -->
               <div class="section" id="GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__BCSLOGIN.CONF-3389212B">
                  <p class="subhead1" id="GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__GUID-975241C4-B3C8-49D5-A3FB-4404761935D0">bcsLogin.conf</p><pre class="pre codeblock"><code>/** 
 * Login Configuration for JAAS.
 */

com.sun.security.jgss.initiate {
  com.sun.security.auth.module.Krb5LoginModule required;
};

com.sun.security.jgss.accept {
  com.sun.security.auth.module.Krb5LoginModule required storeKey=true; 
};</code></pre></div>
               <!-- class="section" -->
               <div class="section" id="GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__SAMPLECLIENT.JAVA-338923E1">
                  <p class="subhead1" id="GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__GUID-737F17D4-5FAF-4E98-A8AA-5500FE62BC61">SampleClient.java</p><pre class="pre codeblock"><code>import org.ietf.jgss.*;
import java.net.Socket;
import java.io.IOException;
import java.io.DataInputStream;
import java.io.DataOutputStream;

/**
 * A sample client application that uses JGSS to do mutual authentication
 * with a server using Kerberos as the underlying mechanism. It then
 * exchanges data securely with the server.
 *
 * Every message sent to the server includes a 4-byte application-level
 * header that contains the big-endian integer value for the number
 * of bytes that will follow as part of the JGSS token.
 *
 * The protocol is:
 *    1.  Context establishment loop:
 *         a. client sends init sec context token to server
 *         b. server sends accept sec context token to client
 *         ....
 *    2. client sends a wrap token to the server.
 *    3. server sends a MIC token to the client for the application
 *       message that was contained in the wrap token.
 */

public class SampleClient {

    public static void main(String[] args)
       throws IOException, GSSException  {

        // Obtain the command-line arguments and parse the port number

        if (args.length &lt; 3) {
            System.err.println("Usage: java &lt;options&gt; Login SampleClient "
                               + " &lt;server&gt; &lt;hostName&gt; &lt;port&gt;");
            System.exit(-1);
        }

        String server = args[0];
        String hostName = args[1];
        int port = Integer.parseInt(args[2]);

        Socket socket = new Socket(hostName, port);
        DataInputStream inStream =
          new DataInputStream(socket.getInputStream());
        DataOutputStream outStream =
          new DataOutputStream(socket.getOutputStream());

        System.out.println("Connected to server "
                           + socket.getInetAddress());

        /*
         * This Oid is used to represent the Kerberos version 5 GSS-API
         * mechanism. It is defined in RFC 1964. We will use this Oid
         * whenever we need to indicate to the GSS-API that it must
         * use Kerberos for some purpose.
         */
        Oid krb5Oid = new Oid("1.2.840.113554.1.2.2");

        GSSManager manager = GSSManager.getInstance();

        /*
         * Create a GSSName out of the server's name. The null
         * indicates that this application does not wish to make
         * any claims about the syntax of this name and that the
         * underlying mechanism should try to parse it as per whatever
         * default syntax it chooses.
         */
        GSSName serverName = manager.createName(server, null);

        /*
         * Create a GSSContext for mutual authentication with the
         * server.
         *    - serverName is the GSSName that represents the server.
         *    - krb5Oid is the Oid that represents the mechanism to
         *      use. The client chooses the mechanism to use.
         *    - null is passed in for client credentials
         *    - DEFAULT_LIFETIME lets the mechanism decide how long the
         *      context can remain valid.
         * Note: Passing in null for the credentials asks GSS-API to
         * use the default credentials. This means that the mechanism
         * will look among the credentials stored in the current Subject
         * to find the right kind of credentials that it needs.
         */
        GSSContext context = manager.createContext(serverName,
                                        krb5Oid,
                                        null,
                                        GSSContext.DEFAULT_LIFETIME);

        // Set the desired optional features on the context. The client
        // chooses these options.

        context.requestMutualAuth(true);  // Mutual authentication
        context.requestConf(true);  // Will use confidentiality later
        context.requestInteg(true); // Will use integrity later

        // Do the context eastablishment loop

        byte[] token = new byte[0];

        while (!context.isEstablished()) {

            // token is ignored on the first call
            token = context.initSecContext(token, 0, token.length);

            // Send a token to the server if one was generated by
            // initSecContext
            if (token != null) {
                System.out.println("Will send token of size "
                                   + token.length
                                   + " from initSecContext.");
                outStream.writeInt(token.length);
                outStream.write(token);
                outStream.flush();
            }

            // If the client is done with context establishment
            // then there will be no more tokens to read in this loop
            if (!context.isEstablished()) {
                token = new byte[inStream.readInt()];
                System.out.println("Will read input token of size "
                                   + token.length
                                   + " for processing by initSecContext");
                inStream.readFully(token);
            }
        }

        System.out.println("Context Established! ");
        System.out.println("Client is " + context.getSrcName());
        System.out.println("Server is " + context.getTargName());

        /*
         * If mutual authentication did not take place, then only the
         * client was authenticated to the server. Otherwise, both
         * client and server were authenticated to each other.
         */
        if (context.getMutualAuthState())
            System.out.println("Mutual authentication took place!");

        byte[] messageBytes = "Hello There!\0".getBytes();

        /*
         * The first MessageProp argument is 0 to request
         * the default Quality-of-Protection.
         * The second argument is true to request
         * privacy (encryption of the message).
         */
        MessageProp prop =  new MessageProp(0, true);

        /*
         * Encrypt the data and send it across. Integrity protection
         * is always applied, irrespective of confidentiality
         * (i.e., encryption).
         * You can use the same token (byte array) as that used when
         * establishing the context.
         */

        token = context.wrap(messageBytes, 0, messageBytes.length, prop);
        System.out.println("Will send wrap token of size " + token.length);
        outStream.writeInt(token.length);
        outStream.write(token);
        outStream.flush();

        /*
         * Now we will allow the server to decrypt the message,
         * calculate a MIC on the decrypted message and send it back
         * to us for verification. This is unnecessary, but done here
         * for illustration.
         */

        token = new byte[inStream.readInt()];
        System.out.println("Will read token of size " + token.length);
        inStream.readFully(token);
        context.verifyMIC(token, 0, token.length,
                          messageBytes, 0, messageBytes.length,
                          prop);

        System.out.println("Verified received MIC for message.");

        System.out.println("Exiting...");
        context.dispose();
        socket.close();
    }
}</code></pre></div>
               <!-- class="section" -->
               <div class="section" id="GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__JAASACN.JAVA-338927FE">
                  <p class="subhead1" id="GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__GUID-EC9E3B81-D124-40FC-9AE8-A1370FDFC12B">JaasAcn.java</p><pre class="pre codeblock"><code>import javax.security.auth.*;
import javax.security.auth.callback.*;
import javax.security.auth.login.*;
import com.sun.security.auth.callback.TextCallbackHandler;

/**
 * This JaasAcn application attempts to authenticate a user
 * and reports whether or not the authentication was successful.
 */
public class JaasAcn {

    public static void main(String[] args) {

        // Obtain a LoginContext, needed for authentication. Tell it
        // to use the LoginModule implementation specified by the
        // entry named "JaasSample" in the JAAS login configuration
        // file and to also use the specified CallbackHandler.
        LoginContext lc = null;
        try {
            lc = new LoginContext("JaasSample", new TextCallbackHandler());
        } catch (LoginException le) {
            System.err.println("Cannot create LoginContext. "
                + le.getMessage());
            System.exit(-1);
        } catch (SecurityException se) {
            System.err.println("Cannot create LoginContext. "
                + se.getMessage());
            System.exit(-1);
        }

        try {

            // attempt authentication
            lc.login();

        } catch (LoginException le) {

            System.err.println("Authentication failed:");
            System.err.println("  " + le.getMessage());
            System.exit(-1);

        }

        System.out.println("Authentication succeeded!");

    }
}</code></pre></div>
               <!-- class="section" -->
               <div class="section" id="GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__JASS.CONF-33892AE7">
                  <p class="subhead1" id="GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__GUID-3CFE3338-909B-44F8-88C3-07A47C44F3D3">jass.conf</p><pre class="pre codeblock"><code>/** Login Configuration for the JaasAcn and
 ** JaasAzn Applications 
 **/

JaasSample {
   com.sun.security.auth.module.Krb5LoginModule required;
};</code></pre></div>
               <!-- class="section" -->
               <div class="section" id="GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__JASSACN.POLICY-33892D36">
                  <p class="subhead1" id="GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__GUID-2E0811AA-4C95-4520-9FC6-3AE69D62AD0F">jassacn.policy</p><pre class="pre codeblock"><code>/** Java Access Control Policy for the JaasAcn Application **/


grant codebase "file:./JaasAcn.jar" {

   permission javax.security.auth.AuthPermission "createLoginContext.JaasSample";
};
</code></pre></div>
               <!-- class="section" -->
               <div class="section" id="GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__JAASAZN.JAVA-33892F00">
                  <p class="subhead1" id="GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__GUID-41E8D915-0F67-4BAB-89B1-E00ACD3FE197">JaasAzn.java</p><pre class="pre codeblock"><code>import javax.security.auth.Subject;
import javax.security.auth.callback.*;
import javax.security.auth.login.*;
import com.sun.security.auth.callback.TextCallbackHandler;
import java.security.PrivilegedAction;

/**
 * This JaasAzn application attempts to authenticate a user
 * and reports whether or not the authentication was successful.
 * If successful, it then sets up subsequent execution of
 * code in the run method of the SampleAction class such that
 * access control checks for security-sensitive operations will be
 * based on the user running the code.
 */
public class JaasAzn {

    public static void main(String[] args) {

        // Obtain a LoginContext, needed for authentication. Tell it
        // to use the LoginModule implementation specified by the
        // entry named "JaasSample" in the JAAS login configuration
        // file and to also use the specified CallbackHandler.
        LoginContext lc = null;
        try {
            lc = new LoginContext("JaasSample", new TextCallbackHandler());
        } catch (LoginException le) {
            System.err.println("Cannot create LoginContext. "
                + le.getMessage());
            System.exit(-1);
        } catch (SecurityException se) {
            System.err.println("Cannot create LoginContext. "
                + se.getMessage());
            System.exit(-1);
        }

        try {

            // attempt authentication
            lc.login();

        } catch (LoginException le) {

            System.err.println("Authentication failed:");
            System.err.println("  " + le.getMessage());
            System.exit(-1);

        }

        System.out.println("Authentication succeeded!");

        // now try to execute the SampleAction as the authenticated Subject
        Subject mySubject = lc.getSubject();
        PrivilegedAction action = new SampleAction();
        Subject.doAsPrivileged(mySubject, action, null);

    }
}</code></pre></div>
               <!-- class="section" -->
               <div class="section" id="GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__SAMPLEACTION.JAVA-33893145">
                  <p class="subhead1" id="GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__GUID-854570DB-DCBB-4FB1-87E8-3E99DD81219F">SampleAction.java</p><pre class="pre codeblock"><code>import java.io.File;
import java.security.PrivilegedAction;

/**
 * This is a sample PrivilegedAction implementation, designed to be
 * used with the JaasAzn class.
 */
public class SampleAction implements PrivilegedAction {

    /**
     * This sample PrivilegedAction performs the following operations:
     * &lt;ul&gt;
     * &lt;li&gt; Access the System property &lt;i&gt;java.home&lt;/i&gt;
     * &lt;li&gt; Access the System property &lt;i&gt;user.home&lt;/i&gt;
     * &lt;li&gt; Access the file &lt;i&gt;foo.txt&lt;/i&gt;
     * &lt;/ul&gt;
     *
     * @return &lt;code&gt;null&lt;/code&gt; in all cases.
     *
     * @exception SecurityException if the caller does not have permission
     *          to perform any of the operations listed above.
     */
    public Object run() {
        System.out.println("\nYour java.home property value is: "
                            +System.getProperty("java.home"));

        System.out.println("\nYour user.home property value is: "
                            +System.getProperty("user.home"));

        File f = new File("foo.txt");
        System.out.print("\nfoo.txt does ");
        if (!f.exists())
            System.out.print("not ");
        System.out.println("exist in the current working directory.");
        return null;
    }
}</code></pre></div>
               <!-- class="section" -->
               <div class="section" id="GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__JASSAZN.POLICY-3389344E">
                  <p class="subhead1" id="GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__GUID-5F2EBCCF-9010-417E-B056-A38155F54964">jassazn.policy</p><pre class="pre codeblock"><code>/** Java Access Control Policy for the JaasAzn Application **/

/** Code-Based Access Control Policy for JaasAzn **/

grant codebase "file:./JaasAzn.jar" {

   permission javax.security.auth.AuthPermission 
                    "createLoginContext.JaasSample";
   permission javax.security.auth.AuthPermission "doAsPrivileged";
};


/** User-Based Access Control Policy for the SampleAction class
 ** instantiated by JaasAzn 
 **/

grant	codebase "file:./SampleAction.jar",
    Principal javax.security.auth.kerberos.KerberosPrincipal 
        "your_user_name@your_realm"  {

   permission java.util.PropertyPermission "java.home", "read";
   permission java.util.PropertyPermission "user.home", "read";
   permission java.io.FilePermission "foo.txt", "read";
};</code></pre></div>
               <!-- class="section" -->
               <div class="section" id="GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__LOGIN.JAVA-338935D0">
                  <p class="subhead1" id="GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__GUID-6B7CE80E-7FCC-4FEA-A727-16DB14874BB2">Login.java</p><pre class="pre codeblock"><code>import java.io.*;
import java.lang.reflect.*;
import java.util.Arrays;

import javax.security.auth.callback.*;
import javax.security.auth.login.*;
import javax.security.auth.Subject;
import com.sun.security.auth.callback.TextCallbackHandler;

/**
 * &lt;p&gt; This class authenticates a &lt;code&gt;Subject&lt;/code&gt; and then
 * executes a specified application as that &lt;code&gt;Subject&lt;/code&gt;.
 * To use this class, the java interpreter would typically be invoked as:
 *
 * &lt;pre&gt;
 *    % java -Djava.security.manager \
 *        Login \
 *        &lt;applicationclass&gt; &lt;applicationClass_args&gt;
 * &lt;/pre&gt;
 *
 * &lt;p&gt; &lt;i&gt;applicationClass&lt;/i&gt; represents the application to be executed
 * as the authenticated &lt;code&gt;Subject&lt;/code&gt;,
 * and &lt;i&gt;applicationClass_args&lt;/i&gt; are passed as arguments to
 * &lt;i&gt;applicationClass&lt;/i&gt;.
 *
 * &lt;p&gt; To perform the authentication, &lt;code&gt;Login&lt;/code&gt; uses a
 * &lt;code&gt;LoginContext&lt;/code&gt;.  A &lt;code&gt;LoginContext&lt;/code&gt; relies on a
 * &lt;code&gt;Configuration&lt;/code&gt; to determine the modules that should be used
 * to perform the actual authentication.  The location of the Configuration
 * is dependent upon each Configuration implementation.
 * The default Configuration implementation
 * (&lt;code&gt;com.sun.security.auth.login.ConfigFile&lt;/code&gt;)
 * allows the Configuration location to be specified (among other ways)
 * via the &lt;code&gt;java.security.auth.login.config&lt;/code&gt; system property.
 * Therefore, the &lt;code&gt;Login&lt;/code&gt; class can also be invoked as:
 *
 * &lt;pre&gt;
 *    % java -Djava.security.manager \
 *        -Djava.security.auth.login.config=&lt;configuration_url&gt; \
 *        Login \
 *        &lt;your_application_class&gt; &lt;your_application_class_args&gt;
 * &lt;/pre&gt;
 */

public class Login {

    /**
     * &lt;p&gt; Instantate a &lt;code&gt;LoginContext&lt;/code&gt; using the
     * provided application classname as the index for the login
     * &lt;code&gt;Configuration&lt;/code&gt;.  Authenticate the &lt;code&gt;Subject&lt;/code&gt;
     * (three retries are allowed) and invoke
     * &lt;code&gt;Subject.doAsPrivileged&lt;/code&gt;
     * with the authenticated &lt;code&gt;Subject&lt;/code&gt; and a
     * &lt;code&gt;PrivilegedExceptionAction&lt;/code&gt;.
     * The &lt;code&gt;PrivilegedExceptionAction&lt;/code&gt;
     * loads the provided application class, and then invokes
     * its public static &lt;code&gt;main&lt;/code&gt; method, passing it
     * the application arguments.
     *
     * &lt;p&gt;
     *
     * @param args the arguments for &lt;code&gt;Login&lt;/code&gt;.  The first
     *          argument must be the class name of the application to be
     *          invoked once authentication has completed, and the
     *          subsequent arguments are the arguments to be passed
     *          to that application's public static &lt;code&gt;main&lt;/code&gt; method.
     */
    public static void main(String[] args) {

        // check for the application's main class
        if (args == null || args.length == 0) {
            System.err.println("Invalid arguments: " +
                "Did not provide name of application class.");
            System.exit(-1);
        }

        LoginContext lc = null;
        try {
            lc = new LoginContext(args[0], new TextCallbackHandler());
        } catch (LoginException le) {
            System.err.println("Cannot create LoginContext. "
                + le.getMessage());
            System.exit(-1);
        } catch (SecurityException se) {
            System.err .println("Cannot create LoginContext. "
                + se.getMessage());
            System.exit(-1);
        }

        // the user has 3 attempts to authenticate successfully
        int i;
        for (i = 0; i &lt; 3; i++) {
            try {

                // attempt authentication
                lc.login();

                // if we return with no exception, authentication succeeded
                break;

            } catch (AccountExpiredException aee) {

                System.err.println("Your account has expired.  " +
                                "Please notify your administrator.");
                System.exit(-1);

            } catch (CredentialExpiredException cee) {

                System.err.println("Your credentials have expired.");
                System.exit(-1);

            } catch (FailedLoginException fle) {

                System.err.println("Authentication Failed");
                try {
                      Thread.currentThread().sleep(3000);
                } catch (Exception e) {
                      // ignore
                }

            } catch (Exception e) {

                System.err.println("Unexpected Exception - unable to continue");
                e.printStackTrace();
                System.exit(-1);
            }
        }

        // did they fail three times?
        if (i == 3) {
            System.err.println("Sorry");
            System.exit(-1);
        }

        // push the subject into the current ACC
        try {
            Subject.doAsPrivileged(lc.getSubject(),
                                   new  MyAction(args),
                                   null);
        } catch (java.security.PrivilegedActionException pae) {
            pae.printStackTrace();
            System.exit(-1);
        }

        System.exit(0);
    }
}

class MyAction implements java.security.PrivilegedExceptionAction {

    String[] origArgs;

    public MyAction(String[] origArgs) {
        this.origArgs = (String[])origArgs.clone();
    }

    public Object run() throws Exception {

        // get the ContextClassLoader
        ClassLoader cl = Thread.currentThread().getContextClassLoader();

        try {
            // get the application class's main method
            Class c = Class.forName(origArgs[0], true, cl);
            Class[] PARAMS = { origArgs.getClass() };
            java.lang.reflect.Method mainMethod = c.getMethod("main", PARAMS);

            // invoke the main method with the remaining args
            String[] appArgs = new String[origArgs.length - 1];
            System.arraycopy(origArgs, 1, appArgs, 0, origArgs.length - 1);
            Object[] args = { appArgs };
            mainMethod.invoke(null /*ignored*/, args);
        } catch (Exception e) {
            throw new java.security.PrivilegedActionException(e);
        }

        // successful completion
        return null;
    }
}</code></pre></div>
               <!-- class="section" -->
               <div class="section" id="GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__SAMPLE.JAVA-3389388B">
                  <p class="subhead1" id="GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__GUID-08263150-7544-4A7B-9708-B580103D1AA1">Sample.java</p><pre class="pre codeblock"><code>import java.io.File;

public class Sample {

    /**
     * This sample class performs the following operations:
     * &lt;ul&gt;
     * &lt;li&gt; Access the System property &lt;i&gt;java.home&lt;/i&gt;
     * &lt;li&gt; Access the System property &lt;i&gt;user.home&lt;/i&gt;
     * &lt;li&gt; Access the file &lt;i&gt;foo.txt&lt;/i&gt;
     * &lt;/ul&gt;
     *
     * @exception SecurityException if the caller does not have permission
     *          to perform any of the operations listed above.
     */
    public static void main (String[] args) throws SecurityException {

        // If there were any arguments to read, we'd do it here.

        System.out.println("\nYour java.home property value is: "
                            +System.getProperty("java.home"));

        System.out.println("\nYour user.home property value is: "
                            +System.getProperty("user.home"));

        File f = new File("foo.txt");
        System.out.print("\nfoo.txt does ");
        if (!f.exists())
            System.out.print("not ");
        System.out.println("exist in the current working directory.");
    }
}</code></pre></div>
               <!-- class="section" -->
               <div class="section" id="GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__SAMPLE.CONF-33893A5C">
                  <p class="subhead1" id="GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__GUID-7C51261E-F616-4828-BB59-DDD9BE3D53E1">sample.conf</p><pre class="pre codeblock"><code>/** Login Configuration for the Sample Application **/

Sample {
   com.sun.security.auth.module.Krb5LoginModule required;
};</code></pre></div>
               <!-- class="section" -->
               <div class="section" id="GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__SAMPLE.POLICY-33893EE3">
                  <p class="subhead1" id="GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__GUID-6EEA9F37-8D89-4CB7-BC6F-7AEE068FE687">sample.policy</p><pre class="pre codeblock"><code>/** Access Control Policy for the Sample Application **/


grant codebase "file:./Login.jar" {
   permission java.security.AllPermission;
};


grant	codebase "file:./Sample.jar",
    Principal javax.security.auth.kerberos.KerberosPrincipal 
        "your_user_name@your_realm"  {

   permission java.util.PropertyPermission "java.home", "read";
   permission java.util.PropertyPermission "user.home", "read";
   permission java.io.FilePermission "foo.txt", "read";
};</code></pre></div>
               <!-- class="section" -->
               <div class="section" id="GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__CSLOGIN.CONF-33894173">
                  <p class="subhead1" id="GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__GUID-AA6D1F08-F8C6-40AF-A578-089252AF05A5">csLogin.conf</p><pre class="pre codeblock"><code>/** 
 * Login Configuration for JAAS.
 */

SampleClient {
  com.sun.security.auth.module.Krb5LoginModule required;
};

SampleServer {
  com.sun.security.auth.module.Krb5LoginModule required storeKey=true principal="service_principal@your_realm";
};</code></pre></div>
               <!-- class="section" -->
               <div class="section" id="GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__CLIENT.POLICY-33894283">
                  <p class="subhead1" id="GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__GUID-7F16EDCB-25A0-40CE-9D9D-BB40FE2D02BF">client.policy</p><pre class="pre codeblock"><code>grant CodeBase "file:./Login.jar" {
        permission java.security.AllPermission;
};

grant CodeBase "file:./SampleClient.jar", 
	Principal javax.security.auth.kerberos.KerberosPrincipal 
		"your_user_name@your_realm" {

	permission java.net.SocketPermission "*", "connect";

	permission javax.security.auth.kerberos.ServicePermission
		"krbtgt/your_realm@your_realm", 
		"initiate";

	permission javax.security.auth.kerberos.ServicePermission
		"service_principal@your_realm", 
		"initiate";
};</code></pre></div>
               <!-- class="section" -->
               <div class="section" id="GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__SERVER.POLICY-33894513">
                  <p class="subhead1" id="GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__GUID-A093E102-2084-40D0-B76B-C7B61AB5E098">server.policy</p><pre class="pre codeblock"><code>grant CodeBase "file:./Login.jar" {
        permission java.security.AllPermission;
};

grant CodeBase "file:./SampleServer.jar" 
	Principal javax.security.auth.kerberos.KerberosPrincipal 
		"service_principal@your_realm" {

	permission java.net.SocketPermission "*", "accept";

	permission javax.security.auth.kerberos.ServicePermission
		"service_principal@your_realm", "accept";
};</code></pre></div>
               <!-- class="section" -->
               <div class="section" id="GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__SAMPLESERVERIMP.JAVA-33894617">
                  <p class="subhead1" id="GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__GUID-3A33AB5A-6882-4219-92B4-32DD10295269">SampleServerImp.java</p><pre class="pre codeblock"><code>import org.ietf.jgss.*;
import java.io.*;
import java.net.Socket;
import java.net.ServerSocket;
import javax.security.auth.Subject;
import java.security.PrivilegedAction;

/**
 * A sample server application that uses JGSS to do mutual authentication
 * with a client using Kerberos as the underlying mechanism. It then
 * exchanges data securely with the client.
 *
 * Every message exchanged with the client includes a 4-byte application-
 * level header that contains the big-endian integer value for the number
 * of bytes that will follow as part of the JGSS token.
 *
 * The protocol is:
 *    1.  Context establishment loop:
 *         a. client sends init sec context token to server
 *         b. server sends accept sec context token to client
 *         ....
 *    2. client sends a wrap token to the server.
 *    3. server sends a mic token to the client for the application
 *       message that was contained in the wrap token.
 */

public class SampleServerImp  {

    public static void main(String[] args)
        throws IOException, GSSException {

        // Obtain the command-line arguments and parse the port number

        if (args.length != 1) {
            System.err.println("Usage: java &lt;options&gt; Login SampleServer &lt;localPort&gt;");
            System.exit(-1);
        }

        int localPort = Integer.parseInt(args[0]);

        ServerSocket ss = new ServerSocket(localPort);

        GSSManager manager = GSSManager.getInstance();

        while (true) {

            System.out.println("Waiting for incoming connection...");

            Socket socket = ss.accept();
            DataInputStream inStream =
                new DataInputStream(socket.getInputStream());
            DataOutputStream outStream =
                new DataOutputStream(socket.getOutputStream());

            System.out.println("Got connection from client "
                               + socket.getInetAddress());

            /*
             * Create a GSSContext to receive the incoming request
             * from the client. Use null for the server credentials
             * passed in. This tells the underlying mechanism
             * to use whatever credentials it has available that
             * can be used to accept this connection.
             */
            GSSContext context = manager.createContext((GSSCredential)null);

            // Do the context eastablishment loop

            byte[] token = null;

            while (!context.isEstablished()) {

                token = new byte[inStream.readInt()];
                System.out.println("Will read input token of size "
                                   + token.length
                                   + " for processing by acceptSecContext");
                inStream.readFully(token);

                token = context.acceptSecContext(token, 0, token.length);

                // Send a token to the peer if one was generated by
                // acceptSecContext
                if (token != null) {
                    System.out.println("Will send token of size "
                                       + token.length
                                       + " from acceptSecContext.");
                    outStream.writeInt(token.length);
                    outStream.write(token);
                    outStream.flush();
                }
            }

            System.out.println("Context Established! ");
            System.out.println("Client is " + context.getSrcName());
            System.out.println("Server is " + context.getTargName());
            /*
             * If mutual authentication did not take place, then
             * only the client was authenticated to the
             * server. Otherwise, both client and server were
             * authenticated to each other.
             */
            if (context.getMutualAuthState())
                System.out.println("Mutual authentication took place!");

            /*
             * Create a MessageProp which unwrap will use to return
             * information such as the Quality-of-Protection that was
             * applied to the wrapped token, whether or not it was
             * encrypted, etc. Since the initial MessageProp values
             * are ignored, just set them to the defaults of 0 and false.
             */
            MessageProp prop = new MessageProp(0, false);

            /*
             * Read the token. This uses the same token byte array
             * as that used during context establishment.
             */
            token = new byte[inStream.readInt()];
            System.out.println("Will read token of size "
                               + token.length);
            inStream.readFully(token);

            byte[] bytes = context.unwrap(token, 0, token.length, prop);
            String str = new String(bytes);
            System.out.println("Received data \""
                               + str + "\" of length " + str.length());

            System.out.println("Confidentiality applied: "
                               + prop.getPrivacy());

            /*
             * Now generate a MIC and send it to the client. This is
             * just for illustration purposes. The integrity of the
             * incoming wrapped message is guaranteed irrespective of
             * the confidentiality (encryption) that was used.
             */

            /*
             * First reset the QOP of the MessageProp to 0
             * to ensure the default Quality-of-Protection
             * is applied.
             */
            prop.setQOP(0);

            token = context.getMIC(bytes, 0, bytes.length, prop);

            System.out.println("Will send MIC token of size "
                               + token.length);
            outStream.writeInt(token.length);
            outStream.write(token);
            outStream.flush();


            /*
             * Impersonate client
             */

            System.out.println("Impersonating client.");

            /*
             * Extract the KerberosPrincipal from the client GSSName and populate
             * it in the principal set of a new Subject. Pass in a null for
             * credentials. If we were to pass in the delegated GSSCredential
             * instead of null, then the resulting Subject's private credential
             * set would also be populated.
             */
            GSSName clientGSSName = context.getSrcName();
            System.out.println("clientGSSName: " + clientGSSName);
            Subject client =
                com.sun.security.jgss.GSSUtil.createSubject(clientGSSName,
                                                     null);

            /*
             * Construct an action that will read a file meant only for the
             * client
             */
            PrivilegedAction readFile =
                new ReadFileAction(clientGSSName.toString());

            /*
             * Invoke the action via a doAsPrivileged. This allows the
             * action to be executed as the client subject, and it also runs
             * that code as privileged. This means that any permission checking
             * that happens beyond this point applies only to the code being
             * run as the client.
             */
            Subject.doAsPrivileged(client, readFile, null);



            /*
             * Clean up
             */


            System.out.println("Closing connection with client "
                               + socket.getInetAddress());
            context.dispose();
            socket.close();
        }
    }
}</code></pre></div>
               <!-- class="section" -->
               <div class="section" id="GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__READFILEACTION.JAVA-33894842">
                  <p class="subhead1" id="GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__GUID-659BD583-F572-4842-83EC-FB6B4B4C7CAF">ReadFileAction.java</p><pre class="pre codeblock"><code>import java.security.PrivilegedAction;
import java.io.*;

/**
 * This class implements the PrivilegedAction interface to demonstrate the
 * reading of a file that belongs to the client. This code will be
 * executed by the server while impersonating the client principal.
 */
public class ReadFileAction implements PrivilegedAction {

    private String fileName;

    /**
     * Contructs a ReadFileAction instance.
     *
     * @param kerberosPrincipalName the name of the Kerberos principal
     * who owns the file that will be read. The filename is constructed
     * from the name of the principal.
     */
    public ReadFileAction(String kerberosPrincipalName) {
        /*
         * Separate the realm component from the name and use the rest of
         * it for constructing the filename. If the principal name is
         * "joe@REALM" then the file that will be read is
         * "data/joe_info.txt". The path separator "/" might be "\" in the
         * case of Windows.
         */
        int realmSeparatorPos = kerberosPrincipalName.lastIndexOf('@');
        fileName = "data" + File.separatorChar
            + kerberosPrincipalName.substring(0, realmSeparatorPos)
            + "_info.txt";
    }

    /**
     * Does the actual reading of the file. It displays the text contained
     * in the file.
     */
    public Object run() {
        System.out.println("===============================================");
        System.out.println("Reading file: " + fileName);
        try {
            BufferedReader reader = new BufferedReader(new FileReader(fileName));
            String str = reader.readLine();
            while (str != null) {
                System.out.println(str);
                str = reader.readLine();
            }
        } catch (IOException e) {
            System.err.println(e);
        }
        System.out.println("===============================================");
        return null;
    }
}</code></pre></div>
               <!-- class="section" -->
               <div class="section" id="GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__SERVERIMP.POLICY-33894A6C">
                  <p class="subhead1" id="GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__GUID-04037A35-36EA-4C63-B9CD-0045E17B94E3">serverimp.policy</p><pre class="pre codeblock"><code>grant CodeBase "file:./Login.jar" {
        permission java.security.AllPermission;
};

grant CodeBase "file:./SampleServerImp.jar" 
	Principal javax.security.auth.kerberos.KerberosPrincipal 
		"service_principal@your_realm" {

	permission java.net.SocketPermission "*", "accept";

	permission javax.security.auth.kerberos.ServicePermission
		"service_principal@your_realm", "accept";

	permission javax.security.auth.AuthPermission "doAsPrivileged";
};

grant CodeBase "file:./ReadFileAction.jar" 
	Principal javax.security.auth.kerberos.KerberosPrincipal 
		"your_user_name@your_realm" {

	permission java.io.FilePermission 
		"data/your_user_name_info.txt", "read";
};</code></pre></div>
               <!-- class="section" -->
               <div class="section" id="GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__CSIMPLOGIN.CONF-37761B67">
                  <p class="subhead1" id="GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__GUID-47807266-3BC0-4D89-901D-87CADA837248">csImpLogin.conf</p><pre class="pre codeblock"><code>/** 
 * Login Configuration for JAAS.
 */

SampleClient {
  com.sun.security.auth.module.Krb5LoginModule required;
};

SampleServerImp {
  com.sun.security.auth.module.Krb5LoginModule required storeKey=true principal="service_principal@your_realm";
};</code></pre></div>
               <!-- class="section" -->
            </div>
         </div>
      </article>
   </body>
</html>
