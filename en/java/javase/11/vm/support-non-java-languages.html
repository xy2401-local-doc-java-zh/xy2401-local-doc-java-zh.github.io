<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="This chapter describes the Non-Java Language features in the Java Virtual Machine.">
      <meta name="description" content="This chapter describes the Non-Java Language features in the Java Virtual Machine.">
      <title>Support for Non-Java Languages</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Java Virtual Machine Guide">
      <meta property="og:description" content="This chapter describes the Non-Java Language features in the Java Virtual Machine.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Java Virtual Machine Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="java-virtual-machine-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2018-09-20T02:39:56-07:00">
      <meta name="dcterms.title" content="Java Virtual Machine Guide">
      <meta name="dcterms.dateCopyrighted" content="1993, 2018">
      <meta name="dcterms.category" content="java">
      <meta name="dcterms.identifier" content="E95202-01">
      
      <meta name="dcterms.product" content="en/java/javase/11">
      <meta name="dcterms.release" content="11">
      <link rel="prev" href="java-hotspot-virtual-machine-performance-enhancements.html" title="Previous" type="text/html">
      <link rel="next" href="signal-chaining.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"java","element_name":"Java","display_in_url":true},"suite":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product_group":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product":{"short_name":"javase","element_name":"Java SE","display_in_url":true},"release":{"short_name":"11","element_name":"11","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="VM">
  <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="java-hotspot-virtual-machine-performance-enhancements.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="signal-chaining.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Java Virtual Machine Guide</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Support for Non-Java Languages</li>
            </ol>
            <a id="GUID-CC00C59C-0426-487A-A836-A40E5E67A0CE" name="GUID-CC00C59C-0426-487A-A836-A40E5E67A0CE"></a>
            
            <h2 id="JSJVM-GUID-CC00C59C-0426-487A-A836-A40E5E67A0CE" class="sect2"><span class="enumeration_chapter">6 </span>Support for Non-Java Languages
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This chapter describes the Non-Java Language features in the Java Virtual Machine.</p>
               <div class="section">
                  <p class="subhead1" id="GUID-CC00C59C-0426-487A-A836-A40E5E67A0CE__GUID-7345B5CB-173A-4352-B342-DD9163EFDAF0">Topics:</p>
                  <ul style="list-style-type: disc;">
                     <li><a href="support-non-java-languages.html#GUID-66752E7E-B9A5-4E86-9E98-C2733B4987FA">Introduction to Non-Java Language Features</a></li>
                     <li><a href="support-non-java-languages.html#GUID-B4C667E0-62EE-4124-82AA-D91FAF53F587">Static and Dynamic Typing</a></li>
                     <li><a href="support-non-java-languages.html#GUID-99173E26-45BC-40F9-976B-C19D67D1DB74">The Challenge of Compiling Dynamically-Typed Languages</a></li>
                     <li><a href="support-non-java-languages.html#GUID-7FDE8A77-F901-455B-8871-E01B61A9A504">The invokedynamic Instruction</a></li>
                  </ul>
               </div>
               <!-- class="section" -->
            </div>
            <div class="sect2"><a id="GUID-66752E7E-B9A5-4E86-9E98-C2733B4987FA" name="GUID-66752E7E-B9A5-4E86-9E98-C2733B4987FA"></a><h3 id="JSJVM-GUID-66752E7E-B9A5-4E86-9E98-C2733B4987FA" class="sect3">Introduction to Non-Java Language Features</h3>
               <div>
                  <p>The Java Platform, Standard Edition (Java SE) enables the development of applications that have the following features:</p>
                  <ul style="list-style-type: disc;">
                     <li>They can be written once and run anywhere</li>
                     <li>They can be run securely because of the Java sandbox security model</li>
                     <li>They are easy to package and deliver</li>
                  </ul>
                  <p>The Java SE platform provides robust support in the following areas:</p>
                  <ul style="list-style-type: disc;">
                     <li>Concurrency</li>
                     <li>Garbage collection</li>
                     <li>Reflective access to classes and objects</li>
                     <li>JVM Tool Interface (JVM TI): A native programming interface for use by tools. It provides both a way to inspect the state and to control the execution of applications running in the JVM.</li>
                  </ul>
                  <p>Oracle's HotSpot JVM provides the following tools and features:</p>
                  <ul style="list-style-type: disc;">
                     <li>DTrace: A dynamic tracing utility that monitors the behavior of applications and the operating system.</li>
                     <li>Performance optimizations</li>
                     <li>PrintAssembly: A Java HotSpot option that prints assembly code for bytecoded and native methods.</li>
                  </ul>
                  <p>The Java SE 7 platform enables non-Java languages to use the infrastructure and potential performance optimizations of the JVM. The key mechanism is the <code class="codeph">invokedynamic</code> instruction, which simplifies the implementation of compilers and runtime systems for dynamically-typed languages on the JVM.
                  </p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-B4C667E0-62EE-4124-82AA-D91FAF53F587" name="GUID-B4C667E0-62EE-4124-82AA-D91FAF53F587"></a><h3 id="JSJVM-GUID-B4C667E0-62EE-4124-82AA-D91FAF53F587" class="sect3">Static and Dynamic Typing</h3>
               <div>
                  <p>A programming language is statically-typed if it performs type checking at compile time. Type checking is the process of verifying that a program is type safe. A program is type safe if the arguments of all of its operations are the correct type.</p>
                  <p>Java is a statically-typed language. Type information is available for class and instance variables, method parameters, return values, and other variables when a program is compiled. The compiler for the Java programming language uses this type information to produce strongly typed bytecode, which can then be efficiently executed by the JVM at runtime.</p>
                  <p>The following example of a Hello World program demonstrates static typing. Types are shown in <span class="bold">bold</span>.
                  </p><pre class="pre codeblock"><code>
import <span class="bold">java.util.Date;</span>

public class HelloWorld {
    public static <span class="bold">void</span> main(<span class="bold">String[]</span> argv) {
        <span class="bold">String</span> hello = "Hello ";
        <span class="bold">Date</span> currDate = new Date();
        for (<span class="bold">String</span> a : argv) {
            System.out.println(hello + a);
            System.out.println("Today's date is: " + currDate);
        }
    }
}
</code></pre><p>A programming language is dynamically-typed if it performs type checking at runtime. JavaScript and Ruby are examples of dynamically typed languages. These languages verify at runtime, rather than at compile time, that values in an application conform to expected types. Typically, type information for these languages is not available when an application is compiled. The type of an object is determined only at runtime. In the past, it was difficult to efficiently implement dynamically-typed languages on the JVM.</p>
                  <p>The following is an example of the Hello World program written in the Ruby programming language:</p><pre class="pre codeblock"><code>
#!/usr/bin/env ruby
require 'date'

hello = "Hello "
currDate = DateTime.now
ARGV.each do|a|
  puts hello + a
  puts "Date and time: " + currDate.to_s
end
</code></pre><p>In the example, every name is introduced without a type declaration. The main program is not located inside a holder type (the Java class <code class="codeph">HelloWorld</code>). The Ruby equivalent of the Java <code class="codeph">for</code> loop is inside the dynamic type <code class="codeph">ARGV</code> variable. The body of the loop is contained in a block called a closure, which is a common feature in dynamic languages.
                  </p>
               </div>
               <div class="sect3"><a id="GUID-917118E0-0CAD-4EC8-B65F-410357ED70F3" name="GUID-917118E0-0CAD-4EC8-B65F-410357ED70F3"></a><h4 id="JSJVM-GUID-917118E0-0CAD-4EC8-B65F-410357ED70F3" class="sect4">Statically-Typed Languages Are Not Necessarily Strongly-Typed Languages</h4>
                  <div>
                     <p>Statically-typed programming languages can employ strong typing or weak typing. A programming language that employs strong typing specifies restrictions on the types of values supplied to its operations, and it prevents the execution of an operation if its arguments have the wrong type. A language that employs weak typing would implicitly convert (or cast) arguments of an operation if those arguments have the wrong or incompatible types.</p>
                     <p>Dynamically-typed languages can employ strong typing or weak typing. For example, the Ruby programming language is dynamically-typed and strongly-typed. When a variable is initialized with a value of some type, the Ruby programming language does not implicitly convert the variable into another data type. </p>
                     <p>In the following example, the Ruby programming language does not implicitly cast the number 2, which has a <code class="codeph">Fixnum</code> type, to a string.
                     </p><pre class="pre codeblock"><code>
a = "40"
b = a + 2
</code></pre></div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-99173E26-45BC-40F9-976B-C19D67D1DB74" name="GUID-99173E26-45BC-40F9-976B-C19D67D1DB74"></a><h3 id="JSJVM-GUID-99173E26-45BC-40F9-976B-C19D67D1DB74" class="sect3">The Challenge of Compiling Dynamically-Typed Languages</h3>
               <div>
                  <p>Consider the following dynamically-typed method, <code class="codeph">addtwo</code>, which adds any two numbers (which can be of any numeric type) and returns their sum:
                  </p><pre class="pre codeblock"><code>
def addtwo(a, b)
       a + b;
end
</code></pre><p>Suppose your organization is implementing a compiler and runtime system for the programming language in which the method <code class="codeph">addtwo</code> is written. In a strongly-typed language, whether typed statically or dynamically, the behavior of <code class="codeph">+</code> (the addition operator) depends on the operand types. A compiler for a statically-typed language chooses the appropriate implementation of <code class="codeph">+</code> based on the static types of <code class="codeph">a</code> and <code class="codeph">b</code>. For example, a Java compiler implements <code class="codeph">+</code> with the <code class="codeph">iadd</code> JVM instruction if the types of <code class="codeph">a</code> and <code class="codeph">b</code> are <code class="codeph">int</code>. The addition operator is compiled to a method call because the JVM <code class="codeph">iadd</code> instruction requires the operand types to be statically known.
                  </p>
                  <p>A compiler for a dynamically-typed language must defer the choice until runtime. The statement <code class="codeph">a + b</code> is compiled as the method call <code class="codeph">+(a, b)</code>, where <code class="codeph">+</code> is the method name. A method named <code class="codeph">+</code> is permitted in the JVM but not in the Java programming language. If the runtime system for the dynamically-typed language is able to identify that <code class="codeph">a</code> and <code class="codeph">b</code> are variables of integer type, then the runtime system would prefer to call an implementation of <code class="codeph">+</code> that is specialized for integer types rather than arbitrary object types.
                  </p>
                  <p>The challenge of compiling dynamically-typed languages is how to implement a runtime system that can choose the most appropriate implementation of a method or function — after the program has been compiled. Treating all variables as objects of <code class="codeph">Object</code> type would not work efficiently; the <code class="codeph">Object</code> class does not contain a method named <code class="codeph">+</code>.
                  </p>
                  <p>In Java SE 7 and later, the <code class="codeph">invokedynamic</code> instruction enables the runtime system to customize the linkage between a call site and a method implementation. In this example, the <code class="codeph">invokedynamic</code> call site is <code class="codeph">+</code>. An <code class="codeph">invokedynamic</code> call site is linked to a method by means of a <span class="italic">bootstrap method</span>, which is a method specified by the compiler for the dynamically-typed language that is called once by the JVM to link the site. Assuming the compiler emitted an <code class="codeph">invokedynamic</code> instruction that invokes <code class="codeph">+</code>, and assuming that the runtime system knows about the method <code class="codeph">adder(Integer,Integer)</code>, the runtime can link the <code class="codeph">invokedynamic</code> call site to the <code class="codeph">adder</code> method as follows:
                  </p>
                  <p id="GUID-99173E26-45BC-40F9-976B-C19D67D1DB74__INTEGEROPS.JAVA-336DB0F2"><span class="bold">IntegerOps.java</span></p><pre class="pre codeblock"><code>
class IntegerOps {

  public static Integer adder(Integer x, Integer y) {
    return x + y;
  }
}
</code></pre><p id="GUID-99173E26-45BC-40F9-976B-C19D67D1DB74__EXAMPLE.JAVA-336DB496"><span class="bold">Example.java</span></p><pre class="pre codeblock"><code>
import java.util.*;
import java.lang.invoke.*;
import static java.lang.invoke.MethodType.*;
import static java.lang.invoke.MethodHandles.*;

class Example {

  public static CallSite mybsm(
    MethodHandles.Lookup callerClass, String dynMethodName, MethodType dynMethodType)
    throws Throwable {

    MethodHandle mh =
      callerClass.findStatic(
        Example.class,
        "IntegerOps.adder",
        MethodType.methodType(Integer.class, Integer.class, Integer.class));

    if (!dynMethodType.equals(mh.type())) {
      mh = mh.asType(dynMethodType);
    }

    return new ConstantCallSite(mh);
  }
}
</code></pre><p>In this example, the <code class="codeph">IntegerOps</code> class belongs to the library that accompanies runtime system for the dynamically-typed language.
                  </p>
                  <p>The <code class="codeph">Example.mybsm</code> method is a bootstrap method that links the <code class="codeph">invokedynamic</code> call site to the <code class="codeph">adder</code> method.
                  </p>
                  <p>The <code class="codeph">callerClass</code> object is a <code class="codeph">lookup</code> object, which is a factory for creating method handles.
                  </p>
                  <p>The <code class="codeph">MethodHandles.Lookup.findStatic</code> method (called from the <code class="codeph">callerClass</code> <code class="codeph">lookup</code> object) creates a static method handle for the method <code class="codeph">adder</code>.
                  </p>
                  <p><span class="bold">Note</span>: This bootstrap method links an <code class="codeph">invokedynamic</code> call site to only the code that is defined in the <code class="codeph">adder</code> method. It assumes that the arguments given to the <code class="codeph">invokedynamic</code> call site are <code class="codeph">Integer</code> objects. A bootstrap method requires additional code to properly link <code class="codeph">invokedynamic</code> call sites to the appropriate code to execute if the parameters of the bootstrap method (in this example, <code class="codeph">callerClass</code>, <code class="codeph">dynMethodName</code>, and <code class="codeph">dynMethodType</code>) vary.
                  </p>
                  <p>The <code class="codeph">java.lang.invoke.MethodHandles</code> class and <code class="codeph">java.lang.invoke.MethodHandle</code> class contain various methods that create method handles based on existing method handles. This example calls the <code class="codeph">asType</code> method if the method type of the <code class="codeph">mh</code> method handle does not match the method type specified by the <code class="codeph">dynMethodType</code> parameter. This enables the bootstrap method to link <code class="codeph">invokedynamic</code> call sites to Java methods whose method types don’t exactly match.
                  </p>
                  <p>The <code class="codeph">ConstantCallSite</code> instance returned by the bootstrap method represents a call site to be associated with a distinct <code class="codeph">invokedynamic</code> instruction. The target for a <code class="codeph">ConstantCallSite</code> instance is permanent and can never be changed. In this case, one Java method, <code class="codeph">adder</code>, is a candidate for executing the call site. This method does not have to be a Java method. Instead, if several such methods are available to the runtime system, each handling different argument types, the <code class="codeph">mybsm</code> bootstrap method could dynamically select the correct method based on the <code class="codeph">dynMethodType</code> argument.
                  </p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-7FDE8A77-F901-455B-8871-E01B61A9A504" name="GUID-7FDE8A77-F901-455B-8871-E01B61A9A504"></a><h3 id="JSJVM-GUID-7FDE8A77-F901-455B-8871-E01B61A9A504" class="sect3">The invokedynamic Instruction</h3>
               <div>
                  <p>You can use the <code class="codeph">invokedynamic</code> instruction in implementations of compilers and runtime systems for dynamically typed languages on the JVM. The <code class="codeph">invokedynamic</code> instruction enables the language implementer to define custom linkage. This contrasts with other JVM instructions such as <code class="codeph">invokevirtual</code>, in which linkage behavior specific to Java classes and interfaces is hard-wired by the JVM.
                  </p>
                  <p>Each instance of an <code class="codeph">invokedynamic</code> instruction is called a <span class="italic">dynamic call site</span>. When an instance of the dynamic call site is created, it is in an unlinked state, with no method specified for the call site to invoke. The dynamic call site is linked to a method by means of a bootstrap method. A dynamic call site's bootstrap method is a method specified by the compiler for the dynamically-typed language. The method is called once by the JVM to link the site. The object returned from the bootstrap method permanently determines the call site's activity.
                  </p>
                  <p>The <code class="codeph">invokedynamic</code> instruction contains a constant pool index (in the same format as for the other <code class="codeph">invoke</code> instructions). This constant pool index references a <code class="codeph">CONSTANT_InvokeDynamic</code> entry. This entry specifies the bootstrap method (a <code class="codeph">CONSTANT_MethodHandle</code> entry), the name of the dynamically-linked method, and the argument types and return type of the call to the dynamically-linked method.
                  </p>
                  <p>In the following example, the runtime system links the dynamic call site specified by the <code class="codeph">invokedynamic</code> instruction (which is <code class="codeph">+</code>, the addition operator) to the <code class="codeph"><a href="support-non-java-languages.html#GUID-99173E26-45BC-40F9-976B-C19D67D1DB74__INTEGEROPS.JAVA-336DB0F2">IntegerOps.adder</a></code> method by using the <code class="codeph"><a href="support-non-java-languages.html#GUID-99173E26-45BC-40F9-976B-C19D67D1DB74__EXAMPLE.JAVA-336DB496">Example.mybsm</a></code> bootstrap method. The <code class="codeph">adder</code> method and <code class="codeph">mybsm</code> method are defined in <a href="support-non-java-languages.html#GUID-99173E26-45BC-40F9-976B-C19D67D1DB74">The Challenge of Compiling Dynamically Typed Languages</a> (line breaks have been added for clarity):
                  </p><pre class="pre codeblock"><code>
invokedynamic   InvokeDynamic
  REF_invokeStatic:
    Example.mybsm:
      "(Ljava/lang/invoke/MethodHandles/Lookup;
        Ljava/lang/String;
        Ljava/lang/invoke/MethodType;)
      Ljava/lang/invoke/CallSite;":
    +:
      "(Ljava/lang/Integer;
        Ljava/lang/Integer;)
      Ljava/lang/Integer;";
</code></pre><div class="p">
                     <div class="infoboxnote" id="GUID-7FDE8A77-F901-455B-8871-E01B61A9A504__GUID-BB5F3290-9D56-4825-A011-9956BC3EA9C5">
                        <p class="notep1">Note:</p>The bytecode examples use the syntax of the <a href="http://asm.ow2.org/" target="_blank">ASM</a> Java bytecode manipulation and analysis framework.
                     </div>
                  </div>
                  <p>Invoking a dynamically-linked method with the <code class="codeph">invokedynamic</code> instruction involves the following steps:
                  </p>
                  <ol>
                     <li><a href="support-non-java-languages.html#GUID-69026FEA-2A5A-4802-9289-25F8253EA3FB">Defining the Bootstrap Method</a></li>
                     <li><a href="support-non-java-languages.html#GUID-C201B57A-0E58-44BB-A1B9-0B47BA4356D4">Specifying Constant Pool Entries</a></li>
                     <li><a href="support-non-java-languages.html#GUID-5A6C7674-3FE3-48EC-A685-5F71FDBFE921">Using the <code class="codeph">invokedynamic</code> Instruction</a></li>
                  </ol>
               </div>
               <div class="sect3"><a id="GUID-69026FEA-2A5A-4802-9289-25F8253EA3FB" name="GUID-69026FEA-2A5A-4802-9289-25F8253EA3FB"></a><h4 id="JSJVM-GUID-69026FEA-2A5A-4802-9289-25F8253EA3FB" class="sect4">Defining the Bootstrap Method</h4>
                  <div>
                     <p>At runtime, the first time the JVM encounters an <code class="codeph">invokedynamic</code> instruction, it calls the bootstrap method. This method links the name that the <code class="codeph">invokedynamic</code> instruction specifies with the code to execute the target method, which is referenced by a method handle. The next time the JVM executes the same <code class="codeph">invokedynamic</code> instruction, it does not call the bootstrap method; it automatically calls the linked method handle.
                     </p>
                     <p>The bootstrap method's return type must be <code class="codeph">java.lang.invoke.CallSite</code>. The <code class="codeph">CallSite</code> object represents the linked state of the <code class="codeph">invokedynamic</code> instruction and the method handle to which it is linked.
                     </p>
                     <p>The bootstrap method takes three or more of the following parameters:</p>
                     <ul style="list-style-type: disc;">
                        <li><code class="codeph">MethodHandles.Lookup</code> object: A factory for creating method handles in the context of the <code class="codeph">invokedynamic</code> instruction.
                        </li>
                        <li><code class="codeph">String</code> object: The method name mentioned in the dynamic call site.
                        </li>
                        <li><code class="codeph">MethodType</code> object: The resolved type signature of the dynamic call site.
                        </li>
                        <li>One or more additional static arguments to the <code class="codeph">invokedynamic</code> instruction: Optional arguments, drawn from the constant pool, are intended to help language implementers safely and compactly encode additional metadata useful to the bootstrap method. In principle, the name and extra arguments are redundant because each call site could be given its own unique bootstrap method. However, such a practice is likely to produce large class files and constant pools
                        </li>
                     </ul>
                     <p>See <a href="support-non-java-languages.html#GUID-99173E26-45BC-40F9-976B-C19D67D1DB74">The Challenge of Compiling Dynamically Typed Languages</a> for an example of a bootstrap method.
                     </p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-C201B57A-0E58-44BB-A1B9-0B47BA4356D4" name="GUID-C201B57A-0E58-44BB-A1B9-0B47BA4356D4"></a><h4 id="JSJVM-GUID-C201B57A-0E58-44BB-A1B9-0B47BA4356D4" class="sect4">Specifying Constant Pool Entries</h4>
                  <div>
                     <p>The <code class="codeph">invokedynamic</code> instruction contains a reference to an entry in the constant pool with the <code class="codeph">CONSTANT_InvokeDynamic</code> tag. This entry contains references to other entries in the constant pool and references to attributes. See, <a href="https://docs.oracle.com/javase/10/docs/api/java/lang/invoke/package-summary.html" target="_blank"><span class="apiname">java.lang.invoke package documentation</span></a> and <span class="italic">The Java Virtual Machine Specification</span>.
                     </p>
                  </div>
                  <div class="sect4"><a id="GUID-D88BBC6A-2372-4717-A770-C90558C8F337" name="GUID-D88BBC6A-2372-4717-A770-C90558C8F337"></a><h5 id="JSJVM-GUID-D88BBC6A-2372-4717-A770-C90558C8F337" class="sect5">Example Constant Pool</h5>
                     <div>
                        <p>The following example shows an excerpt from the constant pool for the class <code class="codeph">Example</code>, which contains the bootstrap method <code class="codeph">Example.mybsm</code> that links the method <code class="codeph">+</code> with the Java method <code class="codeph">adder</code>:
                        </p><pre class="pre codeblock"><code>
    class #159; // #47
    Utf8 "adder"; // #83
    Utf8 "(Ljava/lang/Integer;Ljava/lang/Integer;)Ljava/lang/Integer;"; // #84
    Utf8 "mybsm"; // #87
    Utf8 "(Ljava/lang/invoke/MethodHandles/Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;)
      java/lang/invoke/CallSite;"; // #88
    Utf8 "Example"; // #159
    Utf8 "+"; // #166

    // ...

    NameAndType #83 #84; // #228
    Method #47 #228; // #229
    MethodHandle 6b #229; // #230
    NameAndType #87 #88; // #231
    Method #47 #231; // #232
    <span class="bold">MethodHandle 6b #232; // #233</span>
    NameAndType #166 #84; // #234
    Utf8 "BootstrapMethods"; // #235
    <span class="bold">InvokeDynamic 0s #234; // #236</span>
</code></pre><p>The constant pool entry for the <code class="codeph">invokedynamic</code> instruction in this example contains the following values:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li><code class="codeph">CONSTANT_InvokeDynamic</code> tag
                           </li>
                           <li>Unsigned short of value <code class="codeph">0</code></li>
                           <li>Constant pool index <code class="codeph">#234</code>.
                           </li>
                        </ul>
                        <p>The value, <code class="codeph">0</code>, refers to the first bootstrap method specifier in the array of specifiers that are stored in the <code class="codeph">BootstrapMethods</code> attribute. Bootstrap method specifiers are not in the constant pool table. They are contained in this separate array of specifiers. Each bootstrap method specifier contains an index to a <code class="codeph">CONSTANT_MethodHandle</code> constant pool entry, which is the bootstrap method itself.
                        </p>
                        <p>The following example shows an excerpt from the same constant pool that shows the <code class="codeph">BootstrapMethods</code> attribute, which contains the array of bootstrap method specifiers:
                        </p><pre class="pre codeblock"><code>
  [3] { // Attributes

    // ...

    Attr(#235, 6) { // BootstrapMethods at 0x0F63
      [1] { // bootstrap_methods
        {  //  bootstrap_method
          #233; // bootstrap_method_ref
          [0] { // bootstrap_arguments
          }  //  bootstrap_arguments
        }  //  bootstrap_method
      }
    } // end BootstrapMethods
  } // Attributes
</code></pre><p>The constant pool entry for the bootstrap method <code class="codeph">mybsm</code> method handle contains the following values:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li><code class="codeph">CONSTANT_MethodHandle</code> tag
                           </li>
                           <li>Unsigned byte of value <code class="codeph">6</code></li>
                           <li>Constant pool index <code class="codeph">#232</code>.
                           </li>
                        </ul>
                        <p>The value, <code class="codeph">6</code>, is the <code class="codeph">REF_invokeStatic</code> subtag. See, <a href="support-non-java-languages.html#GUID-5A6C7674-3FE3-48EC-A685-5F71FDBFE921">Using the invokedynamic Instruction</a>, for more information about this subtag.
                        </p>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-5A6C7674-3FE3-48EC-A685-5F71FDBFE921" name="GUID-5A6C7674-3FE3-48EC-A685-5F71FDBFE921"></a><h4 id="JSJVM-GUID-5A6C7674-3FE3-48EC-A685-5F71FDBFE921" class="sect4">Using the invokedynamic Instruction</h4>
                  <div>
                     <p>The following example shows how the bytecode uses the <code class="codeph">invokedynamic</code> instruction to call the <code class="codeph">mybsm</code> bootstrap method, which links the dynamic call site (<code class="codeph">+</code>, the addition operator) to the <code class="codeph">adder</code> method. This example uses the <code class="codeph">+</code> method to add the numbers <code class="codeph">40</code> and <code class="codeph">2</code> (line breaks have been added for clarity):
                     </p><pre class="pre codeblock"><code>
bipush  40;
invokestatic    Method java/lang/Integer.valueOf:"(I)Ljava/lang/Integer;";
iconst_2;
invokestatic    Method java/lang/Integer.valueOf:"(I)Ljava/lang/Integer;";
invokedynamic   InvokeDynamic
  REF_invokeStatic:
    Example.mybsm:
      "(Ljava/lang/invoke/MethodHandles/Lookup;
        Ljava/lang/String;
        Ljava/lang/invoke/MethodType;)
      Ljava/lang/invoke/CallSite;":
    +:
      "(Ljava/lang/Integer;
        Ljava/lang/Integer;)
      Ljava/lang/Integer;";
</code></pre><p>The first four instructions put the integers <code class="codeph">40</code> and <code class="codeph">2</code> in the stack and boxes them in the <code class="codeph">java.lang.Integer</code> wrapper type. The fifth instruction invokes a dynamic method. This instruction refers to a constant pool entry with a <code class="codeph">CONSTANT_InvokeDynamic</code> tag:
                     </p><pre class="pre codeblock"><code>
REF_invokeStatic:
  Example.mybsm:
    "(Ljava/lang/invoke/MethodHandles/Lookup;
      Ljava/lang/String;
      Ljava/lang/invoke/MethodType;)
    Ljava/lang/invoke/CallSite;":
  +:
    "(Ljava/lang/Integer;
      Ljava/lang/Integer;)
    Ljava/lang/Integer;";
</code></pre><p>Four bytes follow the <code class="codeph">CONSTANT_InvokeDynamic</code> tag in this entry. 
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The first two bytes form a reference to a <code class="codeph">CONSTANT_MethodHandle</code> entry that references a bootstrap method specifier:
                           </p><pre class="pre codeblock"><code>
REF_invokeStatic:
  Example.mybsm:
    "(Ljava/lang/invoke/MethodHandles/Lookup;
      Ljava/lang/String;
      Ljava/lang/invoke/MethodType;)
    Ljava/lang/invoke/CallSite;"
</code></pre><p>This reference to a bootstrap method specifier is not in the constant pool table. It is contained in a separate array defined by a class file attribute named <code class="codeph">BootstrapMethods</code>. The bootstrap method specifier contains an index to a <code class="codeph">CONSTANT_MethodHandle</code> constant pool entry, which is the bootstrap method itself.
                           </p>
                           <p>Three bytes follow this <code class="codeph">CONSTANT_MethodHandle</code> constant pool entry:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>The first byte is the <code class="codeph">REF_invokeStatic</code> subtag. This means that this bootstrap method will create a method handle for a static method; note that this bootstrap method is linking the dynamic call site with the static Java <code class="codeph">adder</code> method. 
                                 </p>
                              </li>
                              <li>
                                 <p>The next two bytes form a <code class="codeph">CONSTANT_Methodref</code> entry that represents the method for which the method handle is to be created:
                                 </p><pre class="pre codeblock"><code>
Example.mybsm:
  "(Ljava/lang/invoke/MethodHandles/Lookup;
    Ljava/lang/String;
    Ljava/lang/invoke/MethodType;)
  Ljava/lang/invoke/CallSite;"
</code></pre><p>In this example, the fully qualified name of the bootstrap method is <code class="codeph">Example.mybsm</code> . The argument types are <code class="codeph">MethodHandles.Lookup</code>, <code class="codeph">String</code>, and <code class="codeph">MethodType</code>. The return type is <code class="codeph">CallSite</code>.
                                 </p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>The next two bytes form a reference to a <code class="codeph">CONSTANT_NameAndType</code> entry:
                           </p><pre class="pre codeblock"><code>
+:
  "(Ljava/lang/Integer;
    Ljava/lang/Integer;)
  Ljava/lang/Integer;"
</code></pre><p>This constant pool entry specifies the method name (<code class="codeph">+</code>), the argument types (two <code class="codeph">Integer</code> instances), and return type of the dynamic call site (<code class="codeph">Integer</code>).
                           </p>
                        </li>
                     </ul>
                     <p>In this example, the dynamic call site is presented with boxed integer values, which exactly match the type of the eventual target, the <code class="codeph">adder</code> method. In practice, the argument and return types don’t need to exactly match. For example, the <code class="codeph">invokedynamic</code> instruction could pass either or both of its operands on the JVM stack as primitive <code class="codeph">int</code> values. Either or both operands could be untyped <code class="codeph">Object</code> values. The <code class="codeph">invokedynamic</code> instruction could receive its result as a primitive <code class="codeph">int</code> value, or an untyped <code class="codeph">Object</code> value. In any case, the <code class="codeph">dynMethodType</code> argument to <code class="codeph">mybsm</code> accurately describes the method type that is required by the <code class="codeph">invokedynamic</code> instruction.
                     </p>
                     <p>The <code class="codeph">adder</code> method could be given primitive or untyped arguments or return values. The bootstrap method is responsible for making up any difference between the <code class="codeph">dynMethodType</code> and the type of the <code class="codeph">adder</code> method. As shown in the code, this is easily done with an <code class="codeph">asType</code> call on the target method.
                     </p>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>
