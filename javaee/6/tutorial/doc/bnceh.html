<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en-US">
<head>
<!-- GenHTML revision 25226-->
<meta http-equiv="Content-type" content="text/html; charset=utf-8">
<title>The JMS API Programming Model - The Java EE 6 Tutorial</title>
<meta name="robots" content="index,follow">
<meta name="robots" content="index,follow">
<meta name="date" content="2013-01-01">
<link rel="stylesheet" type="text/css" href="css/default.css">
<link rel="stylesheet" type="text/css" href="css/ipg.css">
<link rel="stylesheet" type="text/css" href="css/javaeetutorial.css">
<script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>

<body>

<table border="0" cellpadding="5" cellspacing="0" width="100%">
<tbody>
   <tr valign="top">
      <td width="400px"><p class="toc level1"><a href="docinfo.html">Document Information</a></p>
<p class="toc level1 tocsp"><a href="gexaf.html">Preface</a></p>
<p class="toc level1 tocsp"><a href="gfirp.html">Part&nbsp;I&nbsp;Introduction</a></p>
<p class="toc level2"><a href="bnaaw.html">1.&nbsp;&nbsp;Overview</a></p>
<p class="toc level2"><a href="gfiud.html">2.&nbsp;&nbsp;Using the Tutorial Examples</a></p>
<p class="toc level1 tocsp"><a href="bnadp.html">Part&nbsp;II&nbsp;The Web Tier</a></p>
<p class="toc level2"><a href="bnadr.html">3.&nbsp;&nbsp;Getting Started with Web Applications</a></p>
<p class="toc level2"><a href="bnaph.html">4.&nbsp;&nbsp;JavaServer Faces Technology</a></p>
<p class="toc level2"><a href="giepx.html">5.&nbsp;&nbsp;Introduction to Facelets</a></p>
<p class="toc level2"><a href="gjddd.html">6.&nbsp;&nbsp;Expression Language</a></p>
<p class="toc level2"><a href="bnaqz.html">7.&nbsp;&nbsp;Using JavaServer Faces Technology in Web Pages</a></p>
<p class="toc level2"><a href="gjcut.html">8.&nbsp;&nbsp;Using Converters, Listeners, and Validators</a></p>
<p class="toc level2"><a href="bnatx.html">9.&nbsp;&nbsp;Developing with JavaServer Faces Technology</a></p>
<p class="toc level2"><a href="gkmaa.html">10.&nbsp;&nbsp;JavaServer Faces Technology: Advanced Concepts</a></p>
<p class="toc level2"><a href="gkiow.html">11.&nbsp;&nbsp;Using Ajax with JavaServer Faces Technology</a></p>
<p class="toc level2"><a href="gkhxa.html">12.&nbsp;&nbsp;Composite Components: Advanced Topics and Example</a></p>
<p class="toc level2"><a href="bnavg.html">13.&nbsp;&nbsp;Creating Custom UI Components and Other Custom Objects</a></p>
<p class="toc level2"><a href="bnawo.html">14.&nbsp;&nbsp;Configuring JavaServer Faces Applications</a></p>
<p class="toc level2"><a href="bnafd.html">15.&nbsp;&nbsp;Java Servlet Technology</a></p>
<p class="toc level2"><a href="glrbb.html">16.&nbsp;&nbsp;Uploading Files with Java Servlet Technology</a></p>
<p class="toc level2"><a href="bnaxu.html">17.&nbsp;&nbsp;Internationalizing and Localizing Web Applications</a></p>
<p class="toc level1 tocsp"><a href="bnayk.html">Part&nbsp;III&nbsp;Web Services</a></p>
<p class="toc level2"><a href="gijti.html">18.&nbsp;&nbsp;Introduction to Web Services</a></p>
<p class="toc level2"><a href="bnayl.html">19.&nbsp;&nbsp;Building Web Services with JAX-WS</a></p>
<p class="toc level2"><a href="giepu.html">20.&nbsp;&nbsp;Building RESTful Web Services with JAX-RS</a></p>
<p class="toc level2"><a href="gjjxe.html">21.&nbsp;&nbsp;JAX-RS: Advanced Topics and Example</a></p>
<p class="toc level1 tocsp"><a href="bnblr.html">Part&nbsp;IV&nbsp;Enterprise Beans</a></p>
<p class="toc level2"><a href="gijsz.html">22.&nbsp;&nbsp;Enterprise Beans</a></p>
<p class="toc level2"><a href="gijre.html">23.&nbsp;&nbsp;Getting Started with Enterprise Beans</a></p>
<p class="toc level2"><a href="gijrb.html">24.&nbsp;&nbsp;Running the Enterprise Bean Examples</a></p>
<p class="toc level2"><a href="bnbpk.html">25.&nbsp;&nbsp;A Message-Driven Bean Example</a></p>
<p class="toc level2"><a href="gkcqz.html">26.&nbsp;&nbsp;Using the Embedded Enterprise Bean Container</a></p>
<p class="toc level2"><a href="gkidz.html">27.&nbsp;&nbsp;Using Asynchronous Method Invocation in Session Beans</a></p>
<p class="toc level1 tocsp"><a href="gjbnr.html">Part&nbsp;V&nbsp;Contexts and Dependency Injection for the Java EE Platform</a></p>
<p class="toc level2"><a href="giwhb.html">28.&nbsp;&nbsp;Introduction to Contexts and Dependency Injection for the Java EE Platform</a></p>
<p class="toc level2"><a href="gjbls.html">29.&nbsp;&nbsp;Running the Basic Contexts and Dependency Injection Examples</a></p>
<p class="toc level2"><a href="gjehi.html">30.&nbsp;&nbsp;Contexts and Dependency Injection for the Java EE Platform: Advanced Topics</a></p>
<p class="toc level2"><a href="gkhre.html">31.&nbsp;&nbsp;Running the Advanced Contexts and Dependency Injection Examples</a></p>
<p class="toc level1 tocsp"><a href="bnbpy.html">Part&nbsp;VI&nbsp;Persistence</a></p>
<p class="toc level2"><a href="bnbpz.html">32.&nbsp;&nbsp;Introduction to the Java Persistence API</a></p>
<p class="toc level2"><a href="gijst.html">33.&nbsp;&nbsp;Running the Persistence Examples</a></p>
<p class="toc level2"><a href="bnbtg.html">34.&nbsp;&nbsp;The Java Persistence Query Language</a></p>
<p class="toc level2"><a href="gjitv.html">35.&nbsp;&nbsp;Using the Criteria API to Create Queries</a></p>
<p class="toc level2"><a href="gkjiq.html">36.&nbsp;&nbsp;Creating and Using String-Based Criteria Queries</a></p>
<p class="toc level2"><a href="gkjjf.html">37.&nbsp;&nbsp;Controlling Concurrent Access to Entity Data with Locking</a></p>
<p class="toc level2"><a href="gkjia.html">38.&nbsp;&nbsp;Using a Second-Level Cache with Java Persistence API Applications</a></p>
<p class="toc level1 tocsp"><a href="gijrp.html">Part&nbsp;VII&nbsp;Security</a></p>
<p class="toc level2"><a href="bnbwj.html">39.&nbsp;&nbsp;Introduction to Security in the Java EE Platform</a></p>
<p class="toc level2"><a href="bncas.html">40.&nbsp;&nbsp;Getting Started Securing Web Applications</a></p>
<p class="toc level2"><a href="bnbyk.html">41.&nbsp;&nbsp;Getting Started Securing Enterprise Applications</a></p>
<p class="toc level2"><a href="gjjwx.html">42.&nbsp;&nbsp;Java EE Security: Advanced Topics</a></p>
<p class="toc level1 tocsp"><a href="gijue.html">Part&nbsp;VIII&nbsp;Java EE Supporting Technologies</a></p>
<p class="toc level2"><a href="gijto.html">43.&nbsp;&nbsp;Introduction to Java EE Supporting Technologies</a></p>
<p class="toc level2"><a href="bncih.html">44.&nbsp;&nbsp;Transactions</a></p>
<p class="toc level2"><a href="bncjh.html">45.&nbsp;&nbsp;Resources and Resource Adapters</a></p>
<p class="toc level2"><a href="glodb.html">46.&nbsp;&nbsp;The Resource Adapter Example</a></p>
<p class="toc level2"><a href="bncdq.html">47.&nbsp;&nbsp;Java Message Service Concepts</a></p>
<p class="toc level3"><a href="bncdr.html">Overview of the JMS API</a></p>
<p class="toc level4"><a href="bncdr.html#bncds">What Is Messaging?</a></p>
<p class="toc level4"><a href="bncdr.html#bncdt">What Is the JMS API?</a></p>
<p class="toc level4"><a href="bncdr.html#bncdu">When Can You Use the JMS API?</a></p>
<p class="toc level4"><a href="bncdr.html#bncdw">How Does the JMS API Work with the Java EE Platform?</a></p>
<p class="toc level3 tocsp"><a href="bncdx.html">Basic JMS API Concepts</a></p>
<p class="toc level4"><a href="bncdx.html#bncdy">JMS API Architecture</a></p>
<p class="toc level4"><a href="bncdx.html#bncea">Messaging Domains</a></p>
<p class="toc level5"><a href="bncdx.html#bnceb">Point-to-Point Messaging Domain</a></p>
<p class="toc level5"><a href="bncdx.html#bnced">Publish/Subscribe Messaging Domain</a></p>
<p class="toc level5"><a href="bncdx.html#bncef">Programming with the Common Interfaces</a></p>
<p class="toc level4 tocsp"><a href="bncdx.html#bnceg">Message Consumption</a></p>
<div id="scrolltoc" class="onpage">
<p class="toc level3 tocsp"><a href="">The JMS API Programming Model</a></p>
<p class="toc level4"><a href="#bncej">JMS Administered Objects</a></p>
<p class="toc level5"><a href="#bncek">JMS Connection Factories</a></p>
<p class="toc level5"><a href="#bncel">JMS Destinations</a></p>
<p class="toc level4 tocsp"><a href="#bncem">JMS Connections</a></p>
<p class="toc level4"><a href="#bncen">JMS Sessions</a></p>
<p class="toc level4"><a href="#bnceo">JMS Message Producers</a></p>
<p class="toc level4"><a href="#bncep">JMS Message Consumers</a></p>
<p class="toc level5"><a href="#bnceq">JMS Message Listeners</a></p>
<p class="toc level5"><a href="#bncer">JMS Message Selectors</a></p>
<p class="toc level4 tocsp"><a href="#bnces">JMS Messages</a></p>
<p class="toc level5"><a href="#bncet">Message Headers</a></p>
<p class="toc level5"><a href="#bncev">Message Properties</a></p>
<p class="toc level5"><a href="#bncew">Message Bodies</a></p>
<p class="toc level4 tocsp"><a href="#bncey">JMS Queue Browsers</a></p>
<p class="toc level4"><a href="#bncez">JMS Exception Handling</a></p>
</div>
<p class="toc level3 tocsp"><a href="bncfu.html">Creating Robust JMS Applications</a></p>
<p class="toc level4"><a href="bncfu.html#bncfv">Using Basic Reliability Mechanisms</a></p>
<p class="toc level5"><a href="bncfu.html#bncfw">Controlling Message Acknowledgment</a></p>
<p class="toc level5"><a href="bncfu.html#bncfy">Specifying Message Persistence</a></p>
<p class="toc level5"><a href="bncfu.html#bncfz">Setting Message Priority Levels</a></p>
<p class="toc level5"><a href="bncfu.html#bncga">Allowing Messages to Expire</a></p>
<p class="toc level5"><a href="bncfu.html#bncgb">Creating Temporary Destinations</a></p>
<p class="toc level4 tocsp"><a href="bncfu.html#bncgc">Using Advanced Reliability Mechanisms</a></p>
<p class="toc level5"><a href="bncfu.html#bncgd">Creating Durable Subscriptions</a></p>
<p class="toc level5"><a href="bncfu.html#bncgh">Using JMS API Local Transactions</a></p>
<p class="toc level3 tocsp"><a href="bncgl.html">Using the JMS API in Java EE Applications</a></p>
<p class="toc level4"><a href="bncgl.html#bncgm">Using <tt>@Resource</tt> Annotations in Enterprise Bean or Web Components</a></p>
<p class="toc level4"><a href="bncgl.html#bncgn">Using Session Beans to Produce and to Synchronously Receive Messages</a></p>
<p class="toc level5"><a href="bncgl.html#bncgo">Managing JMS Resources in Session Beans</a></p>
<p class="toc level5"><a href="bncgl.html#bncgp">Managing Transactions in Session Beans</a></p>
<p class="toc level4 tocsp"><a href="bncgl.html#bncgq">Using Message-Driven Beans to Receive Messages Asynchronously</a></p>
<p class="toc level4"><a href="bncgl.html#bncgs">Managing Distributed Transactions</a></p>
<p class="toc level4"><a href="bncgl.html#bncgt">Using the JMS API with Application Clients and Web Components</a></p>
<p class="toc level3 tocsp"><a href="bncgu.html">Further Information about JMS</a></p>
<p class="toc level2 tocsp"><a href="bncgv.html">48.&nbsp;&nbsp;Java Message Service Examples</a></p>
<p class="toc level2"><a href="gkahp.html">49.&nbsp;&nbsp;Bean Validation: Advanced Topics</a></p>
<p class="toc level2"><a href="gkeed.html">50.&nbsp;&nbsp;Using Java EE Interceptors</a></p>
<p class="toc level1 tocsp"><a href="gkgjw.html">Part&nbsp;IX&nbsp;Case Studies</a></p>
<p class="toc level2"><a href="glnvi.html">51.&nbsp;&nbsp;Duke's Bookstore Case Study Example</a></p>
<p class="toc level2"><a href="gkaee.html">52.&nbsp;&nbsp;Duke's Tutoring Case Study Example</a></p>
<p class="toc level2"><a href="glnpw.html">53.&nbsp;&nbsp;Duke's Forest Case Study Example</a></p>
<p class="toc level1 tocsp"><a href="idx-1.html">Index</a></p>
</td>
      <td width="10px">&nbsp;</td>
      <td>
         <div class="header">
             <div class="banner">
                <table width="100%" border="0" cellpadding="5" cellspacing="0">
                   <tbody>
                      <tr>
                         <td valign="bottom"><p class="Banner">The Java EE 6 Tutorial
</p></td>
                         <td align="right"  valign="bottom"><img src="graphics/javalogo.png" alt="Java Coffee Cup logo"></td>
                      </tr>
                   </tbody>
                </table>
             </div>

             <div class="header-links">
	         <a href="./index.html">Home</a> | 
<a href="../information/download.html">Download</a> | 
<a href="./javaeetutorial6.pdf">PDF</a> | 
<a href="../information/faq.html">FAQ</a> | 
<a href="http://docs.oracle.com/javaee/support/feedback.htm">Feedback</a>

             </div>
             <div class="navigation">
                 <a href="bncdx.html"><img src="graphics/leftButton.gif" border="0" alt="Previous" title="Previous"></a>
                 <a href="p1.html"><img src="graphics/upButton.gif" border="0" alt="Contents" title="Contents"></a>
                 <a href="bncfu.html"><img src="graphics/rightButton.gif" border="0" alt="Next" title="Next"></a>
             </div>
         </div>

	 <div class="maincontent">      	 
             

<a name="bnceh"></a><h2>The JMS API Programming Model</h2>
<a name="indexterm-2364"></a><a name="indexterm-2365"></a><p>The basic building blocks of a JMS application are:</p>


<ul><li><p>Administered objects: connection factories and destinations</p>

</li>
<li><p>Connections</p>

</li>
<li><p>Sessions</p>

</li>
<li><p>Message producers</p>

</li>
<li><p>Message consumers</p>

</li>
<li><p>Messages</p>

</li></ul>
<p><a href="#bncei">Figure&nbsp;47-5</a> shows how all these objects fit together in a JMS client application.</p>

<a name="bncei"></a><p class="caption">Figure&nbsp;47-5 The JMS API Programming Model</p><img src="figures/jms-programmingModel.gif" alt="Diagram of the JMS API programming model: connection factory, connection, session, message producer, message consumer, messages, and destinations"></img><p>This section describes all these objects briefly and provides sample commands and code
snippets that show how to create and use the objects. The last subsection
briefly describes JMS API exception handling.</p>

<p>Examples that show how to combine all these objects in applications appear in
later sections. For more detail, see the JMS API documentation, part of the
Java EE API documentation.</p>



<a name="bncej"></a><h3>JMS Administered Objects</h3>
<a name="indexterm-2366"></a><a name="indexterm-2367"></a><a name="indexterm-2368"></a><a name="indexterm-2369"></a><p>Two parts of a JMS application, destinations and connection factories, are best maintained
administratively rather than programmatically. The technology underlying these objects is likely to be
very different from one implementation of the JMS API to another. Therefore, the
management of these objects belongs with other administrative tasks that vary from provider
to provider.</p>

<p>JMS clients access these objects through interfaces that are portable, so a client
application can run with little or no change on more than one implementation
of the JMS API. Ordinarily, an administrator configures administered objects in a JNDI
namespace, and JMS clients then access them by using resource injection.</p>

<p>With GlassFish Server, you can use the <tt>asadmin create-jms-resource</tt> command or the Administration Console
to create JMS administered objects in the form of connector resources. You can
also specify the resources in a file named <tt>glassfish-resources.xml</tt> that you can
bundle with an application.</p>

<p>NetBeans IDE provides a wizard that allows you to create JMS resources for
GlassFish Server. See <a href="bncfa.html#gkthg">To Create JMS Resources Using NetBeans IDE</a> for details.</p>



<a name="bncek"></a><h4>JMS Connection Factories</h4>
<a name="indexterm-2370"></a><a name="indexterm-2371"></a><p>A <b>connection factory</b> is the object a client uses to create a connection to
a provider. A connection factory encapsulates a set of connection configuration parameters that
has been defined by an administrator. Each connection factory is an instance of
the <tt>ConnectionFactory</tt>, <tt>QueueConnectionFactory</tt>, or <tt>TopicConnectionFactory</tt> interface. To learn how to create connection factories,
see <a href="bncfa.html#gkthg">To Create JMS Resources Using NetBeans IDE</a>.</p>

<p><a name="indexterm-2372"></a><a name="indexterm-2373"></a>At the beginning of a JMS client program, you usually inject a connection
factory resource into a <tt>ConnectionFactory</tt> object. For example, the following code fragment specifies a
resource whose JNDI name is <tt>jms/ConnectionFactory</tt> and assigns it to a <tt>ConnectionFactory</tt> object:</p>

<pre>@Resource(lookup = "jms/ConnectionFactory")
private static ConnectionFactory connectionFactory;</pre><p><a name="indexterm-2374"></a>In a Java EE application, JMS administered objects are normally placed in the
<tt>jms</tt> naming subcontext.</p>



<a name="bncel"></a><h4>JMS Destinations</h4>
<a name="indexterm-2375"></a><a name="indexterm-2376"></a><a name="indexterm-2377"></a><a name="indexterm-2378"></a><a name="indexterm-2379"></a><a name="indexterm-2380"></a><a name="indexterm-2381"></a><a name="indexterm-2382"></a><p>A <b>destination</b> is the object a client uses to specify the target of
messages it produces and the source of messages it consumes. In the PTP
messaging domain, destinations are called queues. In the pub/sub messaging domain, destinations are
called topics. A JMS application can use multiple queues or topics (or both).
To learn how to create destination resources, see <a href="bncfa.html#gkthg">To Create JMS Resources Using NetBeans IDE</a>.</p>

<p>To create a destination using the GlassFish Server, you create a JMS
destination resource that specifies a JNDI name for the destination.</p>

<p>In the GlassFish Server implementation of JMS, each destination resource refers to a
physical destination. You can create a physical destination explicitly, but if you do
not, the Application Server creates it when it is needed and deletes it
when you delete the destination resource.</p>

<p><a name="indexterm-2383"></a>In addition to injecting a connection factory resource into a client program, you
usually inject a destination resource. Unlike connection factories, destinations are specific to one
domain or the other. To create an application that allows you to use
the same code for both topics and queues, you assign the destination to
a <tt>Destination</tt> object.</p>

<p><a name="indexterm-2384"></a>The following code specifies two resources, a queue and a topic. The resource
names are mapped to destination resources created in the JNDI namespace.</p>

<pre>@Resource(lookup = "jms/Queue")
private static Queue queue;

@Resource(lookup = "jms/Topic")
private static Topic topic;</pre><p>With the common interfaces, you can mix or match connection factories and destinations.
That is, in addition to using the <tt>ConnectionFactory</tt> interface, you can inject
a <tt>QueueConnectionFactory</tt> resource and use it with a <tt>Topic</tt>, and you can inject
a <tt>TopicConnectionFactory</tt> resource and use it with a <tt>Queue</tt>. The behavior of the application
will depend on the kind of destination you use and not on
the kind of connection factory you use.</p>



<a name="bncem"></a><h3>JMS Connections</h3>
<a name="indexterm-2385"></a><a name="indexterm-2386"></a><p>A <b>connection</b> encapsulates a virtual connection with a JMS provider. For example, a
connection could represent an open TCP/IP socket between a client and a provider
service daemon. You use a connection to create one or more sessions.</p>


<hr><p><b>Note - </b>In the Java EE platform, the ability to create multiple sessions from a
single connection is limited to application clients. In web and enterprise bean components,
a connection can create no more than one session.</p>


<hr>
<p>Connections implement the <tt>Connection</tt> interface. When you have a <tt>ConnectionFactory</tt> object, you can use
it to create a <tt>Connection</tt>:</p>

<pre>Connection connection = connectionFactory.createConnection();</pre><p>Before an application completes, you must close any connections you have created. Failure
to close a connection can cause resources not to be released by the
JMS provider. Closing a connection also closes its sessions and their message producers
and message consumers.</p>

<pre>connection.close();</pre><p>Before your application can consume messages, you must call the connection&rsquo;s <tt>start</tt>
method; for details, see <a href="#bncep">JMS Message Consumers</a>. If you want to stop message delivery
temporarily without closing the connection, you call the <tt>stop</tt> method.</p>



<a name="bncen"></a><h3>JMS Sessions</h3>
<a name="indexterm-2387"></a><a name="indexterm-2388"></a><p>A <b>session</b> is a single-threaded context for producing and consuming messages. You use
sessions to create the following:</p>


<ul><li><p>Message producers</p>

</li>
<li><p>Message consumers</p>

</li>
<li><p>Messages</p>

</li>
<li><p>Queue browsers</p>

</li>
<li><p>Temporary queues and topics (see <a href="bncfu.html#bncgb">Creating Temporary Destinations</a>)</p>

</li></ul>
<p>Sessions serialize the execution of message listeners; for details, see <a href="#bnceq">JMS Message Listeners</a>.</p>

<p>A session provides a transactional context with which to group a set of
sends and receives into an atomic unit of work. For details, see
<a href="bncfu.html#bncgh">Using JMS API Local Transactions</a>.</p>

<p>Sessions implement the <tt>Session</tt> interface. After you create a <tt>Connection</tt> object, you use it
to create a <tt>Session</tt>:</p>

<pre>Session session = connection.createSession(false,
     Session.AUTO_ACKNOWLEDGE);</pre><p>The first argument means the session is not transacted; the second means the
session automatically acknowledges messages when they have been received successfully. (For more information,
see <a href="bncfu.html#bncfw">Controlling Message Acknowledgment</a>.)</p>

<p>To create a transacted session, use the following code:</p>

<pre>Session session = connection.createSession(true, 0);</pre><p>Here, the first argument means the session is transacted; the second indicates that
message acknowledgment is not specified for transacted sessions. For more information on transactions,
see <a href="bncfu.html#bncgh">Using JMS API Local Transactions</a>. For information about the way JMS transactions work in Java EE
applications, see <a href="bncgl.html">Using the JMS API in Java EE Applications</a>.</p>



<a name="bnceo"></a><h3>JMS Message Producers</h3>
<a name="indexterm-2389"></a><a name="indexterm-2390"></a><a name="indexterm-2391"></a><p>A <b>message producer</b> is an object that is created by a session and used
for sending messages to a destination. It implements the <tt>MessageProducer</tt> interface.</p>

<p>You use a <tt>Session</tt> to create a <tt>MessageProducer</tt> for a destination. The
following examples show that you can create a producer for a <tt>Destination</tt> object, a
<tt>Queue</tt> object, or a <tt>Topic</tt> object.</p>

<pre>MessageProducer producer = session.createProducer(dest);
MessageProducer producer = session.createProducer(queue);
MessageProducer producer = session.createProducer(topic);</pre><p>You can create an unidentified producer by specifying <tt>null</tt> as the argument to
<tt>createProducer</tt>. With an unidentified producer, you do not specify a destination until you
send a message.</p>

<p>After you have created a message producer, you can use it to
send messages by using the <tt>send</tt> method:</p>

<pre>producer.send(message);</pre><p>You must first create the messages; see <a href="#bnces">JMS Messages</a>.</p>

<p>If you have created an unidentified producer, use an overloaded <tt>send</tt> method
that specifies the destination as the first parameter. For example:</p>

<pre>MessageProducer anon_prod = session.createProducer(null);
anon_prod.send(dest, message);</pre>

<a name="bncep"></a><h3>JMS Message Consumers</h3>
<a name="indexterm-2392"></a><a name="indexterm-2393"></a><p>A <b>message consumer</b> is an object that is created by a session and used
for receiving messages sent to a destination. It implements the <tt>MessageConsumer</tt> interface.</p>

<p>A message consumer allows a JMS client to register interest in a
destination with a JMS provider. The JMS provider manages the delivery of messages
from a destination to the registered consumers of the destination.</p>

<p>For example, you could use a <tt>Session</tt> to create a <tt>MessageConsumer</tt> for a
<tt>Destination</tt> object, a <tt>Queue</tt> object, or a <tt>Topic</tt> object:</p>

<pre>MessageConsumer consumer = session.createConsumer(dest);
MessageConsumer consumer = session.createConsumer(queue);
MessageConsumer consumer = session.createConsumer(topic);</pre><p>You use the <tt>Session.createDurableSubscriber</tt> method to create a durable topic subscriber. This method
is valid only if you are using a topic. For details, see <a href="bncfu.html#bncgd">Creating Durable Subscriptions</a>.</p>

<p>After you have created a message consumer it becomes active, and you can
use it to receive messages. You can use the <tt>close</tt> method for a
<tt>MessageConsumer</tt> to make the message consumer inactive. Message delivery does not begin until
you start the connection you created by calling its <tt>start</tt> method. (Remember always to
call the <tt>start</tt> method; forgetting to start the connection is one of the
most common JMS programming errors.)</p>

<p>You use the <tt>receive</tt> method to consume a message synchronously. You can use
this method at any time after you call the <tt>start</tt> method:</p>

<pre>connection.start();
Message m = consumer.receive();
connection.start();
Message m = consumer.receive(1000); // time out after a second</pre><p>To consume a message asynchronously, you use a message listener, as described in
the next section.</p>



<a name="bnceq"></a><h4>JMS Message Listeners</h4>
<a name="indexterm-2394"></a><a name="indexterm-2395"></a><a name="indexterm-2396"></a><p>A message listener is an object that acts as an asynchronous event
handler for messages. This object implements the <tt>MessageListener</tt> interface, which contains one method, <tt>onMessage</tt>.
In the <tt>onMessage</tt> method, you define the actions to be taken when
a message arrives.</p>

<p>You register the message listener with a specific MessageConsumer by using the
<tt>setMessageListener</tt> method. For example, if you define a class named <tt>Listener</tt> that implements the
<tt>MessageListener</tt> interface, you can register the message listener as follows:</p>

<pre>Listener myListener = new Listener();
consumer.setMessageListener(myListener);</pre>
<hr><p><b>Note - </b>In the Java EE platform, a <tt>MessageListener</tt> can be used only in an
application client, not in a web component or enterprise bean.</p>


<hr>
<p>After you register the message listener, you call the <tt>start</tt> method on the
<tt>Connection</tt> to begin message delivery. (If you call <tt>start</tt> before you register the
message listener, you are likely to miss messages.)</p>

<p>When message delivery begins, the JMS provider automatically calls the message listener&rsquo;s <tt>onMessage</tt>
method whenever a message is delivered. The <tt>onMessage</tt> method takes one argument of type
<tt>Message</tt>, which your implementation of the method can cast to any of the
other message types (see <a href="#bncew">Message Bodies</a>).</p>

<p>A message listener is not specific to a particular destination type. The same
listener can obtain messages from either a queue or a topic, depending on
the type of destination for which the message consumer was created. A
message listener does, however, usually expect a specific message type and format.</p>

<p>Your <tt>onMessage</tt> method should handle all exceptions. It must not throw checked exceptions,
and throwing a <tt>RuntimeException</tt> is considered a programming error.</p>

<p>The session used to create the message consumer serializes the execution of all
message listeners registered with the session. At any time, only one of the
session&rsquo;s message listeners is running.</p>

<p>In the Java EE platform, a message-driven bean is a special kind
of message listener. For details, see <a href="bncgl.html#bncgq">Using Message-Driven Beans to Receive Messages Asynchronously</a>.</p>



<a name="bncer"></a><h4>JMS Message Selectors</h4>
<a name="indexterm-2397"></a><p>If your messaging application needs to filter the messages it receives, you can
use a JMS API message selector, which allows a message consumer to specify
the messages that interest it. Message selectors assign the work of filtering messages
to the JMS provider rather than to the application. For an example of
an application that uses a message selector, see <a href="bncgw.html">An Application That Uses the JMS API with a Session Bean</a>.</p>

<p>A message selector is a <tt>String</tt> that contains an expression. The syntax of
the expression is based on a subset of the SQL92 conditional expression syntax.
The message selector in the example selects any message that has a <tt>NewsType</tt>
property that is set to the value <tt>'Sports'</tt> or <tt>'Opinion'</tt>:</p>

<pre>NewsType = &rsquo;Sports&rsquo; OR NewsType = &rsquo;Opinion&rsquo;</pre><p>The <tt>createConsumer</tt> and <tt>createDurableSubscriber</tt> methods allow you to specify a message selector
as an argument when you create a message consumer.</p>

<p>The message consumer then receives only messages whose headers and properties match the
selector. (See <a href="#bncet">Message Headers</a>, and <a href="#bncev">Message Properties</a>.) A message selector cannot select messages on the basis
of the content of the message body.</p>



<a name="bnces"></a><h3>JMS Messages</h3>
<a name="indexterm-2398"></a><p>The ultimate purpose of a JMS application is to produce and consume messages
that can then be used by other software applications. JMS messages have a
basic format that is simple but highly flexible, allowing you to create messages
that match formats used by non-JMS applications on heterogeneous platforms.</p>

<p>A JMS message can have three parts: a header, properties, and a
body. Only the header is required. The following sections describe these parts.</p>

<p>For complete documentation of message headers, properties, and bodies, see the documentation of
the <tt>Message</tt> interface in the API documentation.</p>



<a name="bncet"></a><h4>Message Headers</h4>
<a name="indexterm-2399"></a><a name="indexterm-2400"></a><p>A JMS message header contains a number of predefined fields that contain values
used by both clients and providers to identify and route messages. <a href="#bnceu">Table&nbsp;47-1</a>
lists the JMS message header fields and indicates how their values are set.
For example, every message has a unique identifier, which is represented in the
header field <tt>JMSMessageID</tt>. The value of another header field, <tt>JMSDestination</tt>, represents the queue
or the topic to which the message is sent. Other fields include a
timestamp and a priority level.</p>

<p>Each header field has associated setter and getter methods, which are documented in
the description of the <tt>Message</tt> interface. Some header fields are intended to be
set by a client, but many are set automatically by the <tt>send</tt> or
the <tt>publish</tt> method, which overrides any client-set values.</p>

<a name="bnceu"></a><p class="caption">Table&nbsp;47-1 How JMS Message Header Field Values Are Set</p><table><col width="33%"><col width="66%"><tr><th align="left" valign="top" scope="column"><p>Header Field</p>

</th>
<th align="left" valign="top" scope="column"><p>Set By</p>

</th>
</tr>
<tr><td align="left" valign="top" scope="row"><p><a name="indexterm-2401"></a><a name="indexterm-2402"></a><tt>JMSDestination</tt></p>

</td>
<td align="left" valign="top" scope="row"><p><tt>send</tt> or <tt>publish</tt> method</p>

</td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><a name="indexterm-2403"></a><a name="indexterm-2404"></a><tt>JMSDeliveryMode</tt></p>

</td>
<td align="left" valign="top" scope="row"><p><tt>send</tt>
or <tt>publish</tt> method</p>

</td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><a name="indexterm-2405"></a><a name="indexterm-2406"></a><tt>JMSExpiration</tt></p>

</td>
<td align="left" valign="top" scope="row"><p><tt>send</tt> or <tt>publish</tt> method</p>

</td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><a name="indexterm-2407"></a><a name="indexterm-2408"></a><tt>JMSPriority</tt></p>

</td>
<td align="left" valign="top" scope="row"><p><tt>send</tt> or <tt>publish</tt> method</p>

</td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><a name="indexterm-2409"></a><a name="indexterm-2410"></a><tt>JMSMessageID</tt></p>

</td>
<td align="left" valign="top" scope="row"><p><tt>send</tt> or <tt>publish</tt> method</p>

</td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><a name="indexterm-2411"></a><a name="indexterm-2412"></a><tt>JMSTimestamp</tt></p>

</td>
<td align="left" valign="top" scope="row"><p><tt>send</tt>
or <tt>publish</tt> method</p>

</td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><a name="indexterm-2413"></a><a name="indexterm-2414"></a><tt>JMSCorrelationID</tt></p>

</td>
<td align="left" valign="top" scope="row"><p>Client</p>

</td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><a name="indexterm-2415"></a><a name="indexterm-2416"></a><tt>JMSReplyTo</tt></p>

</td>
<td align="left" valign="top" scope="row"><p>Client</p>

</td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><a name="indexterm-2417"></a><tt>JMSType</tt></p>

</td>
<td align="left" valign="top" scope="row"><p>Client</p>

</td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><a name="indexterm-2418"></a><a name="indexterm-2419"></a><tt>JMSRedelivered</tt></p>

</td>
<td align="left" valign="top" scope="row"><p>JMS provider</p>

</td>
</tr>
</table>

<a name="bncev"></a><h4>Message Properties</h4>
<a name="indexterm-2420"></a><a name="indexterm-2421"></a><p>You can create and set properties for messages if you need values
in addition to those provided by the header fields. You can use properties
to provide compatibility with other messaging systems, or you can use them to create
message selectors (see <a href="#bncer">JMS Message Selectors</a>). For an example of setting a property to be
used as a message selector, see <a href="bncgw.html">An Application That Uses the JMS API with a Session Bean</a>.</p>

<p>The JMS API provides some predefined property names that a provider can support.
The use of these predefined properties or of user-defined properties is optional.</p>



<a name="bncew"></a><h4>Message Bodies</h4>
<a name="indexterm-2422"></a><a name="indexterm-2423"></a><p>The JMS API defines five message body formats, also called message types, which
allow you to send and receive data in many different forms and
which provide compatibility with existing messaging formats. <a href="#bncex">Table&nbsp;47-2</a> describes these message types.</p>

<a name="bncex"></a><p class="caption">Table&nbsp;47-2 JMS Message Types</p><table><col width="25%"><col width="75%"><tr><th align="left" valign="top" scope="column"><p>Message Type</p>

</th>
<th align="left" valign="top" scope="column"><p>Body
Contains</p>

</th>
</tr>
<tr><td align="left" valign="top" scope="row"><p><a name="indexterm-2424"></a><tt>TextMessage</tt></p>

</td>
<td align="left" valign="top" scope="row"><p>A <tt>java.lang.String</tt> object (for example, the contents of an XML file).</p>

</td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><a name="indexterm-2425"></a><tt>MapMessage</tt></p>

</td>
<td align="left" valign="top" scope="row"><p>A set of
name-value pairs, with names as <tt>String</tt> objects and values as primitive types in
the Java programming language. The entries can be accessed sequentially by enumerator or
randomly by name. The order of the entries is undefined.</p>

</td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><a name="indexterm-2426"></a><tt>BytesMessage</tt></p>

</td>
<td align="left" valign="top" scope="row"><p>A stream of uninterpreted
bytes. This message type is for literally encoding a body to match an
existing message format.</p>

</td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><a name="indexterm-2427"></a><tt>StreamMessage</tt></p>

</td>
<td align="left" valign="top" scope="row"><p>A stream of primitive values in the Java programming language,
filled and read sequentially.</p>

</td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><a name="indexterm-2428"></a><tt>ObjectMessage</tt></p>

</td>
<td align="left" valign="top" scope="row"><p>A <tt>Serializable</tt> object in the Java programming language.</p>

</td>
</tr>
<tr><td align="left" valign="top" scope="row"><p><a name="indexterm-2429"></a><tt>Message</tt></p>

</td>
<td align="left" valign="top" scope="row"><p>Nothing. Composed of header
fields and properties only. This message type is useful when a message body
is not required.</p>

</td>
</tr>
</table><p>The JMS API provides methods for creating messages of each type and for
filling in their contents. For example, to create and send a <tt>TextMessage</tt>,
you might use the following statements:</p>

<pre>TextMessage message = session.createTextMessage();
message.setText(msg_text);     // msg_text is a String
producer.send(message);</pre><p>At the consuming end, a message arrives as a generic <tt>Message</tt> object
and must be cast to the appropriate message type. You can use one
or more getter methods to extract the message contents. The following code fragment
uses the <tt>getText</tt> method:</p>

<pre>Message m = consumer.receive();
if (m instanceof TextMessage) {
    TextMessage message = (TextMessage) m;
    System.out.println("Reading message: " + message.getText());
} else {
    // Handle error
}</pre>

<a name="bncey"></a><h3>JMS Queue Browsers</h3>
<a name="indexterm-2430"></a><a name="indexterm-2431"></a><a name="indexterm-2432"></a><p>Messages sent to a queue remain in the queue until the message
consumer for that queue consumes them. The JMS API provides a <tt>QueueBrowser</tt> object that
allows you to browse the messages in the queue and display the
header values for each message. To create a <tt>QueueBrowser</tt> object, use the <tt>Session.createBrowser</tt> method.
For example:</p>

<pre>QueueBrowser browser = session.createBrowser(queue);</pre><p>See <a href="bncfa.html#bncfl">A Simple Example of Browsing Messages in a Queue</a> for an example of using a <tt>QueueBrowser</tt> object.</p>

<p>The <tt>createBrowser</tt> method allows you to specify a message selector as a second
argument when you create a <tt>QueueBrowser</tt>. For information on message selectors, see
<a href="#bncer">JMS Message Selectors</a>.</p>

<p>The JMS API provides no mechanism for browsing a topic. Messages usually disappear
from a topic as soon as they appear: If there are no
message consumers to consume them, the JMS provider removes them. Although durable subscriptions allow
messages to remain on a topic while the message consumer is not
active, no facility exists for examining them.</p>



<a name="bncez"></a><h3>JMS Exception Handling</h3>
<a name="indexterm-2433"></a><a name="indexterm-2434"></a><p>The root class for exceptions thrown by JMS API methods is <tt>JMSException</tt>.
Catching <tt>JMSException</tt> provides a generic way of handling all exceptions related to the
JMS API. </p>

<p>The <tt>JMSException</tt> class includes the following subclasses, described in the API documentation:</p>


<ul><li><p><tt>IllegalStateException</tt></p>

</li>
<li><p><tt>InvalidClientIDException</tt></p>

</li>
<li><p><tt>InvalidDestinationException</tt></p>

</li>
<li><p><tt>InvalidSelectorException</tt></p>

</li>
<li><p><tt>JMSSecurityException</tt></p>

</li>
<li><p><tt>MessageEOFException</tt></p>

</li>
<li><p><tt>MessageFormatException</tt></p>

</li>
<li><p><tt>MessageNotReadableException</tt></p>

</li>
<li><p><tt>MessageNotWriteableException</tt></p>

</li>
<li><p><tt>ResourceAllocationException</tt></p>

</li>
<li><p><tt>TransactionInProgressException</tt></p>

</li>
<li><p><tt>TransactionRolledBackException</tt></p>

</li></ul>
<p>All the examples in the tutorial catch and handle <tt>JMSException</tt> when it is
appropriate to do so.</p>


         </div>
         <div class="navigation">
             <a href="bncdx.html"><img src="graphics/leftButton.gif" border="0" alt="Previous" title="Previous"></a>
             <a href="p1.html"><img src="graphics/upButton.gif" border="0" alt="Contents" title="Contents"></a>
             <a href="bncfu.html"><img src="graphics/rightButton.gif" border="0" alt="Next" title="Next"></a>
         </div>

         <div class="copyright">
      	    <p>Copyright &copy; 2013, Oracle and/or its affiliates. All rights reserved. <a href="docinfo.html">Legal Notices</a></p>
      	 </div>

      </td>
   </tr>
</tbody>
</table>
<!-- Start SiteCatalyst code   -->
<script language="JavaScript" src="http://www.oracle.com/ocom/groups/systemobject/@mktg_admin/documents/systemobject/s_code_download.js"></script>
<script language="JavaScript" src="http://www.oracle.com/ocom/groups/systemobject/@mktg_admin/documents/systemobject/s_code.js"></script>
 
<!-- ********** DO NOT ALTER ANYTHING BELOW THIS LINE ! *********** -->
<!--  Below code will send the info to Omniture server -->
<script language="javascript">var s_code=s.t();if(s_code)document.write(s_code)</script>
<noscript><p>Scripting on this page tracks web page traffic,
but does not change the content in any way.</p></noscript>
<!-- End SiteCatalyst code -->
</body>
</html>

