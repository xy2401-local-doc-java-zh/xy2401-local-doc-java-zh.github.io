<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en-US">
<head>
<!-- GenHTML revision 25226-->
<meta http-equiv="Content-type" content="text/html; charset=utf-8">
<title>Creating Custom Component Classes - The Java EE 6 Tutorial</title>
<meta name="robots" content="index,follow">
<meta name="robots" content="index,follow">
<meta name="date" content="2013-01-01">
<link rel="stylesheet" type="text/css" href="css/default.css">
<link rel="stylesheet" type="text/css" href="css/ipg.css">
<link rel="stylesheet" type="text/css" href="css/javaeetutorial.css">
<script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>

<body>

<table border="0" cellpadding="5" cellspacing="0" width="100%">
<tbody>
   <tr valign="top">
      <td width="400px"><p class="toc level1"><a href="docinfo.html">Document Information</a></p>
<p class="toc level1 tocsp"><a href="gexaf.html">Preface</a></p>
<p class="toc level1 tocsp"><a href="gfirp.html">Part&nbsp;I&nbsp;Introduction</a></p>
<p class="toc level2"><a href="bnaaw.html">1.&nbsp;&nbsp;Overview</a></p>
<p class="toc level2"><a href="gfiud.html">2.&nbsp;&nbsp;Using the Tutorial Examples</a></p>
<p class="toc level1 tocsp"><a href="bnadp.html">Part&nbsp;II&nbsp;The Web Tier</a></p>
<p class="toc level2"><a href="bnadr.html">3.&nbsp;&nbsp;Getting Started with Web Applications</a></p>
<p class="toc level2"><a href="bnaph.html">4.&nbsp;&nbsp;JavaServer Faces Technology</a></p>
<p class="toc level2"><a href="giepx.html">5.&nbsp;&nbsp;Introduction to Facelets</a></p>
<p class="toc level2"><a href="gjddd.html">6.&nbsp;&nbsp;Expression Language</a></p>
<p class="toc level2"><a href="bnaqz.html">7.&nbsp;&nbsp;Using JavaServer Faces Technology in Web Pages</a></p>
<p class="toc level2"><a href="gjcut.html">8.&nbsp;&nbsp;Using Converters, Listeners, and Validators</a></p>
<p class="toc level2"><a href="bnatx.html">9.&nbsp;&nbsp;Developing with JavaServer Faces Technology</a></p>
<p class="toc level2"><a href="gkmaa.html">10.&nbsp;&nbsp;JavaServer Faces Technology: Advanced Concepts</a></p>
<p class="toc level2"><a href="gkiow.html">11.&nbsp;&nbsp;Using Ajax with JavaServer Faces Technology</a></p>
<p class="toc level2"><a href="gkhxa.html">12.&nbsp;&nbsp;Composite Components: Advanced Topics and Example</a></p>
<p class="toc level2"><a href="bnavg.html">13.&nbsp;&nbsp;Creating Custom UI Components and Other Custom Objects</a></p>
<p class="toc level3"><a href="bnavh.html">Determining Whether You Need a Custom Component or Renderer</a></p>
<p class="toc level4"><a href="bnavh.html#bnavi">When to Use a Custom Component</a></p>
<p class="toc level4"><a href="bnavh.html#bnavj">When to Use a Custom Renderer</a></p>
<p class="toc level4"><a href="bnavh.html#bnavk">Component, Renderer, and Tag Combinations</a></p>
<p class="toc level3 tocsp"><a href="glpcb.html">Understanding the Image Map Example</a></p>
<p class="toc level4"><a href="glpcb.html#glpbd">Why Use JavaServer Faces Technology to Implement an Image Map?</a></p>
<p class="toc level4"><a href="glpcb.html#glpem">Understanding the Rendered HTML</a></p>
<p class="toc level4"><a href="glpcb.html#glpcd">Understanding the Facelets Page</a></p>
<p class="toc level4"><a href="glpcb.html#glpbo">Configuring Model Data</a></p>
<p class="toc level4"><a href="glpcb.html#glpel">Summary of the Image Map Application Classes</a></p>
<p class="toc level3 tocsp"><a href="bnavt.html">Steps for Creating a Custom Component</a></p>
<div id="scrolltoc" class="onpage">
<p class="toc level3"><a href="">Creating Custom Component Classes</a></p>
<p class="toc level4"><a href="#bnavv">Specifying the Component Family</a></p>
<p class="toc level4"><a href="#bnavw">Performing Encoding</a></p>
<p class="toc level4"><a href="#bnavx">Performing Decoding</a></p>
<p class="toc level4"><a href="#bnavy">Enabling Component Properties to Accept Expressions</a></p>
<p class="toc level4"><a href="#bnavz">Saving and Restoring State</a></p>
</div>
<p class="toc level3 tocsp"><a href="bnawa.html">Delegating Rendering to a Renderer</a></p>
<p class="toc level4"><a href="bnawa.html#bnawb">Creating the Renderer Class</a></p>
<p class="toc level4"><a href="bnawa.html#bnawc">Identifying the Renderer Type</a></p>
<p class="toc level3 tocsp"><a href="bnaut.html">Implementing an Event Listener</a></p>
<p class="toc level4"><a href="bnaut.html#bnauu">Implementing Value-Change Listeners</a></p>
<p class="toc level4"><a href="bnaut.html#bnauv">Implementing Action Listeners</a></p>
<p class="toc level3 tocsp"><a href="bnawd.html">Handling Events for Custom Components</a></p>
<p class="toc level3"><a href="bnawn.html">Defining the Custom Component Tag in a Tag Library Descriptor</a></p>
<p class="toc level3"><a href="bnatt.html">Using a Custom Component</a></p>
<p class="toc level3"><a href="bnaus.html">Creating and Using a Custom Converter</a></p>
<p class="toc level4"><a href="bnaus.html#glphb">Creating a Custom Converter</a></p>
<p class="toc level4"><a href="bnaus.html#bnatu">Using a Custom Converter</a></p>
<p class="toc level3 tocsp"><a href="bnauw.html">Creating and Using a Custom Validator</a></p>
<p class="toc level4"><a href="bnauw.html#bnaux">Implementing the Validator Interface</a></p>
<p class="toc level4"><a href="bnauw.html#bnauy">Specifying a Custom Tag</a></p>
<p class="toc level4"><a href="bnauw.html#bnatv">Using a Custom Validator</a></p>
<p class="toc level3 tocsp"><a href="bnatg.html">Binding Component Values and Instances to Managed Bean Properties</a></p>
<p class="toc level4"><a href="bnatg.html#bnati">Binding a Component Value to a Property</a></p>
<p class="toc level4"><a href="bnatg.html#bnatj">Binding a Component Value to an Implicit Object</a></p>
<p class="toc level4"><a href="bnatg.html#bnatl">Binding a Component Instance to a Bean Property</a></p>
<p class="toc level3 tocsp"><a href="bnatm.html">Binding Converters, Listeners, and Validators to Managed Bean Properties</a></p>
<p class="toc level2 tocsp"><a href="bnawo.html">14.&nbsp;&nbsp;Configuring JavaServer Faces Applications</a></p>
<p class="toc level2"><a href="bnafd.html">15.&nbsp;&nbsp;Java Servlet Technology</a></p>
<p class="toc level2"><a href="glrbb.html">16.&nbsp;&nbsp;Uploading Files with Java Servlet Technology</a></p>
<p class="toc level2"><a href="bnaxu.html">17.&nbsp;&nbsp;Internationalizing and Localizing Web Applications</a></p>
<p class="toc level1 tocsp"><a href="bnayk.html">Part&nbsp;III&nbsp;Web Services</a></p>
<p class="toc level2"><a href="gijti.html">18.&nbsp;&nbsp;Introduction to Web Services</a></p>
<p class="toc level2"><a href="bnayl.html">19.&nbsp;&nbsp;Building Web Services with JAX-WS</a></p>
<p class="toc level2"><a href="giepu.html">20.&nbsp;&nbsp;Building RESTful Web Services with JAX-RS</a></p>
<p class="toc level2"><a href="gjjxe.html">21.&nbsp;&nbsp;JAX-RS: Advanced Topics and Example</a></p>
<p class="toc level1 tocsp"><a href="bnblr.html">Part&nbsp;IV&nbsp;Enterprise Beans</a></p>
<p class="toc level2"><a href="gijsz.html">22.&nbsp;&nbsp;Enterprise Beans</a></p>
<p class="toc level2"><a href="gijre.html">23.&nbsp;&nbsp;Getting Started with Enterprise Beans</a></p>
<p class="toc level2"><a href="gijrb.html">24.&nbsp;&nbsp;Running the Enterprise Bean Examples</a></p>
<p class="toc level2"><a href="bnbpk.html">25.&nbsp;&nbsp;A Message-Driven Bean Example</a></p>
<p class="toc level2"><a href="gkcqz.html">26.&nbsp;&nbsp;Using the Embedded Enterprise Bean Container</a></p>
<p class="toc level2"><a href="gkidz.html">27.&nbsp;&nbsp;Using Asynchronous Method Invocation in Session Beans</a></p>
<p class="toc level1 tocsp"><a href="gjbnr.html">Part&nbsp;V&nbsp;Contexts and Dependency Injection for the Java EE Platform</a></p>
<p class="toc level2"><a href="giwhb.html">28.&nbsp;&nbsp;Introduction to Contexts and Dependency Injection for the Java EE Platform</a></p>
<p class="toc level2"><a href="gjbls.html">29.&nbsp;&nbsp;Running the Basic Contexts and Dependency Injection Examples</a></p>
<p class="toc level2"><a href="gjehi.html">30.&nbsp;&nbsp;Contexts and Dependency Injection for the Java EE Platform: Advanced Topics</a></p>
<p class="toc level2"><a href="gkhre.html">31.&nbsp;&nbsp;Running the Advanced Contexts and Dependency Injection Examples</a></p>
<p class="toc level1 tocsp"><a href="bnbpy.html">Part&nbsp;VI&nbsp;Persistence</a></p>
<p class="toc level2"><a href="bnbpz.html">32.&nbsp;&nbsp;Introduction to the Java Persistence API</a></p>
<p class="toc level2"><a href="gijst.html">33.&nbsp;&nbsp;Running the Persistence Examples</a></p>
<p class="toc level2"><a href="bnbtg.html">34.&nbsp;&nbsp;The Java Persistence Query Language</a></p>
<p class="toc level2"><a href="gjitv.html">35.&nbsp;&nbsp;Using the Criteria API to Create Queries</a></p>
<p class="toc level2"><a href="gkjiq.html">36.&nbsp;&nbsp;Creating and Using String-Based Criteria Queries</a></p>
<p class="toc level2"><a href="gkjjf.html">37.&nbsp;&nbsp;Controlling Concurrent Access to Entity Data with Locking</a></p>
<p class="toc level2"><a href="gkjia.html">38.&nbsp;&nbsp;Using a Second-Level Cache with Java Persistence API Applications</a></p>
<p class="toc level1 tocsp"><a href="gijrp.html">Part&nbsp;VII&nbsp;Security</a></p>
<p class="toc level2"><a href="bnbwj.html">39.&nbsp;&nbsp;Introduction to Security in the Java EE Platform</a></p>
<p class="toc level2"><a href="bncas.html">40.&nbsp;&nbsp;Getting Started Securing Web Applications</a></p>
<p class="toc level2"><a href="bnbyk.html">41.&nbsp;&nbsp;Getting Started Securing Enterprise Applications</a></p>
<p class="toc level2"><a href="gjjwx.html">42.&nbsp;&nbsp;Java EE Security: Advanced Topics</a></p>
<p class="toc level1 tocsp"><a href="gijue.html">Part&nbsp;VIII&nbsp;Java EE Supporting Technologies</a></p>
<p class="toc level2"><a href="gijto.html">43.&nbsp;&nbsp;Introduction to Java EE Supporting Technologies</a></p>
<p class="toc level2"><a href="bncih.html">44.&nbsp;&nbsp;Transactions</a></p>
<p class="toc level2"><a href="bncjh.html">45.&nbsp;&nbsp;Resources and Resource Adapters</a></p>
<p class="toc level2"><a href="glodb.html">46.&nbsp;&nbsp;The Resource Adapter Example</a></p>
<p class="toc level2"><a href="bncdq.html">47.&nbsp;&nbsp;Java Message Service Concepts</a></p>
<p class="toc level2"><a href="bncgv.html">48.&nbsp;&nbsp;Java Message Service Examples</a></p>
<p class="toc level2"><a href="gkahp.html">49.&nbsp;&nbsp;Bean Validation: Advanced Topics</a></p>
<p class="toc level2"><a href="gkeed.html">50.&nbsp;&nbsp;Using Java EE Interceptors</a></p>
<p class="toc level1 tocsp"><a href="gkgjw.html">Part&nbsp;IX&nbsp;Case Studies</a></p>
<p class="toc level2"><a href="glnvi.html">51.&nbsp;&nbsp;Duke's Bookstore Case Study Example</a></p>
<p class="toc level2"><a href="gkaee.html">52.&nbsp;&nbsp;Duke's Tutoring Case Study Example</a></p>
<p class="toc level2"><a href="glnpw.html">53.&nbsp;&nbsp;Duke's Forest Case Study Example</a></p>
<p class="toc level1 tocsp"><a href="idx-1.html">Index</a></p>
</td>
      <td width="10px">&nbsp;</td>
      <td>
         <div class="header">
             <div class="banner">
                <table width="100%" border="0" cellpadding="5" cellspacing="0">
                   <tbody>
                      <tr>
                         <td valign="bottom"><p class="Banner">The Java EE 6 Tutorial
</p></td>
                         <td align="right"  valign="bottom"><img src="graphics/javalogo.png" alt="Java Coffee Cup logo"></td>
                      </tr>
                   </tbody>
                </table>
             </div>

             <div class="header-links">
	         <a href="./index.html">Home</a> | 
<a href="../information/download.html">Download</a> | 
<a href="./javaeetutorial6.pdf">PDF</a> | 
<a href="../information/faq.html">FAQ</a> | 
<a href="http://docs.oracle.com/javaee/support/feedback.htm">Feedback</a>

             </div>
             <div class="navigation">
                 <a href="bnavt.html"><img src="graphics/leftButton.gif" border="0" alt="Previous" title="Previous"></a>
                 <a href="p1.html"><img src="graphics/upButton.gif" border="0" alt="Contents" title="Contents"></a>
                 <a href="bnawa.html"><img src="graphics/rightButton.gif" border="0" alt="Next" title="Next"></a>
             </div>
         </div>

	 <div class="maincontent">      	 
             

<a name="bnavu"></a><h2>Creating Custom Component Classes</h2>
<a name="indexterm-829"></a><p>As explained in <a href="bnavh.html#bnavi">When to Use a Custom Component</a>, a component class defines the state and behavior of
a UI component. The state information includes the component&rsquo;s type, identifier, and local
value. The behavior defined by the component class includes the following:</p>


<ul><li><p><a name="indexterm-830"></a>Decoding (converting the request parameter to the component&rsquo;s local value)</p>

</li>
<li><p><a name="indexterm-831"></a>Encoding (converting the local value into the corresponding markup)</p>

</li>
<li><p>Saving the state of the component</p>

</li>
<li><p>Updating the bean value with the local value</p>

</li>
<li><p>Processing validation on the local value</p>

</li>
<li><p>Queueing events</p>

</li></ul>
<p><a name="indexterm-832"></a>The <tt>javax.faces.component.UIComponentBase</tt> class defines the default behavior of a component class. All the
classes representing the standard components extend from <tt>UIComponentBase</tt>. These classes add their
own behavior definitions, as your custom component class will do.</p>

<p><a name="indexterm-833"></a>Your custom component class must either extend <tt>UIComponentBase</tt> directly or extend a class representing
one of the standard components. These classes are located in the <tt>javax.faces.component</tt> package
and their names begin with <tt>UI</tt>.</p>

<p>If your custom component serves the same purpose as a standard component, you
should extend that standard component rather than directly extend <tt>UIComponentBase</tt>. For example,
suppose you want to create an editable menu component. It makes sense to
have this component extend <tt>UISelectOne</tt> rather than <tt>UIComponentBase</tt> because you can reuse the
behavior already defined in <tt>UISelectOne</tt>. The only new functionality you need to define
is to make the menu editable.</p>

<p>Whether you decide to have your component extend <tt>UIComponentBase</tt> or a standard
component, you might also want your component to implement one or more of
these behavioral interfaces defined in the <tt>javax.faces.component</tt> package:</p>


<ul><li><p><a name="indexterm-834"></a><tt>ActionSource</tt>: Indicates that the component can fire a <tt>javax.faces.event.ActionEvent</tt>.</p>

</li>
<li><p><a name="indexterm-835"></a><tt>ActionSource2</tt>: Extends <tt>ActionSource</tt> and allows component properties referencing methods that handle action events to use method expressions as defined by the unified EL.</p>

</li>
<li><p><a name="indexterm-836"></a><tt>EditableValueHolder</tt>: Extends <tt>ValueHolder</tt> and specifies additional features for editable components, such as validation and emitting value-change events.</p>

</li>
<li><p><a name="indexterm-837"></a><tt>NamingContainer</tt>: Mandates that each component rooted at this component have a unique ID.</p>

</li>
<li><p><a name="indexterm-838"></a><tt>StateHolder</tt>: Denotes that a component has state that must be saved between requests.</p>

</li>
<li><p><a name="indexterm-839"></a><tt>ValueHolder</tt>: Indicates that the component maintains a local value as well as the option of accessing data in the model tier.</p>

</li></ul>
<p><a name="indexterm-840"></a><a name="indexterm-841"></a>If your component extends <tt>UIComponentBase</tt>, it automatically implements only <tt>StateHolder</tt>. Because all components
directly or indirectly extend <tt>UIComponentBase</tt>, they all implement <tt>StateHolder</tt>. Any component that implements <tt>StateHolder</tt>
also implements the <tt>StateHelper</tt> interface, which extends <tt>StateHolder</tt> and defines a <tt>Map</tt>-like contract that
makes it easy for components to save and restore a partial view state.</p>

<p>If your component extends one of the other standard components, it might also
implement other behavioral interfaces in addition to <tt>StateHolder</tt>. If your component extends
<tt>UICommand</tt>, it automatically implements <tt>ActionSource2</tt>. If your component extends <tt>UIOutput</tt> or one of the
component classes that extend <tt>UIOutput</tt>, it automatically implements <tt>ValueHolder</tt>. If your component extends
<tt>UIInput</tt>, it automatically implements <tt>EditableValueHolder</tt> and <tt>ValueHolder</tt>. See the JavaServer Faces API documentation
to find out what the other component classes implement.</p>

<p>You can also make your component explicitly implement a behavioral interface that it
doesn&rsquo;t already by virtue of extending a particular standard component. For example, if
you have a component that extends <tt>UIInput</tt> and you want it to fire
action events, you must make it explicitly implement <tt>ActionSource2</tt> because a <tt>UIInput</tt>
component doesn&rsquo;t automatically implement this interface.</p>

<p>The Duke's Bookstore image map example has two component classes: <tt>AreaComponent</tt> and
<tt>MapComponent</tt>. The <tt>MapComponent</tt> class extends <tt>UICommand</tt> and therefore implements <tt>ActionSource2</tt>, which means it can
fire action events when a user clicks on the map. The <tt>AreaComponent</tt>
class extends the standard component <tt>UIOutput</tt>. The <tt>@FacesComponent</tt> annotation registers the components with the
JavaServer Faces implementation:</p>

<pre>@FacesComponent("DemoMap")
public class MapComponent extends UICommand {...}

@FacesComponent("DemoArea")
public class AreaComponent extends UIOutput {...}</pre><p>The <tt>MapComponent</tt> class represents the component corresponding to the <tt>bookstore:map</tt> tag:</p>

<pre>&lt;bookstore:map id="bookMap" 
               current="map1" 
               immediate="true"
               action="bookstore">
    ...
&lt;/bookstore:map></pre><p>The <tt>AreaComponent</tt> class represents the component corresponding to the <tt>bookstore:area</tt> tag:</p>

<pre>&lt;bookstore:area id="map1" value="#{Book201}" 
                onmouseover="resources/images/book_201.jpg" 
                onmouseout="resources/images/book_all.jpg" 
                targetImage="mapImage"/></pre><p><tt>MapComponent</tt> has one or more <tt>AreaComponent</tt> instances as children. Its behavior consists
of the following actions:</p>


<ul><li><p>Retrieving the value of the currently selected area</p>

</li>
<li><p>Defining the properties corresponding to the component's values</p>

</li>
<li><p>Generating an event when the user clicks on the image map</p>

</li>
<li><p>Queuing the event</p>

</li>
<li><p>Saving its state</p>

</li>
<li><p>Rendering the HTML <tt>map</tt> tag and the HTML <tt>input</tt> tag</p>

</li></ul>
<p><tt>MapComponent</tt> delegates the rendering of the HTML <tt>map</tt> and input tags to
the <tt>MapRenderer</tt> class.</p>

<p><tt>AreaComponent</tt> is bound to a bean that stores the shape and coordinates of
the region of the image map. You will see how all this data
is accessed through the value expression in <a href="bnawa.html#bnawb">Creating the Renderer Class</a>. The behavior of <tt>AreaComponent</tt>
consists of the following:</p>


<ul><li><p>Retrieving the shape and coordinate data from the bean</p>

</li>
<li><p>Setting the value of the hidden tag to the <tt>id</tt> of this component</p>

</li>
<li><p>Rendering the <tt>area</tt> tag, including the JavaScript for the <tt>onmouseover</tt>, <tt>onmouseout</tt>, and <tt>onclick</tt> functions</p>

</li></ul>
<p>Although these tasks are actually performed by <tt>AreaRenderer</tt>, <tt>AreaComponent</tt> must delegate the
tasks to <tt>AreaRenderer</tt>. See <a href="bnawa.html">Delegating Rendering to a Renderer</a> for more information.</p>

<p>The rest of this section describes the tasks that <tt>MapComponent</tt> performs as well
as the encoding and decoding that it delegates to <tt>MapRenderer</tt>. <a href="bnawd.html">Handling Events for Custom Components</a> details
how <tt>MapComponent</tt> handles events.</p>



<a name="bnavv"></a><h3>Specifying the Component Family</h3>
<p>If your custom component class delegates rendering, it needs to override the <tt>getFamily</tt>
method of <tt>UIComponent</tt> to return the identifier of a <b>component family</b>, which is used to
refer to a component or set of components that can be rendered by
a renderer or set of renderers.</p>

<p>The component family is used along with the renderer type to look
up renderers that can render the component:</p>

<pre>public String getFamily() {
    return ("Map");
}</pre><p>The component family identifier, <tt>Map</tt>, must match that defined by the <tt>component-family</tt> elements
included in the component and renderer configurations in the application configuration resource file. <a href="bnaxh.html">Registering a Custom Renderer with a Render Kit</a>
explains how to define the component family in the renderer configuration. <a href="bnaxi.html">Registering a Custom Component</a> explains how
to define the component family in the component configuration.</p>



<a name="bnavw"></a><h3>Performing Encoding</h3>
<a name="indexterm-842"></a><p><a name="indexterm-843"></a>During the Render Response phase, the JavaServer Faces implementation processes the encoding methods of
all components and their associated renderers in the view. The encoding methods convert
the current local value of the component into the corresponding markup that represents
it in the response.</p>

<p><a name="indexterm-844"></a><a name="indexterm-845"></a><a name="indexterm-846"></a><a name="indexterm-847"></a>The <tt>UIComponentBase</tt> class defines a set of methods for rendering markup: <tt>encodeBegin</tt>, <tt>encodeChildren</tt>,
and <tt>encodeEnd</tt>. If the component has child components, you might need to use
more than one of these methods to render the component; otherwise, all rendering
should be done in <tt>encodeEnd</tt>. Alternatively, you can use the <tt>encodeALL</tt> method, which
encompasses all the methods.</p>

<p>Because <tt>MapComponent</tt> is a parent component of <tt>AreaComponent</tt>, the <tt>area</tt> tags must
be rendered after the beginning <tt>map</tt> tag and before the ending <tt>map</tt> tag.
To accomplish this, the <tt>MapRenderer</tt> class renders the beginning <tt>map</tt> tag in <tt>encodeBegin</tt>
and the rest of the <tt>map</tt> tag in <tt>encodeEnd</tt>.</p>

<p>The JavaServer Faces implementation automatically invokes the <tt>encodeEnd</tt> method of <tt>AreaComponent</tt>'s renderer
after it invokes <tt>MapRenderer</tt>'s <tt>encodeBegin</tt> method and before it invokes <tt>MapRenderer</tt>'s <tt>encodeEnd</tt> method. If a
component needs to perform the rendering for its children, it does this in
the <tt>encodeChildren</tt> method.</p>

<p>Here are the <tt>encodeBegin</tt> and <tt>encodeEnd</tt> methods of <tt>MapRenderer</tt>:</p>

<pre>@Override
public void encodeBegin(FacesContext context, UIComponent component) 
        throws IOException {
    if ((context == null)|| (component == null)){
        throw new NullPointerException();
    }
    MapComponent map = (MapComponent) component;
    ResponseWriter writer = context.getResponseWriter();
    writer.startElement("map", map);
    writer.writeAttribute("name", map.getId(), "id");
}

@Override
public void encodeEnd(FacesContext context, UIComponent component) 
        throws IOException {
    if ((context == null) || (component == null)){
        throw new NullPointerException();
    }
    MapComponent map = (MapComponent) component;
    ResponseWriter writer = context.getResponseWriter();
    writer.startElement("input", map);
    writer.writeAttribute("type", "hidden", null);
    writer.writeAttribute("name", getName(context,map), "clientId");(
    writer.endElement("input");
    writer.endElement("map");
}</pre><p>Notice that <tt>encodeBegin</tt> renders only the beginning <tt>map</tt> tag. The <tt>encodeEnd</tt> method
renders the <tt>input</tt> tag and the ending <tt>map</tt> tag.</p>

<p><a name="indexterm-848"></a>The encoding methods accept a <tt>UIComponent</tt> argument and a <tt>javax.faces.context.FacesContext</tt> argument. The <tt>FacesContext</tt>
instance contains all the information associated with the current request. The <tt>UIComponent</tt> argument
is the component that needs to be rendered.</p>

<p>The rest of the method renders the markup to the <tt>javax.faces.context.ResponseWriter</tt> instance,
which writes out the markup to the current response. This basically involves passing
the HTML tag names and attribute names to the <tt>ResponseWriter</tt> instance as strings,
retrieving the values of the component attributes, and passing these values to the
<tt>ResponseWriter</tt> instance.</p>

<p>The <tt>startElement</tt> method takes a <tt>String</tt> (the name of the tag) and the
component to which the tag corresponds (in this case, <tt>map</tt>). (Passing this
information to the <tt>ResponseWriter</tt> instance helps design-time tools know which portions of the
generated markup are related to which components.)</p>

<p>After calling <tt>startElement</tt>, you can call <tt>writeAttribute</tt> to render the tag's attributes.
The <tt>writeAttribute</tt> method takes the name of the attribute, its value, and
the name of a property or attribute of the containing component corresponding to
the attribute. The last parameter can be null, and it won't be rendered.</p>

<p>The <tt>name</tt> attribute value of the <tt>map</tt> tag is retrieved using the <tt>getId</tt>
method of <tt>UIComponent</tt>, which returns the component's unique identifier. The <tt>name</tt> attribute value
of the <tt>input</tt> tag is retrieved using the <tt>getName(FacesContext, UIComponent)</tt> method of <tt>MapRenderer</tt>.</p>

<p>If you want your component to perform its own rendering but delegate to
a renderer if there is one, include the following lines in the
encoding method to check whether there is a renderer associated with this component:</p>

<pre>if (getRendererType() != null) {
    super.encodeEnd(context);
    return;
}</pre><p>If there is a renderer available, this method invokes the superclass's <tt>encodeEnd</tt>
method, which does the work of finding the renderer. The <tt>MapComponent</tt> class delegates
all rendering to <tt>MapRenderer</tt>, so it does not need to check for
available renderers.</p>

<p>In some custom component classes that extend standard components, you might need to
implement other methods in addition to <tt>encodeEnd</tt>. For example, if you need to
retrieve the component&rsquo;s value from the request parameters, you must also implement the
<tt>decode</tt> method.</p>



<a name="bnavx"></a><h3>Performing Decoding</h3>
<a name="indexterm-849"></a><p><a name="indexterm-850"></a><a name="indexterm-851"></a>During the Apply Request Values phase, the JavaServer Faces implementation processes the <tt>decode</tt>
methods of all components in the tree. The <tt>decode</tt> method extracts a component's local
value from incoming request parameters and uses a <tt>javax.faces.convert.Converter</tt> implementation to convert the value
to a type that is acceptable to the component class.</p>

<p><a name="indexterm-852"></a><a name="indexterm-853"></a>A custom component class or its renderer must implement the <tt>decode</tt> method
only if it must retrieve the local value or if it needs to
queue events. The component queues the event by calling <tt>queueEvent</tt>.</p>

<p>Here is the <tt>decode</tt> method of <tt>MapRenderer</tt>:</p>

<pre>@Override
public void decode(FacesContext context, UIComponent component) {
    if ((context == null) || (component == null)) {
        throw new NullPointerException();
    }
    MapComponent map = (MapComponent) component;
    String key = getName(context, map);
    String value = (String) context.getExternalContext().
            getRequestParameterMap().get(key);
    if (value != null)
        map.setCurrent(value);
    }
}</pre><p>The <tt>decode</tt> method first gets the name of the hidden <tt>input</tt> field by
calling <tt>getName(FacesContext, UIComponent)</tt>. It then uses that name as the key to the
request parameter map to retrieve the current value of the <tt>input</tt> field. This value
represents the currently selected area. Finally, it sets the value of the <tt>MapComponent</tt>
class's <tt>current</tt> attribute to the value of the <tt>input</tt> field.</p>



<a name="bnavy"></a><h3>Enabling Component Properties to Accept Expressions</h3>
<p><a name="indexterm-854"></a><a name="indexterm-855"></a><a name="indexterm-856"></a>Nearly all the attributes of the standard JavaServer Faces tags can accept expressions,
whether they are value expressions or method expressions. It is recommended that you
also enable your component attributes to accept expressions because it gives you much
more flexibility when you write Facelets pages.</p>

<p>To enable the attributes to accept expressions, the component class must implement getter
and setter methods for the component properties. These methods can use the facilities
offered by the <tt>StateHelper</tt> interface to store and retrieve not only the values
for these properties, but also the state of the components across multiple requests.</p>

<p>Because <tt>MapComponent</tt> extends <tt>UICommand</tt>, the <tt>UICommand</tt> class already does the work of getting the
<tt>ValueExpression</tt> and <tt>MethodExpression</tt> instances associated with each of the attributes that it supports.
Similarly, the <tt>UIOutput</tt> class that <tt>AreaComponent</tt> extends already obtains the <tt>ValueExpression</tt> instances for
its supported attributes. For both components, the simple getter and setter methods store and
retrieve the key values and state for the attributes, as shown in this
code fragment from <tt>AreaComponent</tt>:</p>

<pre>    enum PropertyKeys {
        alt, coords, shape, targetImage;
    }

    public String getAlt() {
        return (String) getStateHelper().eval(PropertyKeys.alt, null); 
    }

    public void setAlt(String alt) {
        getStateHelper().put(PropertyKeys.alt, alt); 
    }
    ...</pre><p>However, if you have a custom component class that extends <tt>UIComponentBase</tt>, you
will need to implement the methods that get the <tt>ValueExpression</tt> and <tt>MethodExpression</tt>
instances associated with those attributes that are enabled to accept expressions. For example, you
could include a method that gets the <tt>ValueExpression</tt> instance for the <tt>immediate</tt> attribute:</p>

<pre>public boolean isImmediate() {
    if (this.immediateSet) {
        return (this.immediate);
    }
    ValueExpression ve = getValueExpression("immediate");
    if (ve != null) {
        Boolean value = (Boolean) ve.getValue(
            getFacesContext().getELContext());
        return (value.booleanValue());
    } else {
        return (this.immediate);
    }
}</pre><p>The properties corresponding to the component attributes that accept method expressions must accept
and return a <tt>MethodExpression</tt> object. For example, if <tt>MapComponent</tt> extended <tt>UIComponentBase</tt> instead of
<tt>UICommand</tt>, it would need to provide an <tt>action</tt> property that returns and accepts
a <tt>MethodExpression</tt> object:</p>

<pre>public MethodExpression getAction() {
    return (this.action);
}
public void setAction(MethodExpression action) {
    this.action = action;
}</pre>

<a name="bnavz"></a><h3>Saving and Restoring State</h3>
<a name="indexterm-857"></a><a name="indexterm-858"></a><a name="indexterm-859"></a><a name="indexterm-860"></a><a name="indexterm-861"></a><a name="indexterm-862"></a><p>As described in <a href="#bnavy">Enabling Component Properties to Accept Expressions</a>, use of the <tt>StateHelper</tt> interface facilities allows you to
save the component's state at the same time you set and retrieve property
values. The <tt>StateHelper</tt> implementation allows partial state saving: it saves only the changes
in the state since the initial request, not the entire state, because the
full state can be restored during the Restore View phase.</p>

<p>Component classes that implement <tt>StateHolder</tt> may prefer to implement the <tt>saveState(FacesContext)</tt> and <tt>restoreState(FacesContext, Object)</tt>
methods to help the JavaServer Faces implementation save and restore the full state
of components across multiple requests.</p>

<p>To save a set of values, you can implement the <tt>saveState(FacesContext)</tt> method.
This method is called during the Render Response phase, during which the state
of the response is saved for processing on subsequent requests. Here is a
hypothetical method from <tt>MapComponent</tt>, which has only one attribute, <tt>current</tt>:</p>

<pre>@Override
public Object saveState(FacesContext context) {
    Object values[] = new Object[2];
    values[0] = super.saveState(context);
    values[1] = current;
    return (values);
}</pre><p>This method initializes an array, which will hold the saved state. It next
saves all of the state associated with the component.</p>

<p><a name="indexterm-863"></a>A component that implements <tt>StateHolder</tt> may also provide an implementation for <tt>restoreState(FacesContext, Object)</tt>,
which restores the state of the component to that saved with the <tt>saveState(FacesContext)</tt>
method. The <tt>restoreState(FacesContext, Object)</tt> method is called during the Restore View phase, during which
the JavaServer Faces implementation checks whether there is any state that was saved
during the last Render Response phase and needs to be restored in preparation
for the next postback.</p>

<p>Here is a hypothetical <tt>restoreState(FacesContext, Object)</tt> method from <tt>MapComponent</tt>:</p>

<pre>public void restoreState(FacesContext context, Object state) {
    Object values[] = (Object[]) state;
    super.restoreState(context, values[0]);
    current = (String) values[1];
}</pre><p>This method takes a <tt>FacesContext</tt> and an <tt>Object</tt> instance, representing the array
that is holding the state for the component. This method sets the component&rsquo;s
properties to the values saved in the <tt>Object</tt> array.</p>

<p><a name="indexterm-864"></a>Whether or not you implement these methods in a component class, you can
use the <tt>javax.faces.STATE_SAVING_METHOD</tt> context parameter to specify in the deployment descriptor where you
want the state to be saved: either <tt>client</tt> or <tt>server</tt>. If state
is saved on the client, the state of the entire view is rendered
to a hidden field on the page. By default, the state is saved
on the server.</p>

<p>The web applications in the Duke's Forest case study save their view state
on the client.</p>

<p>Saving state on the client uses more bandwidth as well as more
client resources, while saving it on the server uses more server resources. You
may also want to save state on the client if you expect your
users to disable cookies.</p>


         </div>
         <div class="navigation">
             <a href="bnavt.html"><img src="graphics/leftButton.gif" border="0" alt="Previous" title="Previous"></a>
             <a href="p1.html"><img src="graphics/upButton.gif" border="0" alt="Contents" title="Contents"></a>
             <a href="bnawa.html"><img src="graphics/rightButton.gif" border="0" alt="Next" title="Next"></a>
         </div>

         <div class="copyright">
      	    <p>Copyright &copy; 2013, Oracle and/or its affiliates. All rights reserved. <a href="docinfo.html">Legal Notices</a></p>
      	 </div>

      </td>
   </tr>
</tbody>
</table>
<!-- Start SiteCatalyst code   -->
<script language="JavaScript" src="http://www.oracle.com/ocom/groups/systemobject/@mktg_admin/documents/systemobject/s_code_download.js"></script>
<script language="JavaScript" src="http://www.oracle.com/ocom/groups/systemobject/@mktg_admin/documents/systemobject/s_code.js"></script>
 
<!-- ********** DO NOT ALTER ANYTHING BELOW THIS LINE ! *********** -->
<!--  Below code will send the info to Omniture server -->
<script language="javascript">var s_code=s.t();if(s_code)document.write(s_code)</script>
<noscript><p>Scripting on this page tracks web page traffic,
but does not change the content in any way.</p></noscript>
<!-- End SiteCatalyst code -->
</body>
</html>

